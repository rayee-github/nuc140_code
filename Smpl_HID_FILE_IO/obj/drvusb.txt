; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\drvusb.o --depend=.\obj\drvusb.d --feedback=.\obj\Smpl_HID_FILE_IO.fed --cpu=Cortex-M0 --apcs=interwork -O0 -I.\ -I..\..\..\..\CMSIS\CM0\CoreSupport -I..\..\..\..\CMSIS\CM0\DeviceSupport\Nuvoton\NUC1xx -I..\..\..\Include -I..\..\..\Include\Driver -I..\..\..\Include\NUC1xx-LB_002 -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\ST\STM32F10x --omf_browse=.\obj\drvusb.crf ..\..\..\Src\Driver\DrvUSB.c]
                          THUMB

                          AREA ||i.DrvUSB_BusResetCallback||, CODE, READONLY, ALIGN=2

                  DrvUSB_BusResetCallback PROC
;;;525    /*---------------------------------------------------------------------------------------------------------*/
;;;526    void DrvUSB_BusResetCallback(void * pVoid)
000000  b530              PUSH     {r4,r5,lr}
;;;527    {
000002  4603              MOV      r3,r0
;;;528        S_DRVUSB_DEVICE *psDevice =&gsUsbDevice;
000004  4a1f              LDR      r2,|L1.132|
;;;529        int i;
;;;530    
;;;531        /* Reset function address of USB device */
;;;532        _DRVUSB_SET_FADDR(0x00);
000006  4820              LDR      r0,|L1.136|
000008  6880              LDR      r0,[r0,#8]
00000a  09c0              LSRS     r0,r0,#7
00000c  01c0              LSLS     r0,r0,#7
00000e  4c1e              LDR      r4,|L1.136|
000010  60a0              STR      r0,[r4,#8]
;;;533        
;;;534        /* Disable IN NAK Flag */
;;;535        USBD->INTEN.INNAK_EN = 0;
000012  4620              MOV      r0,r4
000014  6800              LDR      r0,[r0,#0]
000016  2401              MOVS     r4,#1
000018  03e4              LSLS     r4,r4,#15
00001a  43a0              BICS     r0,r0,r4
00001c  4c1a              LDR      r4,|L1.136|
00001e  6020              STR      r0,[r4,#0]
;;;536    
;;;537        _DRVUSB_SET_SETUP_BUF(USB_BUF_SETUP);
000020  f7fffffe          BL       DrvUSB_GetSetupBuffer
000024  4c19              LDR      r4,|L1.140|
000026  1b00              SUBS     r0,r0,r4
000028  4c17              LDR      r4,|L1.136|
00002a  61a0              STR      r0,[r4,#0x18]
;;;538        
;;;539        /* Initial USB EP according to EP description */    
;;;540        i = 0;
00002c  2100              MOVS     r1,#0
;;;541        while (sEpDescription[i].u32MaxPacketSize != 0)
00002e  e017              B        |L1.96|
                  |L1.48|
;;;542        {
;;;543            /* Write one to clear IN/OUT ready flag */
;;;544            _DRVUSB_SET_CFGP(i, 0x01);
000030  2001              MOVS     r0,#1
000032  010c              LSLS     r4,r1,#4
000034  4d14              LDR      r5,|L1.136|
000036  1964              ADDS     r4,r4,r5
000038  62e0              STR      r0,[r4,#0x2c]
;;;545            
;;;546            /* Initial USB EP CFG Setting */
;;;547            _DRVUSB_SET_CFG(i, CFG_EP_SETTING[i]);
00003a  0088              LSLS     r0,r1,#2
00003c  4c14              LDR      r4,|L1.144|
00003e  5820              LDR      r0,[r4,r0]
000040  0580              LSLS     r0,r0,#22
000042  0d80              LSRS     r0,r0,#22
000044  010c              LSLS     r4,r1,#4
000046  1964              ADDS     r4,r4,r5
000048  62a0              STR      r0,[r4,#0x28]
;;;548            _DRVUSB_SET_EP_BUF(i, (uint32_t)sEpDescription[i].u8SramBuffer);
00004a  200c              MOVS     r0,#0xc
00004c  4348              MULS     r0,r1,r0
00004e  4c11              LDR      r4,|L1.148|
000050  1900              ADDS     r0,r0,r4
000052  6880              LDR      r0,[r0,#8]
000054  4c0d              LDR      r4,|L1.140|
000056  1b00              SUBS     r0,r0,r4
000058  010c              LSLS     r4,r1,#4
00005a  1964              ADDS     r4,r4,r5
00005c  6220              STR      r0,[r4,#0x20]
;;;549            i++;
00005e  1c49              ADDS     r1,r1,#1
                  |L1.96|
000060  200c              MOVS     r0,#0xc               ;541
000062  4348              MULS     r0,r1,r0              ;541
000064  4c0b              LDR      r4,|L1.148|
000066  1900              ADDS     r0,r0,r4              ;541
000068  6840              LDR      r0,[r0,#4]            ;541
00006a  2800              CMP      r0,#0                 ;541
00006c  d1e0              BNE      |L1.48|
;;;550        }
;;;551    
;;;552        psDevice->u8UsbAddress = 0;
00006e  2400              MOVS     r4,#0
000070  2094              MOVS     r0,#0x94
000072  5484              STRB     r4,[r0,r2]
;;;553        psDevice->u8UsbConfiguration = 0;
000074  2095              MOVS     r0,#0x95
000076  5484              STRB     r4,[r0,r2]
;;;554        
;;;555        if(psDevice->eUsbState > eDRVUSB_DEFAULT)
000078  6fd0              LDR      r0,[r2,#0x7c]
00007a  2807              CMP      r0,#7
00007c  dd01              BLE      |L1.130|
;;;556            psDevice->eUsbState = eDRVUSB_DEFAULT;
00007e  2007              MOVS     r0,#7
000080  67d0              STR      r0,[r2,#0x7c]
                  |L1.130|
;;;557    }
000082  bd30              POP      {r4,r5,pc}
;;;558    
                          ENDP

                  |L1.132|
                          DCD      gsUsbDevice
                  |L1.136|
                          DCD      0x40060000
                  |L1.140|
                          DCD      0x40060100
                  |L1.144|
                          DCD      CFG_EP_SETTING
                  |L1.148|
                          DCD      sEpDescription

                          AREA ||i.DrvUSB_Close||, CODE, READONLY, ALIGN=2

                  DrvUSB_Close PROC
;;;325    /*---------------------------------------------------------------------------------------------------------*/
;;;326    void DrvUSB_Close(void)
000000  b510              PUSH     {r4,lr}
;;;327    {    
;;;328        NVIC_DisableIRQ(USBD_IRQn);
000002  bf00              NOP      
000004  2017              MOVS     r0,#0x17
000006  2101              MOVS     r1,#1
000008  4081              LSLS     r1,r1,r0
00000a  4803              LDR      r0,|L2.24|
00000c  6001              STR      r1,[r0,#0]
00000e  bf00              NOP      
;;;329        DrvUSB_UnInit();
000010  f7fffffe          BL       DrvUSB_UnInit
;;;330    }
000014  bd10              POP      {r4,pc}
;;;331    
                          ENDP

000016  0000              DCW      0x0000
                  |L2.24|
                          DCD      0xe000e180

                          AREA ||i.DrvUSB_ClrCtrlReady||, CODE, READONLY, ALIGN=2

                  DrvUSB_ClrCtrlReady PROC
;;;865    /*---------------------------------------------------------------------------------------------------------*/
;;;866    void DrvUSB_ClrCtrlReady(void)
000000  b510              PUSH     {r4,lr}
;;;867    {
;;;868        uint32_t u32EpId;
;;;869    
;;;870        u32EpId = DrvUSB_GetEpIdentity(0, EP_OUTPUT);
000002  2100              MOVS     r1,#0
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       DrvUSB_GetEpIdentity
00000a  4604              MOV      r4,r0
;;;871        _DRVUSB_CLEAR_EP_READY(u32EpId);
00000c  0120              LSLS     r0,r4,#4
00000e  490c              LDR      r1,|L3.64|
000010  1840              ADDS     r0,r0,r1
000012  6ac0              LDR      r0,[r0,#0x2c]
000014  2101              MOVS     r1,#1
000016  4308              ORRS     r0,r0,r1
000018  0121              LSLS     r1,r4,#4
00001a  4a09              LDR      r2,|L3.64|
00001c  1889              ADDS     r1,r1,r2
00001e  62c8              STR      r0,[r1,#0x2c]
;;;872        u32EpId = DrvUSB_GetEpIdentity(0, EP_INPUT);
000020  2180              MOVS     r1,#0x80
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       DrvUSB_GetEpIdentity
000028  4604              MOV      r4,r0
;;;873        _DRVUSB_CLEAR_EP_READY(u32EpId);
00002a  0120              LSLS     r0,r4,#4
00002c  4904              LDR      r1,|L3.64|
00002e  1840              ADDS     r0,r0,r1
000030  6ac0              LDR      r0,[r0,#0x2c]
000032  2101              MOVS     r1,#1
000034  4308              ORRS     r0,r0,r1
000036  0121              LSLS     r1,r4,#4
000038  4a01              LDR      r2,|L3.64|
00003a  1889              ADDS     r1,r1,r2
00003c  62c8              STR      r0,[r1,#0x2c]
;;;874    }
00003e  bd10              POP      {r4,pc}
;;;875    
                          ENDP

                  |L3.64|
                          DCD      0x40060000

                          AREA ||i.DrvUSB_ClrCtrlReadyAndTrigStall||, CODE, READONLY, ALIGN=2

                  DrvUSB_ClrCtrlReadyAndTrigStall PROC
;;;889    /*---------------------------------------------------------------------------------------------------------*/
;;;890    void DrvUSB_ClrCtrlReadyAndTrigStall(void)
000000  b510              PUSH     {r4,lr}
;;;891    {
;;;892        uint32_t u32EpId;
;;;893    
;;;894        u32EpId = DrvUSB_GetEpIdentity(0, EP_OUTPUT);
000002  2100              MOVS     r1,#0
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       DrvUSB_GetEpIdentity
00000a  4604              MOV      r4,r0
;;;895        _DRVUSB_CLEAR_EP_READY_AND_TRIG_STALL(u32EpId);
00000c  0120              LSLS     r0,r4,#4
00000e  490c              LDR      r1,|L4.64|
000010  1840              ADDS     r0,r0,r1
000012  6ac0              LDR      r0,[r0,#0x2c]
000014  2103              MOVS     r1,#3
000016  4308              ORRS     r0,r0,r1
000018  0121              LSLS     r1,r4,#4
00001a  4a09              LDR      r2,|L4.64|
00001c  1889              ADDS     r1,r1,r2
00001e  62c8              STR      r0,[r1,#0x2c]
;;;896        u32EpId = DrvUSB_GetEpIdentity(0, EP_INPUT);
000020  2180              MOVS     r1,#0x80
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       DrvUSB_GetEpIdentity
000028  4604              MOV      r4,r0
;;;897        _DRVUSB_CLEAR_EP_READY_AND_TRIG_STALL(u32EpId);
00002a  0120              LSLS     r0,r4,#4
00002c  4904              LDR      r1,|L4.64|
00002e  1840              ADDS     r0,r0,r1
000030  6ac0              LDR      r0,[r0,#0x2c]
000032  2103              MOVS     r1,#3
000034  4308              ORRS     r0,r0,r1
000036  0121              LSLS     r1,r4,#4
000038  4a01              LDR      r2,|L4.64|
00003a  1889              ADDS     r1,r1,r2
00003c  62c8              STR      r0,[r1,#0x2c]
;;;898    }
00003e  bd10              POP      {r4,pc}
;;;899    
                          ENDP

                  |L4.64|
                          DCD      0x40060000

                          AREA ||i.DrvUSB_CtrlDataInAck||, CODE, READONLY, ALIGN=2

                  DrvUSB_CtrlDataInAck PROC
;;;710    /*---------------------------------------------------------------------------------------------------------*/
;;;711    void DrvUSB_CtrlDataInAck(void * pArgu)
000000  b5f8              PUSH     {r3-r7,lr}
;;;712    {
000002  4607              MOV      r7,r0
;;;713        uint32_t i;
;;;714        S_DRVUSB_CTRL_CALLBACK_ENTRY *psEntry = 0;
000004  2400              MOVS     r4,#0
;;;715        S_DRVUSB_DEVICE *psDevice = &gsUsbDevice;
000006  4d11              LDR      r5,|L5.76|
;;;716    
;;;717        for (i = 0; i < psDevice->CtrlCallbackSize; i++)
000008  2600              MOVS     r6,#0
00000a  e018              B        |L5.62|
                  |L5.12|
;;;718        {
;;;719            psEntry = psDevice->pCtrlCallback + i;
00000c  2084              MOVS     r0,#0x84
00000e  5941              LDR      r1,[r0,r5]
000010  2014              MOVS     r0,#0x14
000012  4370              MULS     r0,r6,r0
000014  180c              ADDS     r4,r1,r0
;;;720            if (psEntry->pfnCtrlDataInCallback &&
000016  68a0              LDR      r0,[r4,#8]
000018  2800              CMP      r0,#0
00001a  d00f              BEQ      |L5.60|
;;;721                psEntry->u8RequestType == (psDevice->au8Setup[0] & 0x60) &&
00001c  7821              LDRB     r1,[r4,#0]
00001e  208c              MOVS     r0,#0x8c
000020  5d40              LDRB     r0,[r0,r5]
000022  2260              MOVS     r2,#0x60
000024  4010              ANDS     r0,r0,r2
000026  4281              CMP      r1,r0
000028  d108              BNE      |L5.60|
;;;722                psEntry->u8Request == psDevice->au8Setup[1])
00002a  7861              LDRB     r1,[r4,#1]
00002c  208d              MOVS     r0,#0x8d
00002e  5d40              LDRB     r0,[r0,r5]
000030  4281              CMP      r1,r0
000032  d103              BNE      |L5.60|
;;;723            {
;;;724                psEntry->pfnCtrlDataInCallback(psEntry->pVoid);
000034  68a1              LDR      r1,[r4,#8]
000036  6920              LDR      r0,[r4,#0x10]
000038  4788              BLX      r1
                  |L5.58|
;;;725                return;
;;;726            }
;;;727        }
;;;728        return;
;;;729    }
00003a  bdf8              POP      {r3-r7,pc}
                  |L5.60|
00003c  1c76              ADDS     r6,r6,#1              ;717
                  |L5.62|
00003e  2088              MOVS     r0,#0x88              ;717
000040  5940              LDR      r0,[r0,r5]            ;717
000042  42b0              CMP      r0,r6                 ;717
000044  d8e2              BHI      |L5.12|
000046  bf00              NOP                            ;728
000048  e7f7              B        |L5.58|
;;;730    
                          ENDP

00004a  0000              DCW      0x0000
                  |L5.76|
                          DCD      gsUsbDevice

                          AREA ||i.DrvUSB_CtrlDataInDefault||, CODE, READONLY, ALIGN=2

                  DrvUSB_CtrlDataInDefault PROC
;;;780    /*---------------------------------------------------------------------------------------------------------*/
;;;781    void DrvUSB_CtrlDataInDefault(void * pVoid)
000000  4601              MOV      r1,r0
;;;782    {
;;;783        S_DRVUSB_DEVICE *pInfraDevice = &gsUsbDevice;
000002  4805              LDR      r0,|L6.24|
;;;784        
;;;785        if (pInfraDevice->au8Setup[0] & 0x80)
000004  228c              MOVS     r2,#0x8c
000006  5c12              LDRB     r2,[r2,r0]
000008  2380              MOVS     r3,#0x80
00000a  421a              TST      r2,r3
00000c  d002              BEQ      |L6.20|
;;;786        {
;;;787            _DRVUSB_TRIG_EP(1, 0x00);
00000e  2200              MOVS     r2,#0
000010  4b02              LDR      r3,|L6.28|
000012  635a              STR      r2,[r3,#0x34]
                  |L6.20|
;;;788        }
;;;789    }
000014  4770              BX       lr
;;;790    
                          ENDP

000016  0000              DCW      0x0000
                  |L6.24|
                          DCD      gsUsbDevice
                  |L6.28|
                          DCD      0x40060000

                          AREA ||i.DrvUSB_CtrlDataInSetAddress||, CODE, READONLY, ALIGN=2

                  DrvUSB_CtrlDataInSetAddress PROC
;;;1780   /*---------------------------------------------------------------------------------------------------------*/
;;;1781   void DrvUSB_CtrlDataInSetAddress(void * pVoid)
000000  b500              PUSH     {lr}
;;;1782   {
000002  4603              MOV      r3,r0
;;;1783       S_DRVUSB_DEVICE *pInfraDevice = &gsUsbDevice;
000004  4a0b              LDR      r2,|L7.52|
;;;1784   
;;;1785       if (pInfraDevice->u8UsbAddress == 0x00)
000006  2094              MOVS     r0,#0x94
000008  5c80              LDRB     r0,[r0,r2]
00000a  2800              CMP      r0,#0
00000c  d103              BNE      |L7.22|
;;;1786       {
;;;1787           DrvUSB_SetUsbState(eDRVUSB_DEFAULT);
00000e  2007              MOVS     r0,#7
000010  f7fffffe          BL       DrvUSB_SetUsbState
000014  e00d              B        |L7.50|
                  |L7.22|
;;;1788       }
;;;1789       else
;;;1790       {
;;;1791           DrvUSB_SetUsbState(eDRVUSB_ADDRESS);
000016  200f              MOVS     r0,#0xf
000018  f7fffffe          BL       DrvUSB_SetUsbState
;;;1792           _DRVUSB_SET_FADDR(pInfraDevice->u8UsbAddress);
00001c  4806              LDR      r0,|L7.56|
00001e  6880              LDR      r0,[r0,#8]
000020  09c0              LSRS     r0,r0,#7
000022  01c0              LSLS     r0,r0,#7
000024  2194              MOVS     r1,#0x94
000026  5c89              LDRB     r1,[r1,r2]
000028  0649              LSLS     r1,r1,#25
00002a  0e49              LSRS     r1,r1,#25
00002c  4308              ORRS     r0,r0,r1
00002e  4902              LDR      r1,|L7.56|
000030  6088              STR      r0,[r1,#8]
                  |L7.50|
;;;1793       }   
;;;1794   }
000032  bd00              POP      {pc}
;;;1795   
                          ENDP

                  |L7.52|
                          DCD      gsUsbDevice
                  |L7.56|
                          DCD      0x40060000

                          AREA ||i.DrvUSB_CtrlDataOutAck||, CODE, READONLY, ALIGN=2

                  DrvUSB_CtrlDataOutAck PROC
;;;746    /*---------------------------------------------------------------------------------------------------------*/
;;;747    void DrvUSB_CtrlDataOutAck(void * pArgu)
000000  b5f8              PUSH     {r3-r7,lr}
;;;748    {
000002  4607              MOV      r7,r0
;;;749        uint32_t i;
;;;750        S_DRVUSB_CTRL_CALLBACK_ENTRY *psEntry = 0;
000004  2400              MOVS     r4,#0
;;;751        S_DRVUSB_DEVICE *psDevice = &gsUsbDevice;
000006  4d11              LDR      r5,|L8.76|
;;;752    
;;;753        for (i = 0; i < psDevice->CtrlCallbackSize; i++)
000008  2600              MOVS     r6,#0
00000a  e018              B        |L8.62|
                  |L8.12|
;;;754        {
;;;755            psEntry = psDevice->pCtrlCallback + i;
00000c  2084              MOVS     r0,#0x84
00000e  5941              LDR      r1,[r0,r5]
000010  2014              MOVS     r0,#0x14
000012  4370              MULS     r0,r6,r0
000014  180c              ADDS     r4,r1,r0
;;;756            if (psEntry->pfnCtrlDataOutCallback &&
000016  68e0              LDR      r0,[r4,#0xc]
000018  2800              CMP      r0,#0
00001a  d00f              BEQ      |L8.60|
;;;757                psEntry->u8RequestType == (psDevice->au8Setup[0] & 0x60) &&
00001c  7821              LDRB     r1,[r4,#0]
00001e  208c              MOVS     r0,#0x8c
000020  5d40              LDRB     r0,[r0,r5]
000022  2260              MOVS     r2,#0x60
000024  4010              ANDS     r0,r0,r2
000026  4281              CMP      r1,r0
000028  d108              BNE      |L8.60|
;;;758                psEntry->u8Request == psDevice->au8Setup[1])
00002a  7861              LDRB     r1,[r4,#1]
00002c  208d              MOVS     r0,#0x8d
00002e  5d40              LDRB     r0,[r0,r5]
000030  4281              CMP      r1,r0
000032  d103              BNE      |L8.60|
;;;759            {
;;;760                psEntry->pfnCtrlDataOutCallback(psEntry->pVoid);
000034  68e1              LDR      r1,[r4,#0xc]
000036  6920              LDR      r0,[r4,#0x10]
000038  4788              BLX      r1
                  |L8.58|
;;;761                return;
;;;762            }
;;;763        }
;;;764        return;
;;;765    }
00003a  bdf8              POP      {r3-r7,pc}
                  |L8.60|
00003c  1c76              ADDS     r6,r6,#1              ;753
                  |L8.62|
00003e  2088              MOVS     r0,#0x88              ;753
000040  5940              LDR      r0,[r0,r5]            ;753
000042  42b0              CMP      r0,r6                 ;753
000044  d8e2              BHI      |L8.12|
000046  bf00              NOP                            ;764
000048  e7f7              B        |L8.58|
;;;766    
                          ENDP

00004a  0000              DCW      0x0000
                  |L8.76|
                          DCD      gsUsbDevice

                          AREA ||i.DrvUSB_CtrlDataOutDefault||, CODE, READONLY, ALIGN=2

                  DrvUSB_CtrlDataOutDefault PROC
;;;805    /*---------------------------------------------------------------------------------------------------------*/
;;;806    void DrvUSB_CtrlDataOutDefault(void * pVoid)
000000  b530              PUSH     {r4,r5,lr}
;;;807    {
000002  4605              MOV      r5,r0
;;;808        S_DRVUSB_DEVICE *pInfraDevice = &gsUsbDevice;
000004  4c05              LDR      r4,|L9.28|
;;;809        
;;;810        if ((pInfraDevice->au8Setup[0] & 0x80) == 0)
000006  208c              MOVS     r0,#0x8c
000008  5d00              LDRB     r0,[r0,r4]
00000a  2180              MOVS     r1,#0x80
00000c  4208              TST      r0,r1
00000e  d104              BNE      |L9.26|
;;;811        {
;;;812            DrvUSB_DataIn(0, NULL, 0);
000010  2200              MOVS     r2,#0
000012  4611              MOV      r1,r2
000014  4610              MOV      r0,r2
000016  f7fffffe          BL       DrvUSB_DataIn
                  |L9.26|
;;;813        }
;;;814    }
00001a  bd30              POP      {r4,r5,pc}
;;;815    
                          ENDP

                  |L9.28|
                          DCD      gsUsbDevice

                          AREA ||i.DrvUSB_CtrlSetupAck||, CODE, READONLY, ALIGN=2

                  DrvUSB_CtrlSetupAck PROC
;;;647    /*---------------------------------------------------------------------------------------------------------*/
;;;648    void DrvUSB_CtrlSetupAck(void * pArgu)
000000  b5fe              PUSH     {r1-r7,lr}
;;;649    {
;;;650        uint32_t i;
;;;651        E_DRVUSB_STATE eUsbState;
;;;652        S_DRVUSB_CTRL_CALLBACK_ENTRY *psEntry = 0;
000002  2500              MOVS     r5,#0
;;;653        S_DRVUSB_DEVICE *psDevice = &gsUsbDevice;
000004  4e24              LDR      r6,|L10.152|
;;;654        uint8_t * SetupBuffer;
;;;655        volatile int32_t u32Delay;
;;;656    
;;;657        DrvUSB_ClrCtrlReady();
000006  f7fffffe          BL       DrvUSB_ClrCtrlReady
;;;658        
;;;659    
;;;660        /* check if after DEFAULT state (RESET) */
;;;661        eUsbState = DrvUSB_GetUsbState();
00000a  f7fffffe          BL       DrvUSB_GetUsbState
00000e  9001              STR      r0,[sp,#4]
;;;662        if (eUsbState < eDRVUSB_DEFAULT)
000010  9801              LDR      r0,[sp,#4]
000012  2807              CMP      r0,#7
000014  da02              BGE      |L10.28|
;;;663        {
;;;664            DrvUSB_ClrCtrlReadyAndTrigStall();
000016  f7fffffe          BL       DrvUSB_ClrCtrlReadyAndTrigStall
                  |L10.26|
;;;665            return;
;;;666        }
;;;667        SetupBuffer = (uint8_t *)DrvUSB_GetSetupBuffer();
;;;668        
;;;669        u32Delay = 0x1000;
;;;670        while(u32Delay--);
;;;671    
;;;672        for (i = 0; i < 8; i++)
;;;673        {
;;;674            psDevice->au8Setup[i] = SetupBuffer[i];
;;;675        }
;;;676        u32Delay = 0x1000;
;;;677        while(u32Delay--);
;;;678    
;;;679    
;;;680        for (i = 0; i < psDevice->CtrlCallbackSize; i++)
;;;681        {
;;;682            psEntry = psDevice->pCtrlCallback + i;
;;;683            if (psEntry->pfnCtrlSetupCallback &&
;;;684                psEntry->u8RequestType == (psDevice->au8Setup[0] & 0x60) &&
;;;685                psEntry->u8Request == psDevice->au8Setup[1])
;;;686            {
;;;687                psEntry->pfnCtrlSetupCallback(psEntry->pVoid);
;;;688                return;
;;;689            }
;;;690        }
;;;691        DrvUSB_ClrCtrlReadyAndTrigStall();
;;;692        return;
;;;693    }
00001a  bdfe              POP      {r1-r7,pc}
                  |L10.28|
00001c  f7fffffe          BL       DrvUSB_GetSetupBuffer
000020  9000              STR      r0,[sp,#0]            ;667
000022  2701              MOVS     r7,#1                 ;669
000024  033f              LSLS     r7,r7,#12             ;669
000026  bf00              NOP                            ;670
                  |L10.40|
000028  4638              MOV      r0,r7                 ;670
00002a  1e7f              SUBS     r7,r7,#1              ;670
00002c  2800              CMP      r0,#0                 ;670
00002e  d1fb              BNE      |L10.40|
000030  2400              MOVS     r4,#0                 ;672
000032  e005              B        |L10.64|
                  |L10.52|
000034  9800              LDR      r0,[sp,#0]            ;674
000036  5d01              LDRB     r1,[r0,r4]            ;674
000038  4630              MOV      r0,r6                 ;674
00003a  308c              ADDS     r0,r0,#0x8c           ;674
00003c  5501              STRB     r1,[r0,r4]            ;674
00003e  1c64              ADDS     r4,r4,#1              ;672
                  |L10.64|
000040  2c08              CMP      r4,#8                 ;672
000042  d3f7              BCC      |L10.52|
000044  2701              MOVS     r7,#1                 ;676
000046  033f              LSLS     r7,r7,#12             ;676
000048  bf00              NOP                            ;677
                  |L10.74|
00004a  4638              MOV      r0,r7                 ;677
00004c  1e7f              SUBS     r7,r7,#1              ;677
00004e  2800              CMP      r0,#0                 ;677
000050  d1fb              BNE      |L10.74|
000052  2400              MOVS     r4,#0                 ;680
000054  e018              B        |L10.136|
                  |L10.86|
000056  2084              MOVS     r0,#0x84              ;682
000058  5981              LDR      r1,[r0,r6]            ;682
00005a  2014              MOVS     r0,#0x14              ;682
00005c  4360              MULS     r0,r4,r0              ;682
00005e  180d              ADDS     r5,r1,r0              ;682
000060  6868              LDR      r0,[r5,#4]            ;683
000062  2800              CMP      r0,#0                 ;683
000064  d00f              BEQ      |L10.134|
000066  7829              LDRB     r1,[r5,#0]            ;684
000068  208c              MOVS     r0,#0x8c              ;684
00006a  5d80              LDRB     r0,[r0,r6]            ;684
00006c  2260              MOVS     r2,#0x60              ;684
00006e  4010              ANDS     r0,r0,r2              ;684
000070  4281              CMP      r1,r0                 ;684
000072  d108              BNE      |L10.134|
000074  7869              LDRB     r1,[r5,#1]            ;685
000076  208d              MOVS     r0,#0x8d              ;685
000078  5d80              LDRB     r0,[r0,r6]            ;685
00007a  4281              CMP      r1,r0                 ;685
00007c  d103              BNE      |L10.134|
00007e  6869              LDR      r1,[r5,#4]            ;687
000080  6928              LDR      r0,[r5,#0x10]         ;687
000082  4788              BLX      r1                    ;687
000084  e7c9              B        |L10.26|
                  |L10.134|
000086  1c64              ADDS     r4,r4,#1              ;680
                  |L10.136|
000088  2088              MOVS     r0,#0x88              ;680
00008a  5980              LDR      r0,[r0,r6]            ;680
00008c  42a0              CMP      r0,r4                 ;680
00008e  d8e2              BHI      |L10.86|
000090  f7fffffe          BL       DrvUSB_ClrCtrlReadyAndTrigStall
000094  bf00              NOP                            ;692
000096  e7c0              B        |L10.26|
;;;694    
                          ENDP

                  |L10.152|
                          DCD      gsUsbDevice

                          AREA ||i.DrvUSB_CtrlSetupClearSetFeature||, CODE, READONLY, ALIGN=2

                  DrvUSB_CtrlSetupClearSetFeature PROC
;;;1559   /*---------------------------------------------------------------------------------------------------------*/
;;;1560   void DrvUSB_CtrlSetupClearSetFeature(void * pVoid)
000000  b570              PUSH     {r4-r6,lr}
;;;1561   {
000002  4606              MOV      r6,r0
;;;1562       S_DRVUSB_DEVICE *pInfraDevice = &gsUsbDevice;
000004  4c2b              LDR      r4,|L11.180|
;;;1563       uint32_t u32EpId;
;;;1564       
;;;1565       /* Device */
;;;1566       if ((pInfraDevice->au8Setup[0] == 0x00) && (pInfraDevice->au8Setup[2] == FEATURE_DEVICE_REMOTE_WAKEUP))
000006  208c              MOVS     r0,#0x8c
000008  5d00              LDRB     r0,[r0,r4]
00000a  2800              CMP      r0,#0
00000c  d110              BNE      |L11.48|
00000e  208e              MOVS     r0,#0x8e
000010  5d00              LDRB     r0,[r0,r4]
000012  2801              CMP      r0,#1
000014  d10c              BNE      |L11.48|
;;;1567       {
;;;1568           if(pInfraDevice->au8Setup[1] == SET_FEATURE)
000016  208d              MOVS     r0,#0x8d
000018  5d00              LDRB     r0,[r0,r4]
00001a  2803              CMP      r0,#3
00001c  d101              BNE      |L11.34|
;;;1569               DrvUSB_EnableRemoteWakeup();
00001e  f7fffffe          BL       DrvUSB_EnableRemoteWakeup
                  |L11.34|
;;;1570           if(pInfraDevice->au8Setup[1] == CLEAR_FEATURE)
000022  208d              MOVS     r0,#0x8d
000024  5d00              LDRB     r0,[r0,r4]
000026  2801              CMP      r0,#1
000028  d13d              BNE      |L11.166|
;;;1571               DrvUSB_DisableRemoteWakeup();
00002a  f7fffffe          BL       DrvUSB_DisableRemoteWakeup
00002e  e03a              B        |L11.166|
                  |L11.48|
;;;1572       }
;;;1573       /* Interface */
;;;1574       else if (pInfraDevice->au8Setup[0] == 0x01);
000030  208c              MOVS     r0,#0x8c
000032  5d00              LDRB     r0,[r0,r4]
000034  2801              CMP      r0,#1
000036  d036              BEQ      |L11.166|
;;;1575       
;;;1576       /* Endpoint */
;;;1577       else if ((pInfraDevice->au8Setup[0] == 0x02) && (pInfraDevice->au8Setup[2] == FEATURE_ENDPOINT_HALT))
000038  208c              MOVS     r0,#0x8c
00003a  5d00              LDRB     r0,[r0,r4]
00003c  2802              CMP      r0,#2
00003e  d130              BNE      |L11.162|
000040  208e              MOVS     r0,#0x8e
000042  5d00              LDRB     r0,[r0,r4]
000044  2800              CMP      r0,#0
000046  d12c              BNE      |L11.162|
;;;1578       {
;;;1579           u32EpId = DrvUSB_GetEpId(pInfraDevice->au8Setup[4]);
000048  2190              MOVS     r1,#0x90
00004a  5d08              LDRB     r0,[r1,r4]
00004c  f7fffffe          BL       DrvUSB_GetEpId
000050  4605              MOV      r5,r0
;;;1580           
;;;1581           if (u32EpId < MAX_EP_ID)
000052  2d06              CMP      r5,#6
000054  d222              BCS      |L11.156|
;;;1582           {
;;;1583               _DRVUSB_CLEAR_EP_DSQ_SYNC(u32EpId);
000056  0128              LSLS     r0,r5,#4
000058  4917              LDR      r1,|L11.184|
00005a  1840              ADDS     r0,r0,r1
00005c  6a80              LDR      r0,[r0,#0x28]
00005e  2180              MOVS     r1,#0x80
000060  4388              BICS     r0,r0,r1
000062  0129              LSLS     r1,r5,#4
000064  4a14              LDR      r2,|L11.184|
000066  1889              ADDS     r1,r1,r2
000068  6288              STR      r0,[r1,#0x28]
;;;1584               if (pInfraDevice->au8Setup[1] == CLEAR_FEATURE)
00006a  208d              MOVS     r0,#0x8d
00006c  5d00              LDRB     r0,[r0,r4]
00006e  2801              CMP      r0,#1
000070  d109              BNE      |L11.134|
;;;1585               {
;;;1586                   _DRVUSB_CLEAR_EP_STALL(u32EpId);
000072  0128              LSLS     r0,r5,#4
000074  4611              MOV      r1,r2
000076  1840              ADDS     r0,r0,r1
000078  6ac0              LDR      r0,[r0,#0x2c]
00007a  2102              MOVS     r1,#2
00007c  4388              BICS     r0,r0,r1
00007e  0129              LSLS     r1,r5,#4
000080  1889              ADDS     r1,r1,r2
000082  62c8              STR      r0,[r1,#0x2c]
000084  e00f              B        |L11.166|
                  |L11.134|
;;;1587               }
;;;1588               else
;;;1589               {
;;;1590                   _DRVUSB_TRIG_EP_STALL(u32EpId);
000086  0128              LSLS     r0,r5,#4
000088  490b              LDR      r1,|L11.184|
00008a  1840              ADDS     r0,r0,r1
00008c  6ac0              LDR      r0,[r0,#0x2c]
00008e  2102              MOVS     r1,#2
000090  4308              ORRS     r0,r0,r1
000092  0129              LSLS     r1,r5,#4
000094  4a08              LDR      r2,|L11.184|
000096  1889              ADDS     r1,r1,r2
000098  62c8              STR      r0,[r1,#0x2c]
00009a  e004              B        |L11.166|
                  |L11.156|
;;;1591               }
;;;1592           }
;;;1593           else
;;;1594           {
;;;1595               DrvUSB_ClrCtrlReadyAndTrigStall();
00009c  f7fffffe          BL       DrvUSB_ClrCtrlReadyAndTrigStall
0000a0  e001              B        |L11.166|
                  |L11.162|
;;;1596           }
;;;1597       }
;;;1598       else
;;;1599       {
;;;1600           DrvUSB_ClrCtrlReadyAndTrigStall();
0000a2  f7fffffe          BL       DrvUSB_ClrCtrlReadyAndTrigStall
                  |L11.166|
;;;1601       }
;;;1602   
;;;1603       DrvUSB_DataIn(0, NULL, 0);  
0000a6  2200              MOVS     r2,#0
0000a8  4611              MOV      r1,r2
0000aa  4610              MOV      r0,r2
0000ac  f7fffffe          BL       DrvUSB_DataIn
;;;1604   }
0000b0  bd70              POP      {r4-r6,pc}
;;;1605   
                          ENDP

0000b2  0000              DCW      0x0000
                  |L11.180|
                          DCD      gsUsbDevice
                  |L11.184|
                          DCD      0x40060000

                          AREA ||i.DrvUSB_CtrlSetupGetConfiguration||, CODE, READONLY, ALIGN=2

                  DrvUSB_CtrlSetupGetConfiguration PROC
;;;1618   /*---------------------------------------------------------------------------------------------------------*/
;;;1619   void DrvUSB_CtrlSetupGetConfiguration(void * pVoid)
000000  b510              PUSH     {r4,lr}
;;;1620   {
000002  4604              MOV      r4,r0
;;;1621       DrvUSB_DataIn(0, &gsUsbDevice.u8UsbConfiguration, 1);   
000004  2201              MOVS     r2,#1
000006  4902              LDR      r1,|L12.16|
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       DrvUSB_DataIn
;;;1622   }
00000e  bd10              POP      {r4,pc}
;;;1623   
                          ENDP

                  |L12.16|
                          DCD      gsUsbDevice+0x95

                          AREA ||i.DrvUSB_CtrlSetupGetInterface||, CODE, READONLY, ALIGN=1

                  DrvUSB_CtrlSetupGetInterface PROC
;;;1688   /*---------------------------------------------------------------------------------------------------------*/
;;;1689   void DrvUSB_CtrlSetupGetInterface(void * pVoid)
000000  b518              PUSH     {r3,r4,lr}
;;;1690   {
000002  4604              MOV      r4,r0
;;;1691       const uint8_t c = 0x00;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;1692   
;;;1693       DrvUSB_DataIn(0, &c, 1);    
000008  2201              MOVS     r2,#1
00000a  4669              MOV      r1,sp
00000c  f7fffffe          BL       DrvUSB_DataIn
;;;1694   }
000010  bd18              POP      {r3,r4,pc}
;;;1695   
                          ENDP


                          AREA ||i.DrvUSB_CtrlSetupGetStatus||, CODE, READONLY, ALIGN=2

                  DrvUSB_CtrlSetupGetStatus PROC
;;;1636   /*---------------------------------------------------------------------------------------------------------*/
;;;1637   void DrvUSB_CtrlSetupGetStatus(void * pVoid)
000000  b578              PUSH     {r3-r6,lr}
;;;1638   {
000002  4606              MOV      r6,r0
;;;1639       uint8_t au8Buf[4];
;;;1640       S_DRVUSB_DEVICE *pInfraDevice = &gsUsbDevice;
000004  4c1c              LDR      r4,|L14.120|
;;;1641       uint32_t u32EpId;
;;;1642       
;;;1643       u32EpId = DrvUSB_GetEpId(pInfraDevice->au8Setup[4]);
000006  2190              MOVS     r1,#0x90
000008  5d08              LDRB     r0,[r1,r4]
00000a  f7fffffe          BL       DrvUSB_GetEpId
00000e  4605              MOV      r5,r0
;;;1644   
;;;1645       if (pInfraDevice->au8Setup[0] == 0x80)
000010  208c              MOVS     r0,#0x8c
000012  5d00              LDRB     r0,[r0,r4]
000014  2880              CMP      r0,#0x80
000016  d108              BNE      |L14.42|
;;;1646       {
;;;1647           au8Buf[0] = pInfraDevice->bRemoteWakeup << 1 | pInfraDevice->bSelfPowered;
000018  209c              MOVS     r0,#0x9c
00001a  5900              LDR      r0,[r0,r4]
00001c  0040              LSLS     r0,r0,#1
00001e  2198              MOVS     r1,#0x98
000020  5909              LDR      r1,[r1,r4]
000022  4308              ORRS     r0,r0,r1
000024  4669              MOV      r1,sp
000026  7008              STRB     r0,[r1,#0]
000028  e01d              B        |L14.102|
                  |L14.42|
;;;1648       }
;;;1649       else if (pInfraDevice->au8Setup[0] == 0x81)
00002a  208c              MOVS     r0,#0x8c
00002c  5d00              LDRB     r0,[r0,r4]
00002e  2881              CMP      r0,#0x81
000030  d103              BNE      |L14.58|
;;;1650       {
;;;1651           au8Buf[0] = 0x00;
000032  2000              MOVS     r0,#0
000034  4669              MOV      r1,sp
000036  7008              STRB     r0,[r1,#0]
000038  e015              B        |L14.102|
                  |L14.58|
;;;1652       }
;;;1653       else if (pInfraDevice->au8Setup[0] == 0x82)
00003a  208c              MOVS     r0,#0x8c
00003c  5d00              LDRB     r0,[r0,r4]
00003e  2882              CMP      r0,#0x82
000040  d10e              BNE      |L14.96|
;;;1654       {
;;;1655           if (u32EpId < MAX_EP_ID)
000042  2d06              CMP      r5,#6
000044  d209              BCS      |L14.90|
;;;1656           {
;;;1657               /* Interrupt-In Endpoint */
;;;1658               au8Buf[0] = (_DRVUSB_GET_CFGP(u32EpId) & CFGP_SSTALL) ? 1 : 0;
000046  0128              LSLS     r0,r5,#4
000048  490c              LDR      r1,|L14.124|
00004a  1840              ADDS     r0,r0,r1
00004c  6ac0              LDR      r0,[r0,#0x2c]
00004e  2102              MOVS     r1,#2
000050  4008              ANDS     r0,r0,r1
000052  0840              LSRS     r0,r0,#1
000054  4669              MOV      r1,sp
000056  7008              STRB     r0,[r1,#0]
000058  e005              B        |L14.102|
                  |L14.90|
;;;1659           }
;;;1660           else
;;;1661           {
;;;1662               DrvUSB_ClrCtrlReadyAndTrigStall();
00005a  f7fffffe          BL       DrvUSB_ClrCtrlReadyAndTrigStall
                  |L14.94|
;;;1663               return;
;;;1664           }
;;;1665       }
;;;1666       else
;;;1667       {
;;;1668           DrvUSB_ClrCtrlReadyAndTrigStall();
;;;1669           return;
;;;1670       }
;;;1671       au8Buf[1] = 0x00;
;;;1672   
;;;1673       DrvUSB_DataIn(0, au8Buf, 2);    
;;;1674   }
00005e  bd78              POP      {r3-r6,pc}
                  |L14.96|
000060  f7fffffe          BL       DrvUSB_ClrCtrlReadyAndTrigStall
000064  e7fb              B        |L14.94|
                  |L14.102|
000066  2000              MOVS     r0,#0                 ;1671
000068  4669              MOV      r1,sp                 ;1671
00006a  7048              STRB     r0,[r1,#1]            ;1671
00006c  2202              MOVS     r2,#2                 ;1673
00006e  f7fffffe          BL       DrvUSB_DataIn
000072  bf00              NOP      
000074  e7f3              B        |L14.94|
;;;1675   
                          ENDP

000076  0000              DCW      0x0000
                  |L14.120|
                          DCD      gsUsbDevice
                  |L14.124|
                          DCD      0x40060000

                          AREA ||i.DrvUSB_CtrlSetupSetAddress||, CODE, READONLY, ALIGN=2

                  DrvUSB_CtrlSetupSetAddress PROC
;;;1525   /*---------------------------------------------------------------------------------------------------------*/
;;;1526   void DrvUSB_CtrlSetupSetAddress(void * pVoid)
000000  b570              PUSH     {r4-r6,lr}
;;;1527   {
000002  4606              MOV      r6,r0
;;;1528       E_DRVUSB_STATE eUsbState;
;;;1529       S_DRVUSB_DEVICE *pInfraDevice = &gsUsbDevice;   
000004  4c0c              LDR      r4,|L15.56|
;;;1530   
;;;1531       eUsbState = DrvUSB_GetUsbState();
000006  f7fffffe          BL       DrvUSB_GetUsbState
00000a  4605              MOV      r5,r0
;;;1532       if (eUsbState == eDRVUSB_DEFAULT)
00000c  2d07              CMP      r5,#7
00000e  d10f              BNE      |L15.48|
;;;1533       {
;;;1534           pInfraDevice->u8UsbAddress = pInfraDevice->au8Setup[2];
000010  208e              MOVS     r0,#0x8e
000012  5d01              LDRB     r1,[r0,r4]
000014  2094              MOVS     r0,#0x94
000016  5501              STRB     r1,[r0,r4]
;;;1535           _DRVUSB_SET_EP_TOG_BIT(0, 0);
000018  4808              LDR      r0,|L15.60|
00001a  6a80              LDR      r0,[r0,#0x28]
00001c  2180              MOVS     r1,#0x80
00001e  4308              ORRS     r0,r0,r1
000020  4906              LDR      r1,|L15.60|
000022  6288              STR      r0,[r1,#0x28]
;;;1536           _DRVUSB_TRIG_EP(0, 0);
000024  2000              MOVS     r0,#0
000026  6248              STR      r0,[r1,#0x24]
;;;1537   
;;;1538           DrvUSB_SetUsbState(eDRVUSB_ADDRESS);
000028  200f              MOVS     r0,#0xf
00002a  f7fffffe          BL       DrvUSB_SetUsbState
00002e  e001              B        |L15.52|
                  |L15.48|
;;;1539   
;;;1540       }
;;;1541       else
;;;1542       {
;;;1543           DrvUSB_ClrCtrlReadyAndTrigStall();
000030  f7fffffe          BL       DrvUSB_ClrCtrlReadyAndTrigStall
                  |L15.52|
;;;1544       }
;;;1545   }
000034  bd70              POP      {r4-r6,pc}
;;;1546   
                          ENDP

000036  0000              DCW      0x0000
                  |L15.56|
                          DCD      gsUsbDevice
                  |L15.60|
                          DCD      0x40060000

                          AREA ||i.DrvUSB_CtrlSetupSetConfiguration||, CODE, READONLY, ALIGN=2

                  DrvUSB_CtrlSetupSetConfiguration PROC
;;;1732   /*---------------------------------------------------------------------------------------------------------*/
;;;1733   void DrvUSB_CtrlSetupSetConfiguration(void * pVoid)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1734   {
000002  4607              MOV      r7,r0
;;;1735       S_DRVUSB_DEVICE *pDrvDevice = &gsUsbDevice;
000004  4c1a              LDR      r4,|L16.112|
;;;1736       S_DRVUSB_CLASS *psUsbClass = pDrvDevice->psUsbClass;
000006  20a4              MOVS     r0,#0xa4
000008  5905              LDR      r5,[r0,r4]
;;;1737       int32_t bIsDeviceConfigure;
;;;1738       
;;;1739       bIsDeviceConfigure = psUsbClass->pfnCompare ? psUsbClass->pfnCompare(pDrvDevice->au8Setup[2]) : 1;
00000a  68a8              LDR      r0,[r5,#8]
00000c  2800              CMP      r0,#0
00000e  d004              BEQ      |L16.26|
000010  228e              MOVS     r2,#0x8e
000012  5d10              LDRB     r0,[r2,r4]
000014  68a9              LDR      r1,[r5,#8]
000016  4788              BLX      r1
000018  e000              B        |L16.28|
                  |L16.26|
00001a  2001              MOVS     r0,#1
                  |L16.28|
00001c  4606              MOV      r6,r0
;;;1740       
;;;1741       if (pDrvDevice->au8Setup[2] == 0)
00001e  208e              MOVS     r0,#0x8e
000020  5d00              LDRB     r0,[r0,r4]
000022  2800              CMP      r0,#0
000024  d10c              BNE      |L16.64|
;;;1742       {
;;;1743           /* USB address state */
;;;1744           DrvUSB_SetUsbState(eDRVUSB_ADDRESS);
000026  200f              MOVS     r0,#0xf
000028  f7fffffe          BL       DrvUSB_SetUsbState
;;;1745           pDrvDevice->u8UsbConfiguration = pDrvDevice->au8Setup[2];
00002c  208e              MOVS     r0,#0x8e
00002e  5d01              LDRB     r1,[r0,r4]
000030  2095              MOVS     r0,#0x95
000032  5501              STRB     r1,[r0,r4]
;;;1746           DrvUSB_DataIn(0, NULL, 0);
000034  2200              MOVS     r2,#0
000036  4611              MOV      r1,r2
000038  4610              MOV      r0,r2
00003a  f7fffffe          BL       DrvUSB_DataIn
00003e  e016              B        |L16.110|
                  |L16.64|
;;;1747       }
;;;1748       else if (bIsDeviceConfigure)
000040  2e00              CMP      r6,#0
000042  d012              BEQ      |L16.106|
;;;1749       {
;;;1750           /* USB configured state */
;;;1751           DrvUSB_SetUsbState(eDRVUSB_CONFIGURED);
000044  201f              MOVS     r0,#0x1f
000046  f7fffffe          BL       DrvUSB_SetUsbState
;;;1752   
;;;1753           /* Call USB class's start function */
;;;1754           if(psUsbClass->pfnStart)
00004a  6868              LDR      r0,[r5,#4]
00004c  2800              CMP      r0,#0
00004e  d002              BEQ      |L16.86|
;;;1755               psUsbClass->pfnStart(pVoid);
000050  4638              MOV      r0,r7
000052  6869              LDR      r1,[r5,#4]
000054  4788              BLX      r1
                  |L16.86|
;;;1756   
;;;1757           pDrvDevice->u8UsbConfiguration = pDrvDevice->au8Setup[2];
000056  208e              MOVS     r0,#0x8e
000058  5d01              LDRB     r1,[r0,r4]
00005a  2095              MOVS     r0,#0x95
00005c  5501              STRB     r1,[r0,r4]
;;;1758   
;;;1759           DrvUSB_DataIn(0, NULL, 0);
00005e  2200              MOVS     r2,#0
000060  4611              MOV      r1,r2
000062  4610              MOV      r0,r2
000064  f7fffffe          BL       DrvUSB_DataIn
000068  e001              B        |L16.110|
                  |L16.106|
;;;1760       }
;;;1761       else
;;;1762       {
;;;1763           /* Not support. Reply STALL */
;;;1764           DrvUSB_ClrCtrlReadyAndTrigStall();
00006a  f7fffffe          BL       DrvUSB_ClrCtrlReadyAndTrigStall
                  |L16.110|
;;;1765       }   
;;;1766   }
00006e  bdf8              POP      {r3-r7,pc}
;;;1767   
                          ENDP

                  |L16.112|
                          DCD      gsUsbDevice

                          AREA ||i.DrvUSB_CtrlSetupSetInterface||, CODE, READONLY, ALIGN=2

                  DrvUSB_CtrlSetupSetInterface PROC
;;;1708   /*---------------------------------------------------------------------------------------------------------*/
;;;1709   void DrvUSB_CtrlSetupSetInterface(void * pVoid)
000000  b570              PUSH     {r4-r6,lr}
;;;1710   {
000002  4606              MOV      r6,r0
;;;1711       S_DRVUSB_DEVICE *pDrvDevice = &gsUsbDevice;
000004  4d07              LDR      r5,|L17.36|
;;;1712       S_DRVUSB_CLASS *psUsbClass = pDrvDevice->psUsbClass;
000006  20a4              MOVS     r0,#0xa4
000008  5944              LDR      r4,[r0,r5]
;;;1713       
;;;1714       if(psUsbClass->pfnStart)
00000a  6860              LDR      r0,[r4,#4]
00000c  2800              CMP      r0,#0
00000e  d002              BEQ      |L17.22|
;;;1715           psUsbClass->pfnStart(pVoid);
000010  4630              MOV      r0,r6
000012  6861              LDR      r1,[r4,#4]
000014  4788              BLX      r1
                  |L17.22|
;;;1716   
;;;1717       DrvUSB_DataIn(0, NULL, 0);
000016  2200              MOVS     r2,#0
000018  4611              MOV      r1,r2
00001a  4610              MOV      r0,r2
00001c  f7fffffe          BL       DrvUSB_DataIn
;;;1718   }
000020  bd70              POP      {r4-r6,pc}
;;;1719   
                          ENDP

000022  0000              DCW      0x0000
                  |L17.36|
                          DCD      gsUsbDevice

                          AREA ||i.DrvUSB_DataIn||, CODE, READONLY, ALIGN=2

                  DrvUSB_DataIn PROC
;;;480    /*---------------------------------------------------------------------------------------------------------*/
;;;481    int32_t DrvUSB_DataIn(uint32_t u32EpNum, const uint8_t * u8Buffer, uint32_t u32Size)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;482    {
000002  460f              MOV      r7,r1
000004  4616              MOV      r6,r2
;;;483        S_DRVUSB_DEVICE *psDevice = &gsUsbDevice;
000006  4d2f              LDR      r5,|L18.196|
;;;484        uint32_t u32EpId;
;;;485        
;;;486        u32EpId = DrvUSB_GetEpIdentity(u32EpNum, EP_INPUT);
000008  2180              MOVS     r1,#0x80
00000a  9800              LDR      r0,[sp,#0]
00000c  f7fffffe          BL       DrvUSB_GetEpIdentity
000010  4604              MOV      r4,r0
;;;487        
;;;488        if (u32Size > psDevice->sEpCrl[u32EpId].u32MaxPacketSize)
000012  200c              MOVS     r0,#0xc
000014  4360              MULS     r0,r4,r0
000016  4629              MOV      r1,r5
000018  3128              ADDS     r1,r1,#0x28
00001a  1840              ADDS     r0,r0,r1
00001c  6840              LDR      r0,[r0,#4]
00001e  42b0              CMP      r0,r6
000020  d201              BCS      |L18.38|
;;;489            return E_DRVUSB_SIZE_TOO_LONG;
000022  4829              LDR      r0,|L18.200|
                  |L18.36|
;;;490    
;;;491        
;;;492        if (u8Buffer && u32Size)
;;;493        {
;;;494            WordsCpy(psDevice->sEpCrl[u32EpId].u8SramBuffer, (void *)u8Buffer, u32Size);
;;;495        }
;;;496        
;;;497        _DRVUSB_SET_EP_BUF(u32EpId, (uint32_t)psDevice->sEpCrl[u32EpId].u8SramBuffer);
;;;498        
;;;499        if (u8Buffer == NULL && u32Size == 0)
;;;500            psDevice->abData0[u32EpId] = 0;
;;;501        else
;;;502            psDevice->abData0[u32EpId] = !psDevice->abData0[u32EpId];
;;;503        
;;;504        _DRVUSB_SET_EP_TOG_BIT(u32EpId, psDevice->abData0[u32EpId]);
;;;505        _DRVUSB_TRIG_EP(u32EpId, u32Size);
;;;506        
;;;507        return 0;
;;;508    }
000024  bdfe              POP      {r1-r7,pc}
                  |L18.38|
000026  2f00              CMP      r7,#0                 ;492
000028  d00b              BEQ      |L18.66|
00002a  2e00              CMP      r6,#0                 ;492
00002c  d009              BEQ      |L18.66|
00002e  210c              MOVS     r1,#0xc               ;494
000030  4361              MULS     r1,r4,r1              ;494
000032  462a              MOV      r2,r5                 ;494
000034  3228              ADDS     r2,r2,#0x28           ;494
000036  1889              ADDS     r1,r1,r2              ;494
000038  4632              MOV      r2,r6                 ;494
00003a  6888              LDR      r0,[r1,#8]            ;494
00003c  4639              MOV      r1,r7                 ;494
00003e  f7fffffe          BL       WordsCpy
                  |L18.66|
000042  200c              MOVS     r0,#0xc               ;497
000044  4360              MULS     r0,r4,r0              ;497
000046  4629              MOV      r1,r5                 ;497
000048  3128              ADDS     r1,r1,#0x28           ;497
00004a  1840              ADDS     r0,r0,r1              ;497
00004c  6880              LDR      r0,[r0,#8]            ;497
00004e  491f              LDR      r1,|L18.204|
000050  1a40              SUBS     r0,r0,r1              ;497
000052  0121              LSLS     r1,r4,#4              ;497
000054  4a1e              LDR      r2,|L18.208|
000056  1889              ADDS     r1,r1,r2              ;497
000058  6208              STR      r0,[r1,#0x20]         ;497
00005a  2f00              CMP      r7,#0                 ;499
00005c  d107              BNE      |L18.110|
00005e  2e00              CMP      r6,#0                 ;499
000060  d105              BNE      |L18.110|
000062  2100              MOVS     r1,#0                 ;500
000064  00a2              LSLS     r2,r4,#2              ;500
000066  4628              MOV      r0,r5                 ;500
000068  3010              ADDS     r0,r0,#0x10           ;500
00006a  5081              STR      r1,[r0,r2]            ;500
00006c  e00c              B        |L18.136|
                  |L18.110|
00006e  00a1              LSLS     r1,r4,#2              ;502
000070  4628              MOV      r0,r5                 ;502
000072  3010              ADDS     r0,r0,#0x10           ;502
000074  5840              LDR      r0,[r0,r1]            ;502
000076  2800              CMP      r0,#0                 ;502
000078  d101              BNE      |L18.126|
00007a  2101              MOVS     r1,#1                 ;502
00007c  e000              B        |L18.128|
                  |L18.126|
00007e  2100              MOVS     r1,#0                 ;502
                  |L18.128|
000080  00a2              LSLS     r2,r4,#2              ;502
000082  4628              MOV      r0,r5                 ;502
000084  3010              ADDS     r0,r0,#0x10           ;502
000086  5081              STR      r1,[r0,r2]            ;502
                  |L18.136|
000088  00a1              LSLS     r1,r4,#2              ;504
00008a  4628              MOV      r0,r5                 ;504
00008c  3010              ADDS     r0,r0,#0x10           ;504
00008e  5840              LDR      r0,[r0,r1]            ;504
000090  2800              CMP      r0,#0                 ;504
000092  d006              BEQ      |L18.162|
000094  0120              LSLS     r0,r4,#4              ;504
000096  490e              LDR      r1,|L18.208|
000098  1840              ADDS     r0,r0,r1              ;504
00009a  6a80              LDR      r0,[r0,#0x28]         ;504
00009c  490d              LDR      r1,|L18.212|
00009e  4008              ANDS     r0,r0,r1              ;504
0000a0  e005              B        |L18.174|
                  |L18.162|
0000a2  0120              LSLS     r0,r4,#4              ;504
0000a4  490a              LDR      r1,|L18.208|
0000a6  1840              ADDS     r0,r0,r1              ;504
0000a8  6a80              LDR      r0,[r0,#0x28]         ;504
0000aa  2180              MOVS     r1,#0x80              ;504
0000ac  4308              ORRS     r0,r0,r1              ;504
                  |L18.174|
0000ae  0121              LSLS     r1,r4,#4              ;504
0000b0  4a07              LDR      r2,|L18.208|
0000b2  1889              ADDS     r1,r1,r2              ;504
0000b4  6288              STR      r0,[r1,#0x28]         ;504
0000b6  0120              LSLS     r0,r4,#4              ;505
0000b8  4611              MOV      r1,r2                 ;505
0000ba  1840              ADDS     r0,r0,r1              ;505
0000bc  6246              STR      r6,[r0,#0x24]         ;505
0000be  2000              MOVS     r0,#0                 ;507
0000c0  e7b0              B        |L18.36|
;;;509    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L18.196|
                          DCD      gsUsbDevice
                  |L18.200|
                          DCD      0xffff9903
                  |L18.204|
                          DCD      0x40060100
                  |L18.208|
                          DCD      0x40060000
                  |L18.212|
                          DCD      0x0000037f

                          AREA ||i.DrvUSB_DataOutTrigger||, CODE, READONLY, ALIGN=2

                  DrvUSB_DataOutTrigger PROC
;;;416    /*---------------------------------------------------------------------------------------------------------*/
;;;417    int32_t DrvUSB_DataOutTrigger(uint32_t u32EpNum, uint32_t u32Size)
000000  b5f0              PUSH     {r4-r7,lr}
;;;418    {
000002  4607              MOV      r7,r0
000004  460d              MOV      r5,r1
;;;419        uint32_t u32EpId;
;;;420        S_DRVUSB_DEVICE *psDevice = &gsUsbDevice;
000006  4e11              LDR      r6,|L19.76|
;;;421        
;;;422        u32EpId = DrvUSB_GetEpIdentity(u32EpNum, EP_OUTPUT);
000008  2100              MOVS     r1,#0
00000a  4638              MOV      r0,r7
00000c  f7fffffe          BL       DrvUSB_GetEpIdentity
000010  4604              MOV      r4,r0
;;;423        
;;;424        if (u32Size > psDevice->sEpCrl[u32EpId].u32MaxPacketSize)
000012  200c              MOVS     r0,#0xc
000014  4360              MULS     r0,r4,r0
000016  4631              MOV      r1,r6
000018  3128              ADDS     r1,r1,#0x28
00001a  1840              ADDS     r0,r0,r1
00001c  6840              LDR      r0,[r0,#4]
00001e  42a8              CMP      r0,r5
000020  d201              BCS      |L19.38|
;;;425            return E_DRVUSB_SIZE_TOO_LONG;
000022  480b              LDR      r0,|L19.80|
                  |L19.36|
;;;426    
;;;427            
;;;428        _DRVUSB_SET_EP_BUF(u32EpId, (uint32_t)psDevice->sEpCrl[u32EpId].u8SramBuffer);
;;;429        _DRVUSB_TRIG_EP(u32EpId, u32Size);
;;;430        
;;;431        return 0;
;;;432    }
000024  bdf0              POP      {r4-r7,pc}
                  |L19.38|
000026  200c              MOVS     r0,#0xc               ;428
000028  4360              MULS     r0,r4,r0              ;428
00002a  4631              MOV      r1,r6                 ;428
00002c  3128              ADDS     r1,r1,#0x28           ;428
00002e  1840              ADDS     r0,r0,r1              ;428
000030  6880              LDR      r0,[r0,#8]            ;428
000032  4908              LDR      r1,|L19.84|
000034  1a40              SUBS     r0,r0,r1              ;428
000036  0121              LSLS     r1,r4,#4              ;428
000038  4a07              LDR      r2,|L19.88|
00003a  1889              ADDS     r1,r1,r2              ;428
00003c  6208              STR      r0,[r1,#0x20]         ;428
00003e  0120              LSLS     r0,r4,#4              ;429
000040  4611              MOV      r1,r2                 ;429
000042  1840              ADDS     r0,r0,r1              ;429
000044  6245              STR      r5,[r0,#0x24]         ;429
000046  2000              MOVS     r0,#0                 ;431
000048  e7ec              B        |L19.36|
;;;433    
                          ENDP

00004a  0000              DCW      0x0000
                  |L19.76|
                          DCD      gsUsbDevice
                  |L19.80|
                          DCD      0xffff9903
                  |L19.84|
                          DCD      0x40060100
                  |L19.88|
                          DCD      0x40060000

                          AREA ||i.DrvUSB_DisableRemoteWakeup||, CODE, READONLY, ALIGN=2

                  DrvUSB_DisableRemoteWakeup PROC
;;;1030   /*---------------------------------------------------------------------------------------------------------*/
;;;1031   void DrvUSB_DisableRemoteWakeup(void)
000000  2100              MOVS     r1,#0
;;;1032   {   
;;;1033       gsUsbDevice.bRemoteWakeup = 0;
000002  4801              LDR      r0,|L20.8|
000004  61c1              STR      r1,[r0,#0x1c]
;;;1034   }
000006  4770              BX       lr
;;;1035   
                          ENDP

                  |L20.8|
                          DCD      gsUsbDevice+0x80

                          AREA ||i.DrvUSB_DisableSelfPower||, CODE, READONLY, ALIGN=2

                  DrvUSB_DisableSelfPower PROC
;;;972    /*---------------------------------------------------------------------------------------------------------*/
;;;973    void DrvUSB_DisableSelfPower(void)
000000  2100              MOVS     r1,#0
;;;974    {   
;;;975        gsUsbDevice.bSelfPowered = 0; 
000002  4801              LDR      r0,|L21.8|
000004  6181              STR      r1,[r0,#0x18]
;;;976    }
000006  4770              BX       lr
;;;977    
                          ENDP

                  |L21.8|
                          DCD      gsUsbDevice+0x80

                          AREA ||i.DrvUSB_DisableUsb||, CODE, READONLY, ALIGN=2

                  DrvUSB_DisableUsb PROC
;;;1137   /*---------------------------------------------------------------------------------------------------------*/
;;;1138   void DrvUSB_DisableUsb(S_DRVUSB_DEVICE *psDevice)
000000  213b              MOVS     r1,#0x3b
;;;1139   {
;;;1140       _DRVUSB_DISABLE_USB();  /* disable USB & PHY */
000002  0149              LSLS     r1,r1,#5
000004  4a01              LDR      r2,|L22.12|
000006  6111              STR      r1,[r2,#0x10]
;;;1141   }
000008  4770              BX       lr
;;;1142   
                          ENDP

00000a  0000              DCW      0x0000
                  |L22.12|
                          DCD      0x40060000

                          AREA ||i.DrvUSB_DispatchEPEvent||, CODE, READONLY, ALIGN=2

                  DrvUSB_DispatchEPEvent PROC
;;;1435   /*---------------------------------------------------------------------------------------------------------*/
;;;1436   void DrvUSB_DispatchEPEvent(S_DRVUSB_DEVICE *psDevice)
000000  b570              PUSH     {r4-r6,lr}
;;;1437   {
000002  4605              MOV      r5,r0
;;;1438       int32_t i;
;;;1439       
;;;1440       for (i=0;i<12;i++)
000004  2400              MOVS     r4,#0
000006  e019              B        |L23.60|
                  |L23.8|
;;;1441       {
;;;1442           if ((psDevice->u16EPEventFlags >> i)&1)
000008  2082              MOVS     r0,#0x82
00000a  5b40              LDRH     r0,[r0,r5]
00000c  4120              ASRS     r0,r0,r4
00000e  07c0              LSLS     r0,r0,#31
000010  0fc0              LSRS     r0,r0,#31
000012  d012              BEQ      |L23.58|
;;;1443           {
;;;1444               psDevice->u16EPEventFlags &= ~(1 << i);
000014  2082              MOVS     r0,#0x82
000016  5b40              LDRH     r0,[r0,r5]
000018  2101              MOVS     r1,#1
00001a  40a1              LSLS     r1,r1,r4
00001c  4388              BICS     r0,r0,r1
00001e  2182              MOVS     r1,#0x82
000020  5348              STRH     r0,[r1,r5]
;;;1445               /* Call the corresponding event handler. */
;;;1446               if (g_sUsbOps[i].apfnCallback != 0)
000022  00e0              LSLS     r0,r4,#3
000024  4907              LDR      r1,|L23.68|
000026  5808              LDR      r0,[r1,r0]
000028  2800              CMP      r0,#0
00002a  d006              BEQ      |L23.58|
;;;1447               {
;;;1448                   g_sUsbOps[i].apfnCallback(g_sUsbOps[i].apCallbackArgu);
00002c  00e2              LSLS     r2,r4,#3
00002e  460b              MOV      r3,r1
000030  18d2              ADDS     r2,r2,r3
000032  6850              LDR      r0,[r2,#4]
000034  00e2              LSLS     r2,r4,#3
000036  5899              LDR      r1,[r3,r2]
000038  4788              BLX      r1
                  |L23.58|
00003a  1c64              ADDS     r4,r4,#1              ;1440
                  |L23.60|
00003c  2c0c              CMP      r4,#0xc               ;1440
00003e  dbe3              BLT      |L23.8|
;;;1449               }       
;;;1450           }
;;;1451       }
;;;1452   }
000040  bd70              POP      {r4-r6,pc}
;;;1453   
                          ENDP

000042  0000              DCW      0x0000
                  |L23.68|
                          DCD      g_sUsbOps

                          AREA ||i.DrvUSB_DispatchEvent||, CODE, READONLY, ALIGN=2

                  DrvUSB_DispatchEvent PROC
;;;237    /*---------------------------------------------------------------------------------------------------------*/
;;;238    void DrvUSB_DispatchEvent(void)
000000  b510              PUSH     {r4,lr}
;;;239    {
;;;240        DrvUSB_DispatchMiscEvent(&gsUsbDevice);
000002  4803              LDR      r0,|L24.16|
000004  f7fffffe          BL       DrvUSB_DispatchMiscEvent
;;;241        DrvUSB_DispatchEPEvent(&gsUsbDevice);
000008  4801              LDR      r0,|L24.16|
00000a  f7fffffe          BL       DrvUSB_DispatchEPEvent
;;;242    }							
00000e  bd10              POP      {r4,pc}
;;;243    
                          ENDP

                  |L24.16|
                          DCD      gsUsbDevice

                          AREA ||i.DrvUSB_DispatchMiscEvent||, CODE, READONLY, ALIGN=2

                  DrvUSB_DispatchMiscEvent PROC
;;;1400   /*---------------------------------------------------------------------------------------------------------*/
;;;1401   void DrvUSB_DispatchMiscEvent(S_DRVUSB_DEVICE *psDevice)
000000  b570              PUSH     {r4-r6,lr}
;;;1402   {
000002  4605              MOV      r5,r0
;;;1403       uint16_t u16MiscEventFlags;
;;;1404       int32_t i;
;;;1405       
;;;1406       u16MiscEventFlags = psDevice->u16MiscEventFlags;
000004  2080              MOVS     r0,#0x80
000006  5b46              LDRH     r6,[r0,r5]
;;;1407       for (i=0;i<6;i++)
000008  2400              MOVS     r4,#0
00000a  e017              B        |L25.60|
                  |L25.12|
;;;1408       {
;;;1409           if (u16MiscEventFlags & (1 << i))
00000c  2001              MOVS     r0,#1
00000e  40a0              LSLS     r0,r0,r4
000010  4230              TST      r0,r6
000012  d012              BEQ      |L25.58|
;;;1410           {           
;;;1411               psDevice->u16MiscEventFlags &= ~(1 << i);
000014  2080              MOVS     r0,#0x80
000016  5b40              LDRH     r0,[r0,r5]
000018  2101              MOVS     r1,#1
00001a  40a1              LSLS     r1,r1,r4
00001c  4388              BICS     r0,r0,r1
00001e  2180              MOVS     r1,#0x80
000020  5348              STRH     r0,[r1,r5]
;;;1412           
;;;1413               if (g_sBusOps[i].apfnCallback != 0)
000022  00e0              LSLS     r0,r4,#3
000024  4907              LDR      r1,|L25.68|
000026  5808              LDR      r0,[r1,r0]
000028  2800              CMP      r0,#0
00002a  d006              BEQ      |L25.58|
;;;1414               {
;;;1415                   g_sBusOps[i].apfnCallback(g_sBusOps[i].apCallbackArgu);
00002c  00e2              LSLS     r2,r4,#3
00002e  460b              MOV      r3,r1
000030  18d2              ADDS     r2,r2,r3
000032  6850              LDR      r0,[r2,#4]
000034  00e2              LSLS     r2,r4,#3
000036  5899              LDR      r1,[r3,r2]
000038  4788              BLX      r1
                  |L25.58|
00003a  1c64              ADDS     r4,r4,#1              ;1407
                  |L25.60|
00003c  2c06              CMP      r4,#6                 ;1407
00003e  dbe5              BLT      |L25.12|
;;;1416               }
;;;1417           }
;;;1418       }   
;;;1419   }
000040  bd70              POP      {r4-r6,pc}
;;;1420   
                          ENDP

000042  0000              DCW      0x0000
                  |L25.68|
                          DCD      g_sBusOps

                          AREA ||i.DrvUSB_DispatchWakeupEvent||, CODE, READONLY, ALIGN=1

                  DrvUSB_DispatchWakeupEvent PROC
;;;1381   /*---------------------------------------------------------------------------------------------------------*/
;;;1382   void DrvUSB_DispatchWakeupEvent(S_DRVUSB_DEVICE *psDevice)
000000  4770              BX       lr
;;;1383   {
;;;1384   
;;;1385   }
;;;1386   
                          ENDP


                          AREA ||i.DrvUSB_EnableRemoteWakeup||, CODE, READONLY, ALIGN=2

                  DrvUSB_EnableRemoteWakeup PROC
;;;1011   /*---------------------------------------------------------------------------------------------------------*/
;;;1012   void DrvUSB_EnableRemoteWakeup(void)
000000  2101              MOVS     r1,#1
;;;1013   {   
;;;1014       gsUsbDevice.bRemoteWakeup = 1;  
000002  4801              LDR      r0,|L27.8|
000004  61c1              STR      r1,[r0,#0x1c]
;;;1015   }
000006  4770              BX       lr
;;;1016   
                          ENDP

                  |L27.8|
                          DCD      gsUsbDevice+0x80

                          AREA ||i.DrvUSB_EnableSelfPower||, CODE, READONLY, ALIGN=2

                  DrvUSB_EnableSelfPower PROC
;;;953    /*---------------------------------------------------------------------------------------------------------*/
;;;954    void DrvUSB_EnableSelfPower (void)
000000  2101              MOVS     r1,#1
;;;955    {   
;;;956        gsUsbDevice.bSelfPowered = 1; 
000002  4801              LDR      r0,|L28.8|
000004  6181              STR      r1,[r0,#0x18]
;;;957    }
000006  4770              BX       lr
;;;958    
                          ENDP

                  |L28.8|
                          DCD      gsUsbDevice+0x80

                          AREA ||i.DrvUSB_EnableUsb||, CODE, READONLY, ALIGN=2

                  DrvUSB_EnableUsb PROC
;;;1118   /*---------------------------------------------------------------------------------------------------------*/
;;;1119   void DrvUSB_EnableUsb(S_DRVUSB_DEVICE *psDevice)
000000  217d              MOVS     r1,#0x7d
;;;1120   {
;;;1121       _DRVUSB_ENABLE_USB();   /* enable USB & PHY */
000002  0109              LSLS     r1,r1,#4
000004  4a01              LDR      r2,|L29.12|
000006  6111              STR      r1,[r2,#0x10]
;;;1122   }
000008  4770              BX       lr
;;;1123   
                          ENDP

00000a  0000              DCW      0x0000
                  |L29.12|
                          DCD      0x40060000

                          AREA ||i.DrvUSB_GetEpId||, CODE, READONLY, ALIGN=2

                  DrvUSB_GetEpId PROC
;;;386    /*---------------------------------------------------------------------------------------------------------*/
;;;387    int32_t DrvUSB_GetEpId(uint32_t u32EpNum)
000000  b510              PUSH     {r4,lr}
;;;388    {
000002  4602              MOV      r2,r0
;;;389        uint32_t i;
;;;390        S_DRVUSB_DEVICE *psDevice =&gsUsbDevice;
000004  4b08              LDR      r3,|L30.40|
;;;391        
;;;392        for ( i = 0; i < MAX_EP_ID; i++)
000006  2100              MOVS     r1,#0
000008  e009              B        |L30.30|
                  |L30.10|
;;;393        {
;;;394            if (psDevice->sEpCrl[i].u32EpNum == u32EpNum)
00000a  200c              MOVS     r0,#0xc
00000c  4348              MULS     r0,r1,r0
00000e  461c              MOV      r4,r3
000010  3428              ADDS     r4,r4,#0x28
000012  5820              LDR      r0,[r4,r0]
000014  4290              CMP      r0,r2
000016  d101              BNE      |L30.28|
;;;395                return i;
000018  4608              MOV      r0,r1
                  |L30.26|
;;;396        }
;;;397        
;;;398        return E_DRVUSB_INVALID_EP_NUM; 
;;;399    }
00001a  bd10              POP      {r4,pc}
                  |L30.28|
00001c  1c49              ADDS     r1,r1,#1              ;392
                  |L30.30|
00001e  2906              CMP      r1,#6                 ;392
000020  d3f3              BCC      |L30.10|
000022  4802              LDR      r0,|L30.44|
000024  e7f9              B        |L30.26|
;;;400    
                          ENDP

000026  0000              DCW      0x0000
                  |L30.40|
                          DCD      gsUsbDevice
                  |L30.44|
                          DCD      0xffff9902

                          AREA ||i.DrvUSB_GetEpIdentity||, CODE, READONLY, ALIGN=2

                  DrvUSB_GetEpIdentity PROC
;;;352    /*---------------------------------------------------------------------------------------------------------*/
;;;353    int32_t DrvUSB_GetEpIdentity(uint32_t u32EpNum, uint32_t u32EpAttr)
000000  b530              PUSH     {r4,r5,lr}
;;;354    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;355        uint32_t i;
;;;356    
;;;357        S_DRVUSB_DEVICE *psDevice =&gsUsbDevice;
000006  4c09              LDR      r4,|L31.44|
;;;358        
;;;359        for ( i = 0; i < MAX_EP_ID; i++)
000008  2100              MOVS     r1,#0
00000a  e00b              B        |L31.36|
                  |L31.12|
;;;360        {
;;;361            if (psDevice->sEpCrl[i].u32EpNum == (u32EpNum | u32EpAttr))
00000c  200c              MOVS     r0,#0xc
00000e  4348              MULS     r0,r1,r0
000010  4625              MOV      r5,r4
000012  3528              ADDS     r5,r5,#0x28
000014  582d              LDR      r5,[r5,r0]
000016  4610              MOV      r0,r2
000018  4318              ORRS     r0,r0,r3
00001a  4285              CMP      r5,r0
00001c  d101              BNE      |L31.34|
;;;362                return i;
00001e  4608              MOV      r0,r1
                  |L31.32|
;;;363        }
;;;364        
;;;365        return E_DRVUSB_INVALID_EP_NUM;
;;;366    
;;;367    }
000020  bd30              POP      {r4,r5,pc}
                  |L31.34|
000022  1c49              ADDS     r1,r1,#1              ;359
                  |L31.36|
000024  2906              CMP      r1,#6                 ;359
000026  d3f1              BCC      |L31.12|
000028  4801              LDR      r0,|L31.48|
00002a  e7f9              B        |L31.32|
;;;368    
                          ENDP

                  |L31.44|
                          DCD      gsUsbDevice
                  |L31.48|
                          DCD      0xffff9902

                          AREA ||i.DrvUSB_GetFreeSRAM||, CODE, READONLY, ALIGN=2

                  DrvUSB_GetFreeSRAM PROC
;;;934    /*---------------------------------------------------------------------------------------------------------*/
;;;935    uint32_t DrvUSB_GetFreeSRAM(void)
000000  4801              LDR      r0,|L32.8|
;;;936    {
;;;937        return (uint32_t)g_UsbSramBase;
000002  6800              LDR      r0,[r0,#0]  ; g_UsbSramBase
;;;938    }
000004  4770              BX       lr
;;;939    
                          ENDP

000006  0000              DCW      0x0000
                  |L32.8|
                          DCD      g_UsbSramBase

                          AREA ||i.DrvUSB_GetMaxPower||, CODE, READONLY, ALIGN=2

                  DrvUSB_GetMaxPower PROC
;;;1099   /*---------------------------------------------------------------------------------------------------------*/
;;;1100   int32_t DrvUSB_GetMaxPower(void)
000000  4801              LDR      r0,|L33.8|
;;;1101   {   
;;;1102       return ((int32_t) gsUsbDevice.u8MaxPower);
000002  7800              LDRB     r0,[r0,#0]
;;;1103   }
000004  4770              BX       lr
;;;1104   
                          ENDP

000006  0000              DCW      0x0000
                  |L33.8|
                          DCD      gsUsbDevice+0xa0

                          AREA ||i.DrvUSB_GetOutData||, CODE, READONLY, ALIGN=2

                  DrvUSB_GetOutData PROC
;;;450    /*---------------------------------------------------------------------------------------------------------*/
;;;451    uint8_t * DrvUSB_GetOutData(uint32_t u32EpNum, uint32_t *u32Size)
000000  b570              PUSH     {r4-r6,lr}
;;;452    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;453        uint32_t u32EpId;
;;;454        
;;;455        u32EpId = DrvUSB_GetEpIdentity(u32EpNum, EP_OUTPUT);
000006  2100              MOVS     r1,#0
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       DrvUSB_GetEpIdentity
00000e  4605              MOV      r5,r0
;;;456        *u32Size = _DRVUSB_GET_EP_DATA_SIZE(u32EpId);
000010  0128              LSLS     r0,r5,#4
000012  4905              LDR      r1,|L34.40|
000014  1840              ADDS     r0,r0,r1
000016  7900              LDRB     r0,[r0,#4]
000018  6020              STR      r0,[r4,#0]
;;;457    
;;;458        return sEpDescription[u32EpId].u8SramBuffer;
00001a  200c              MOVS     r0,#0xc
00001c  4368              MULS     r0,r5,r0
00001e  4903              LDR      r1,|L34.44|
000020  1840              ADDS     r0,r0,r1
000022  6880              LDR      r0,[r0,#8]
;;;459    }
000024  bd70              POP      {r4-r6,pc}
;;;460    
                          ENDP

000026  0000              DCW      0x0000
                  |L34.40|
                          DCD      0x40060020
                  |L34.44|
                          DCD      sEpDescription

                          AREA ||i.DrvUSB_GetSetupBuffer||, CODE, READONLY, ALIGN=2

                  DrvUSB_GetSetupBuffer PROC
;;;913    /*---------------------------------------------------------------------------------------------------------*/
;;;914    uint32_t DrvUSB_GetSetupBuffer(void)
000000  4801              LDR      r0,|L35.8|
;;;915    {
;;;916        return (uint32_t)gsUsbDevice.sEpCrl[MAX_EP_ID].u8SramBuffer;
000002  6f80              LDR      r0,[r0,#0x78]
;;;917    }
000004  4770              BX       lr
;;;918    
                          ENDP

000006  0000              DCW      0x0000
                  |L35.8|
                          DCD      gsUsbDevice

                          AREA ||i.DrvUSB_GetUsbState||, CODE, READONLY, ALIGN=2

                  DrvUSB_GetUsbState PROC
;;;287    /*---------------------------------------------------------------------------------------------------------*/
;;;288    E_DRVUSB_STATE DrvUSB_GetUsbState(void)
000000  4801              LDR      r0,|L36.8|
;;;289    {
;;;290        return (E_DRVUSB_STATE)gsUsbDevice.eUsbState;
000002  6fc0              LDR      r0,[r0,#0x7c]  ; gsUsbDevice
000004  b2c0              UXTB     r0,r0
;;;291    }
000006  4770              BX       lr
;;;292    
                          ENDP

                  |L36.8|
                          DCD      gsUsbDevice

                          AREA ||i.DrvUSB_GetVersion||, CODE, READONLY, ALIGN=2

                  DrvUSB_GetVersion PROC
;;;41     /*---------------------------------------------------------------------------------------------------------*/
;;;42     uint32_t DrvUSB_GetVersion(void)
000000  4800              LDR      r0,|L37.4|
;;;43     {
;;;44         return DRVUSB_VERSION_NUM;
;;;45     }
000002  4770              BX       lr
;;;46     
                          ENDP

                  |L37.4|
                          DCD      0x00010202

                          AREA ||i.DrvUSB_Init||, CODE, READONLY, ALIGN=2

                  DrvUSB_Init PROC
;;;1467   /*---------------------------------------------------------------------------------------------------------*/
;;;1468   static int32_t DrvUSB_Init(void)
000000  481e              LDR      r0,|L38.124|
;;;1469   {
;;;1470       uint32_t temp;
;;;1471       volatile int32_t delay;
;;;1472    
;;;1473       /* Enable USB Clock */
;;;1474       SYSCLK->APBCLK.USBD_EN = 1;
000002  6880              LDR      r0,[r0,#8]
000004  2301              MOVS     r3,#1
000006  06db              LSLS     r3,r3,#27
000008  4398              BICS     r0,r0,r3
00000a  18c0              ADDS     r0,r0,r3
00000c  4b1b              LDR      r3,|L38.124|
00000e  6098              STR      r0,[r3,#8]
;;;1475   
;;;1476       /* Reset USB */
;;;1477       SYS->IPRSTC2.USBD_RST = 1;
000010  2005              MOVS     r0,#5
000012  0700              LSLS     r0,r0,#28
000014  68c0              LDR      r0,[r0,#0xc]
000016  049b              LSLS     r3,r3,#18
000018  4398              BICS     r0,r0,r3
00001a  18c0              ADDS     r0,r0,r3
00001c  2305              MOVS     r3,#5
00001e  071b              LSLS     r3,r3,#28
000020  60d8              STR      r0,[r3,#0xc]
;;;1478       delay = 500;
000022  22ff              MOVS     r2,#0xff
000024  32f5              ADDS     r2,r2,#0xf5
;;;1479       while(delay--);
000026  bf00              NOP      
                  |L38.40|
000028  4610              MOV      r0,r2
00002a  1e52              SUBS     r2,r2,#1
00002c  2800              CMP      r0,#0
00002e  d1fb              BNE      |L38.40|
;;;1480       SYS->IPRSTC2.USBD_RST = 0;
000030  2005              MOVS     r0,#5
000032  0700              LSLS     r0,r0,#28
000034  68c0              LDR      r0,[r0,#0xc]
000036  2301              MOVS     r3,#1
000038  06db              LSLS     r3,r3,#27
00003a  4398              BICS     r0,r0,r3
00003c  2305              MOVS     r3,#5
00003e  071b              LSLS     r3,r3,#28
000040  60d8              STR      r0,[r3,#0xc]
;;;1481   
;;;1482       _DRVUSB_ENABLE_USB();
000042  207d              MOVS     r0,#0x7d
000044  0100              LSLS     r0,r0,#4
000046  4b0e              LDR      r3,|L38.128|
000048  6118              STR      r0,[r3,#0x10]
;;;1483       _DRVUSB_ENABLE_SE0();   
00004a  480d              LDR      r0,|L38.128|
00004c  3080              ADDS     r0,r0,#0x80
00004e  6900              LDR      r0,[r0,#0x10]
000050  0840              LSRS     r0,r0,#1
000052  0040              LSLS     r0,r0,#1
000054  1c40              ADDS     r0,r0,#1
000056  4b0a              LDR      r3,|L38.128|
000058  3380              ADDS     r3,r3,#0x80
00005a  6118              STR      r0,[r3,#0x10]
;;;1484       temp = 0x100;
00005c  1599              ASRS     r1,r3,#22
;;;1485       while(temp--);   
00005e  bf00              NOP      
                  |L38.96|
000060  4608              MOV      r0,r1
000062  1e49              SUBS     r1,r1,#1
000064  2800              CMP      r0,#0
000066  d1fb              BNE      |L38.96|
;;;1486       _DRVUSB_DISABLE_SE0();
000068  4805              LDR      r0,|L38.128|
00006a  3080              ADDS     r0,r0,#0x80
00006c  6900              LDR      r0,[r0,#0x10]
00006e  0840              LSRS     r0,r0,#1
000070  0040              LSLS     r0,r0,#1
000072  4b03              LDR      r3,|L38.128|
000074  3380              ADDS     r3,r3,#0x80
000076  6118              STR      r0,[r3,#0x10]
;;;1487       
;;;1488       return 0;
000078  2000              MOVS     r0,#0
;;;1489   }
00007a  4770              BX       lr
;;;1490   
                          ENDP

                  |L38.124|
                          DCD      0x50000200
                  |L38.128|
                          DCD      0x40060000

                          AREA ||i.DrvUSB_InstallClassDevice||, CODE, READONLY, ALIGN=2

                  DrvUSB_InstallClassDevice PROC
;;;572    /*---------------------------------------------------------------------------------------------------------*/
;;;573    void * DrvUSB_InstallClassDevice(S_DRVUSB_CLASS *sUsbClass)
000000  4601              MOV      r1,r0
;;;574    {
;;;575        gsUsbDevice.psUsbClass = sUsbClass;
000002  4802              LDR      r0,|L39.12|
000004  6241              STR      r1,[r0,#0x24]
;;;576    
;;;577        return &gsUsbDevice;
000006  3880              SUBS     r0,r0,#0x80
;;;578    }
000008  4770              BX       lr
;;;579    
                          ENDP

00000a  0000              DCW      0x0000
                  |L39.12|
                          DCD      gsUsbDevice+0x80

                          AREA ||i.DrvUSB_InstallCtrlHandler||, CODE, READONLY, ALIGN=2

                  DrvUSB_InstallCtrlHandler PROC
;;;598    /*---------------------------------------------------------------------------------------------------------*/
;;;599    int32_t DrvUSB_InstallCtrlHandler(void * *device, 
000000  b570              PUSH     {r4-r6,lr}
;;;600                    S_DRVUSB_CTRL_CALLBACK_ENTRY *psCtrlCallbackEntry,uint32_t u32RegCnt)
;;;601    {
000002  4605              MOV      r5,r0
000004  460b              MOV      r3,r1
;;;602        S_DRVUSB_DEVICE *pDevice = (S_DRVUSB_DEVICE *)device;
000006  462e              MOV      r6,r5
;;;603        S_DRVUSB_CTRL_CALLBACK_ENTRY *psEntry;
;;;604        int i;
;;;605    
;;;606        if (u32RegCnt == 0)
000008  2a00              CMP      r2,#0
00000a  d101              BNE      |L40.16|
;;;607        {
;;;608            return 0;
00000c  2000              MOVS     r0,#0
                  |L40.14|
;;;609        }
;;;610    
;;;611        if (psCtrlCallbackEntry == 0)
;;;612        {
;;;613            return E_DRVUSB_NULL_POINTER;
;;;614        }
;;;615        
;;;616        pDevice->pCtrlCallback = psCtrlCallbackEntry;
;;;617        pDevice->CtrlCallbackSize = u32RegCnt;
;;;618        
;;;619        for (i = 0; i < u32RegCnt; i++)
;;;620        {
;;;621            psEntry = psCtrlCallbackEntry + i;
;;;622            
;;;623            if (psEntry->pfnCtrlDataInCallback == NULL)
;;;624                psEntry->pfnCtrlDataInCallback = DrvUSB_CtrlDataInDefault;
;;;625            if (psEntry->pfnCtrlDataOutCallback == NULL)
;;;626                psEntry->pfnCtrlDataOutCallback = DrvUSB_CtrlDataOutDefault;
;;;627        }
;;;628    
;;;629        return 0;
;;;630    }
00000e  bd70              POP      {r4-r6,pc}
                  |L40.16|
000010  2b00              CMP      r3,#0                 ;611
000012  d101              BNE      |L40.24|
000014  480c              LDR      r0,|L40.72|
000016  e7fa              B        |L40.14|
                  |L40.24|
000018  2084              MOVS     r0,#0x84              ;616
00001a  5183              STR      r3,[r0,r6]            ;616
00001c  2088              MOVS     r0,#0x88              ;617
00001e  5182              STR      r2,[r0,r6]            ;617
000020  2400              MOVS     r4,#0                 ;619
000022  e00d              B        |L40.64|
                  |L40.36|
000024  2014              MOVS     r0,#0x14              ;621
000026  4360              MULS     r0,r4,r0              ;621
000028  18c1              ADDS     r1,r0,r3              ;621
00002a  6888              LDR      r0,[r1,#8]            ;623
00002c  2800              CMP      r0,#0                 ;623
00002e  d101              BNE      |L40.52|
000030  4806              LDR      r0,|L40.76|
000032  6088              STR      r0,[r1,#8]            ;624
                  |L40.52|
000034  68c8              LDR      r0,[r1,#0xc]          ;625
000036  2800              CMP      r0,#0                 ;625
000038  d101              BNE      |L40.62|
00003a  4805              LDR      r0,|L40.80|
00003c  60c8              STR      r0,[r1,#0xc]          ;626
                  |L40.62|
00003e  1c64              ADDS     r4,r4,#1              ;619
                  |L40.64|
000040  4294              CMP      r4,r2                 ;619
000042  d3ef              BCC      |L40.36|
000044  2000              MOVS     r0,#0                 ;629
000046  e7e2              B        |L40.14|
;;;631    
                          ENDP

                  |L40.72|
                          DCD      0xffff9901
                  |L40.76|
                          DCD      DrvUSB_CtrlDataInDefault
                  |L40.80|
                          DCD      DrvUSB_CtrlDataOutDefault

                          AREA ||i.DrvUSB_IsData0||, CODE, READONLY, ALIGN=2

                  DrvUSB_IsData0 PROC
;;;257    /*---------------------------------------------------------------------------------------------------------*/
;;;258    int32_t DrvUSB_IsData0(uint32_t u32EpId)
000000  4601              MOV      r1,r0
;;;259    {
;;;260        int32_t bData0 = 0;
000002  2000              MOVS     r0,#0
;;;261    
;;;262        if (u32EpId >= MAX_EP_ID)
000004  2906              CMP      r1,#6
000006  d300              BCC      |L41.10|
;;;263        {
;;;264            bData0 = 0;
000008  e002              B        |L41.16|
                  |L41.10|
;;;265        }
;;;266        else
;;;267        {
;;;268            bData0 = gsUsbDevice.abData0[u32EpId];
00000a  008b              LSLS     r3,r1,#2
00000c  4a01              LDR      r2,|L41.20|
00000e  58d0              LDR      r0,[r2,r3]
                  |L41.16|
;;;269        }
;;;270    
;;;271        return bData0;
;;;272    }
000010  4770              BX       lr
;;;273    
                          ENDP

000012  0000              DCW      0x0000
                  |L41.20|
                          DCD      gsUsbDevice+0x10

                          AREA ||i.DrvUSB_IsRemoteWakeupEnabled||, CODE, READONLY, ALIGN=2

                  DrvUSB_IsRemoteWakeupEnabled PROC
;;;1050   /*---------------------------------------------------------------------------------------------------------*/
;;;1051   int32_t DrvUSB_IsRemoteWakeupEnabled(void)
000000  4801              LDR      r0,|L42.8|
;;;1052   {
;;;1053       return gsUsbDevice.bRemoteWakeup;
000002  69c0              LDR      r0,[r0,#0x1c]
;;;1054   }
000004  4770              BX       lr
;;;1055   
                          ENDP

000006  0000              DCW      0x0000
                  |L42.8|
                          DCD      gsUsbDevice+0x80

                          AREA ||i.DrvUSB_IsSelfPowerEnabled||, CODE, READONLY, ALIGN=2

                  DrvUSB_IsSelfPowerEnabled PROC
;;;992    /*---------------------------------------------------------------------------------------------------------*/
;;;993    int32_t DrvUSB_IsSelfPowerEnabled(void)
000000  4801              LDR      r0,|L43.8|
;;;994    {
;;;995        return gsUsbDevice.bSelfPowered;
000002  6980              LDR      r0,[r0,#0x18]
;;;996    }
000004  4770              BX       lr
;;;997    
                          ENDP

000006  0000              DCW      0x0000
                  |L43.8|
                          DCD      gsUsbDevice+0x80

                          AREA ||i.DrvUSB_Open||, CODE, READONLY, ALIGN=2

                  DrvUSB_Open PROC
;;;83     /*---------------------------------------------------------------------------------------------------------*/
;;;84     int32_t DrvUSB_Open(void * pVoid)
000000  b5f8              PUSH     {r3-r7,lr}
;;;85     {
000002  4607              MOV      r7,r0
;;;86         uint32_t i, j;
;;;87         uint8_t *p;
;;;88         
;;;89         DrvUSB_Init();
000004  f7fffffe          BL       DrvUSB_Init
;;;90         
;;;91         if (pVoid != NULL)
000008  2f00              CMP      r7,#0
00000a  d001              BEQ      |L44.16|
;;;92             g_FnIntCallBack = (PFN_DRVUSB_INTCALLBACK)pVoid;
00000c  485e              LDR      r0,|L44.392|
00000e  6007              STR      r7,[r0,#0]  ; g_FnIntCallBack
                  |L44.16|
;;;93         
;;;94         gsUsbDevice.u16MiscEventFlags = 0;
000010  2100              MOVS     r1,#0
000012  485e              LDR      r0,|L44.396|
000014  8001              STRH     r1,[r0,#0]
;;;95         gsUsbDevice.u16EPEventFlags = 0;
000016  8041              STRH     r1,[r0,#2]
;;;96         
;;;97         p = (uint8_t *)USB_SRAM_BASE;
000018  4e5d              LDR      r6,|L44.400|
;;;98         
;;;99         /* for setup packet */
;;;100        gsUsbDevice.sEpCrl[MAX_EP_ID].u32EpNum = 0x0;
00001a  3880              SUBS     r0,r0,#0x80
00001c  6701              STR      r1,[r0,#0x70]
;;;101        gsUsbDevice.sEpCrl[MAX_EP_ID].u32MaxPacketSize = 8;
00001e  2108              MOVS     r1,#8
000020  6741              STR      r1,[r0,#0x74]
;;;102        gsUsbDevice.sEpCrl[MAX_EP_ID].u8SramBuffer = p;
000022  6786              STR      r6,[r0,#0x78]
;;;103        p += 8;
000024  3608              ADDS     r6,r6,#8
;;;104        
;;;105        i = 0;
000026  2400              MOVS     r4,#0
;;;106        while (sEpDescription[i].u32MaxPacketSize != 0)
000028  e087              B        |L44.314|
                  |L44.42|
;;;107        {       
;;;108            /* There may be some EPs which have the same EP address. We will find them out here in order to use same buffer. */
;;;109            for (j = 0; j < i; j++)
00002a  2500              MOVS     r5,#0
00002c  e010              B        |L44.80|
                  |L44.46|
;;;110            {
;;;111                if ((sEpDescription[i].u32EpNum & 0xF) == (gsUsbDevice.sEpCrl[j].u32EpNum & 0xF))
00002e  200c              MOVS     r0,#0xc
000030  4360              MULS     r0,r4,r0
000032  4958              LDR      r1,|L44.404|
000034  5808              LDR      r0,[r1,r0]
000036  0702              LSLS     r2,r0,#28
000038  0f12              LSRS     r2,r2,#28
00003a  200c              MOVS     r0,#0xc
00003c  4368              MULS     r0,r5,r0
00003e  4953              LDR      r1,|L44.396|
000040  3958              SUBS     r1,r1,#0x58
000042  5808              LDR      r0,[r1,r0]
000044  0700              LSLS     r0,r0,#28
000046  0f00              LSRS     r0,r0,#28
000048  4282              CMP      r2,r0
00004a  d100              BNE      |L44.78|
;;;112                    break;
00004c  e002              B        |L44.84|
                  |L44.78|
00004e  1c6d              ADDS     r5,r5,#1              ;109
                  |L44.80|
000050  42a5              CMP      r5,r4                 ;109
000052  d3ec              BCC      |L44.46|
                  |L44.84|
000054  bf00              NOP      
;;;113            }
;;;114            
;;;115            gsUsbDevice.sEpCrl[i].u32EpNum = sEpDescription[i].u32EpNum;
000056  200c              MOVS     r0,#0xc
000058  4360              MULS     r0,r4,r0
00005a  494e              LDR      r1,|L44.404|
00005c  580a              LDR      r2,[r1,r0]
00005e  200c              MOVS     r0,#0xc
000060  4360              MULS     r0,r4,r0
000062  494a              LDR      r1,|L44.396|
000064  3958              SUBS     r1,r1,#0x58
000066  500a              STR      r2,[r1,r0]
;;;116            gsUsbDevice.sEpCrl[i].u32MaxPacketSize = sEpDescription[i].u32MaxPacketSize;
000068  200c              MOVS     r0,#0xc
00006a  4360              MULS     r0,r4,r0
00006c  4949              LDR      r1,|L44.404|
00006e  1840              ADDS     r0,r0,r1
000070  6842              LDR      r2,[r0,#4]
000072  200c              MOVS     r0,#0xc
000074  4360              MULS     r0,r4,r0
000076  4945              LDR      r1,|L44.396|
000078  3958              SUBS     r1,r1,#0x58
00007a  1840              ADDS     r0,r0,r1
00007c  6042              STR      r2,[r0,#4]
;;;117            
;;;118            /* Assign the transfer buffer */
;;;119            if (sEpDescription[i].u8SramBuffer == NULL)
00007e  200c              MOVS     r0,#0xc
000080  4360              MULS     r0,r4,r0
000082  4944              LDR      r1,|L44.404|
000084  1840              ADDS     r0,r0,r1
000086  6880              LDR      r0,[r0,#8]
000088  2800              CMP      r0,#0
00008a  d123              BNE      |L44.212|
;;;120            {               
;;;121                if (j < i)
00008c  42a5              CMP      r5,r4
00008e  d20a              BCS      |L44.166|
;;;122                {
;;;123                    /* Use the same buffer if they have the same EP address */
;;;124                    gsUsbDevice.sEpCrl[i].u8SramBuffer = gsUsbDevice.sEpCrl[j].u8SramBuffer;
000090  200c              MOVS     r0,#0xc
000092  4368              MULS     r0,r5,r0
000094  493d              LDR      r1,|L44.396|
000096  3958              SUBS     r1,r1,#0x58
000098  1840              ADDS     r0,r0,r1
00009a  6882              LDR      r2,[r0,#8]
00009c  200c              MOVS     r0,#0xc
00009e  4360              MULS     r0,r4,r0
0000a0  1840              ADDS     r0,r0,r1
0000a2  6082              STR      r2,[r0,#8]
0000a4  e00b              B        |L44.190|
                  |L44.166|
;;;125                }
;;;126                else
;;;127                {
;;;128                    /* Assign a new buffer */
;;;129                    gsUsbDevice.sEpCrl[i].u8SramBuffer = p;
0000a6  200c              MOVS     r0,#0xc
0000a8  4360              MULS     r0,r4,r0
0000aa  4938              LDR      r1,|L44.396|
0000ac  3958              SUBS     r1,r1,#0x58
0000ae  1840              ADDS     r0,r0,r1
0000b0  6086              STR      r6,[r0,#8]
;;;130                    p += sEpDescription[i].u32MaxPacketSize;
0000b2  200c              MOVS     r0,#0xc
0000b4  4360              MULS     r0,r4,r0
0000b6  4937              LDR      r1,|L44.404|
0000b8  1840              ADDS     r0,r0,r1
0000ba  6840              LDR      r0,[r0,#4]
0000bc  1986              ADDS     r6,r0,r6
                  |L44.190|
;;;131                }
;;;132                
;;;133                /* Write back the assigned buffer */
;;;134                sEpDescription[i].u8SramBuffer = gsUsbDevice.sEpCrl[i].u8SramBuffer;
0000be  200c              MOVS     r0,#0xc
0000c0  4360              MULS     r0,r4,r0
0000c2  4932              LDR      r1,|L44.396|
0000c4  3958              SUBS     r1,r1,#0x58
0000c6  1840              ADDS     r0,r0,r1
0000c8  6881              LDR      r1,[r0,#8]
0000ca  200c              MOVS     r0,#0xc
0000cc  4360              MULS     r0,r4,r0
0000ce  4a31              LDR      r2,|L44.404|
0000d0  1880              ADDS     r0,r0,r2
0000d2  6081              STR      r1,[r0,#8]
                  |L44.212|
;;;135            }
;;;136    
;;;137            if ((sEpDescription[i].u32EpNum & 0x1f) == 0)
0000d4  200c              MOVS     r0,#0xc
0000d6  4360              MULS     r0,r4,r0
0000d8  492e              LDR      r1,|L44.404|
0000da  5808              LDR      r0,[r1,r0]
0000dc  06c0              LSLS     r0,r0,#27
0000de  0ec0              LSRS     r0,r0,#27
0000e0  d116              BNE      |L44.272|
;;;138            {
;;;139                /* Only ctrl EP needs to support STALL auto clear */
;;;140                CFG_EP_SETTING[i] = (CFG_CSTALL | 
0000e2  200c              MOVS     r0,#0xc
0000e4  4360              MULS     r0,r4,r0
0000e6  5808              LDR      r0,[r1,r0]
0000e8  2180              MOVS     r1,#0x80
0000ea  4208              TST      r0,r1
0000ec  d001              BEQ      |L44.242|
;;;141                  ((sEpDescription[i].u32EpNum&EP_INPUT)?CFG_EPT_IN:CFG_EPT_OUT) 
0000ee  2040              MOVS     r0,#0x40
0000f0  e000              B        |L44.244|
                  |L44.242|
0000f2  2020              MOVS     r0,#0x20
                  |L44.244|
0000f4  2101              MOVS     r1,#1
0000f6  0249              LSLS     r1,r1,#9
0000f8  4308              ORRS     r0,r0,r1
0000fa  210c              MOVS     r1,#0xc
0000fc  4361              MULS     r1,r4,r1
0000fe  4a25              LDR      r2,|L44.404|
000100  5851              LDR      r1,[r2,r1]
000102  0709              LSLS     r1,r1,#28
000104  0f09              LSRS     r1,r1,#28
000106  4308              ORRS     r0,r0,r1
000108  00a1              LSLS     r1,r4,#2
00010a  4a23              LDR      r2,|L44.408|
00010c  5050              STR      r0,[r2,r1]
00010e  e013              B        |L44.312|
                  |L44.272|
;;;142                  | (sEpDescription[i].u32EpNum&0x0F));
;;;143            }
;;;144            else
;;;145            {
;;;146                CFG_EP_SETTING[i] = ((sEpDescription[i].u32EpNum&EP_INPUT)?CFG_EPT_IN:CFG_EPT_OUT) 
000110  200c              MOVS     r0,#0xc
000112  4360              MULS     r0,r4,r0
000114  491f              LDR      r1,|L44.404|
000116  5808              LDR      r0,[r1,r0]
000118  2180              MOVS     r1,#0x80
00011a  4208              TST      r0,r1
00011c  d001              BEQ      |L44.290|
00011e  2040              MOVS     r0,#0x40
000120  e000              B        |L44.292|
                  |L44.290|
000122  2020              MOVS     r0,#0x20
                  |L44.292|
000124  210c              MOVS     r1,#0xc
000126  4361              MULS     r1,r4,r1
000128  4a1a              LDR      r2,|L44.404|
00012a  5851              LDR      r1,[r2,r1]
00012c  0709              LSLS     r1,r1,#28
00012e  0f09              LSRS     r1,r1,#28
000130  4308              ORRS     r0,r0,r1
000132  00a1              LSLS     r1,r4,#2
000134  4a18              LDR      r2,|L44.408|
000136  5050              STR      r0,[r2,r1]
                  |L44.312|
;;;147                  | (sEpDescription[i].u32EpNum&0x0F);
;;;148            }
;;;149            
;;;150            i++;
000138  1c64              ADDS     r4,r4,#1
                  |L44.314|
00013a  200c              MOVS     r0,#0xc               ;106
00013c  4360              MULS     r0,r4,r0              ;106
00013e  4915              LDR      r1,|L44.404|
000140  1840              ADDS     r0,r0,r1              ;106
000142  6840              LDR      r0,[r0,#4]            ;106
000144  2800              CMP      r0,#0                 ;106
000146  d000              BEQ      |L44.330|
000148  e76f              B        |L44.42|
                  |L44.330|
;;;151        }
;;;152        
;;;153        /* Update the remind buffer base */
;;;154        g_UsbSramBase = p;
00014a  4814              LDR      r0,|L44.412|
00014c  6006              STR      r6,[r0,#0]  ; g_UsbSramBase
;;;155    
;;;156        gsUsbDevice.eUsbState = eDRVUSB_DETACHED;
00014e  2000              MOVS     r0,#0
000150  490e              LDR      r1,|L44.396|
000152  3980              SUBS     r1,r1,#0x80
000154  67c8              STR      r0,[r1,#0x7c]  ; gsUsbDevice
;;;157        gsUsbDevice.u32FLDET = USBD->FLDET.FLDET;
000156  4812              LDR      r0,|L44.416|
000158  6940              LDR      r0,[r0,#0x14]
00015a  07c0              LSLS     r0,r0,#31
00015c  0fc0              LSRS     r0,r0,#31
00015e  6088              STR      r0,[r1,#8]  ; gsUsbDevice
;;;158        DrvUSB_PreDispatchFDTEvent(&gsUsbDevice);
000160  4608              MOV      r0,r1
000162  f7fffffe          BL       DrvUSB_PreDispatchFDTEvent
;;;159        DrvUSB_DispatchMiscEvent(&gsUsbDevice);
000166  4809              LDR      r0,|L44.396|
000168  3880              SUBS     r0,r0,#0x80
00016a  f7fffffe          BL       DrvUSB_DispatchMiscEvent
;;;160        
;;;161        NVIC_SetPriority (USBD_IRQn, (1<<__NVIC_PRIO_BITS) - 2);
00016e  2102              MOVS     r1,#2
000170  2017              MOVS     r0,#0x17
000172  f7fffffe          BL       NVIC_SetPriority
;;;162        NVIC_EnableIRQ(USBD_IRQn);
000176  bf00              NOP      
000178  2017              MOVS     r0,#0x17
00017a  2101              MOVS     r1,#1
00017c  4081              LSLS     r1,r1,r0
00017e  4809              LDR      r0,|L44.420|
000180  6001              STR      r1,[r0,#0]
000182  bf00              NOP      
;;;163    
;;;164        return 0;
000184  2000              MOVS     r0,#0
;;;165    }
000186  bdf8              POP      {r3-r7,pc}
;;;166    
                          ENDP

                  |L44.392|
                          DCD      g_FnIntCallBack
                  |L44.396|
                          DCD      gsUsbDevice+0x80
                  |L44.400|
                          DCD      0x40060100
                  |L44.404|
                          DCD      sEpDescription
                  |L44.408|
                          DCD      CFG_EP_SETTING
                  |L44.412|
                          DCD      g_UsbSramBase
                  |L44.416|
                          DCD      0x40060000
                  |L44.420|
                          DCD      0xe000e100

                          AREA ||i.DrvUSB_PreDispatchBusEvent||, CODE, READONLY, ALIGN=2

                  DrvUSB_PreDispatchBusEvent PROC
;;;1218   /*---------------------------------------------------------------------------------------------------------*/
;;;1219   void DrvUSB_PreDispatchBusEvent(S_DRVUSB_DEVICE *psDevice)
000000  6801              LDR      r1,[r0,#0]
;;;1220   {
;;;1221       uint32_t u32Attr = psDevice->u32ATTR;
;;;1222   
;;;1223       if (psDevice->eUsbState == eDRVUSB_DETACHED)
000002  6fc2              LDR      r2,[r0,#0x7c]
000004  2a00              CMP      r2,#0
000006  d100              BNE      |L45.10|
                  |L45.8|
;;;1224       {
;;;1225           /* There should be something wrong */
;;;1226           return;
;;;1227       }
;;;1228   
;;;1229       if (u32Attr & ATTR_USBRST)
;;;1230       {
;;;1231           /* Bus reset */
;;;1232           _DRVUSB_ENABLE_USB(); /* enable USB & PHY */
;;;1233           psDevice->eUsbState = eDRVUSB_DEFAULT;
;;;1234           psDevice->u16MiscEventFlags |= DRVUSB_EVENT_FLAG_BUS_RESET;
;;;1235       }
;;;1236       else if (u32Attr & ATTR_SUSPEND)
;;;1237       {
;;;1238           /* Bus suspend */
;;;1239           _DRVUSB_DISABLE_PHY(); /* disable PHY */
;;;1240           if (psDevice->eUsbState >= eDRVUSB_ATTACHED)
;;;1241           {
;;;1242               psDevice->eUsbState |= eDRVUSB_SUSPENDED;
;;;1243           }
;;;1244           psDevice->u16MiscEventFlags |= DRVUSB_EVENT_FLAG_BUS_SUSPEND;
;;;1245   
;;;1246       }
;;;1247       else if (u32Attr & ATTR_RESUME)
;;;1248       {
;;;1249           /* Bus resume */
;;;1250           _DRVUSB_ENABLE_USB(); /* enable PHY */
;;;1251           if (psDevice->eUsbState >= eDRVUSB_ATTACHED)
;;;1252           {
;;;1253               psDevice->eUsbState &= ~eDRVUSB_SUSPENDED;
;;;1254           }
;;;1255           psDevice->u16MiscEventFlags |= DRVUSB_EVENT_FLAG_BUS_RESUME;
;;;1256       }
;;;1257   }
000008  4770              BX       lr
                  |L45.10|
00000a  07ca              LSLS     r2,r1,#31             ;1229
00000c  0fd2              LSRS     r2,r2,#31             ;1229
00000e  d00c              BEQ      |L45.42|
000010  227d              MOVS     r2,#0x7d              ;1232
000012  0112              LSLS     r2,r2,#4              ;1232
000014  4b1a              LDR      r3,|L45.128|
000016  611a              STR      r2,[r3,#0x10]         ;1232
000018  2207              MOVS     r2,#7                 ;1233
00001a  67c2              STR      r2,[r0,#0x7c]         ;1233
00001c  2280              MOVS     r2,#0x80              ;1234
00001e  5a12              LDRH     r2,[r2,r0]            ;1234
000020  2304              MOVS     r3,#4                 ;1234
000022  431a              ORRS     r2,r2,r3              ;1234
000024  2380              MOVS     r3,#0x80              ;1234
000026  521a              STRH     r2,[r3,r0]            ;1234
000028  e028              B        |L45.124|
                  |L45.42|
00002a  2202              MOVS     r2,#2                 ;1236
00002c  4211              TST      r1,r2                 ;1236
00002e  d011              BEQ      |L45.84|
000030  221f              MOVS     r2,#0x1f              ;1239
000032  0192              LSLS     r2,r2,#6              ;1239
000034  4b12              LDR      r3,|L45.128|
000036  611a              STR      r2,[r3,#0x10]         ;1239
000038  6fc2              LDR      r2,[r0,#0x7c]         ;1240
00003a  2a01              CMP      r2,#1                 ;1240
00003c  db03              BLT      |L45.70|
00003e  2320              MOVS     r3,#0x20              ;1242
000040  6fc2              LDR      r2,[r0,#0x7c]         ;1242
000042  431a              ORRS     r2,r2,r3              ;1242
000044  67c2              STR      r2,[r0,#0x7c]         ;1242
                  |L45.70|
000046  2280              MOVS     r2,#0x80              ;1244
000048  5a12              LDRH     r2,[r2,r0]            ;1244
00004a  2308              MOVS     r3,#8                 ;1244
00004c  431a              ORRS     r2,r2,r3              ;1244
00004e  2380              MOVS     r3,#0x80              ;1244
000050  521a              STRH     r2,[r3,r0]            ;1244
000052  e013              B        |L45.124|
                  |L45.84|
000054  2204              MOVS     r2,#4                 ;1247
000056  4211              TST      r1,r2                 ;1247
000058  d010              BEQ      |L45.124|
00005a  227d              MOVS     r2,#0x7d              ;1250
00005c  0112              LSLS     r2,r2,#4              ;1250
00005e  4b08              LDR      r3,|L45.128|
000060  611a              STR      r2,[r3,#0x10]         ;1250
000062  6fc2              LDR      r2,[r0,#0x7c]         ;1251
000064  2a01              CMP      r2,#1                 ;1251
000066  db03              BLT      |L45.112|
000068  2320              MOVS     r3,#0x20              ;1253
00006a  6fc2              LDR      r2,[r0,#0x7c]         ;1253
00006c  439a              BICS     r2,r2,r3              ;1253
00006e  67c2              STR      r2,[r0,#0x7c]         ;1253
                  |L45.112|
000070  2280              MOVS     r2,#0x80              ;1255
000072  5a12              LDRH     r2,[r2,r0]            ;1255
000074  2310              MOVS     r3,#0x10              ;1255
000076  431a              ORRS     r2,r2,r3              ;1255
000078  2380              MOVS     r3,#0x80              ;1255
00007a  521a              STRH     r2,[r3,r0]            ;1255
                  |L45.124|
00007c  bf00              NOP      
00007e  e7c3              B        |L45.8|
;;;1258   
                          ENDP

                  |L45.128|
                          DCD      0x40060000

                          AREA ||i.DrvUSB_PreDispatchEPEvent||, CODE, READONLY, ALIGN=2

                  DrvUSB_PreDispatchEPEvent PROC
;;;1274   /*---------------------------------------------------------------------------------------------------------*/
;;;1275   void DrvUSB_PreDispatchEPEvent(S_DRVUSB_DEVICE *psDevice)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1276   {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
;;;1277       uint32_t u32EpNum;
;;;1278       uint32_t u32EpId;
;;;1279       uint32_t u32INTSTS = psDevice->u32INTSTS;
000006  68e0              LDR      r0,[r4,#0xc]
000008  9003              STR      r0,[sp,#0xc]
;;;1280       uint32_t u32EPSTS = psDevice->u32EPSTS;
00000a  6860              LDR      r0,[r4,#4]
00000c  9002              STR      r0,[sp,#8]
;;;1281       uint32_t u32PacketType;
;;;1282       uint32_t u32ISOPacketType;
;;;1283       int32_t i;
;;;1284           
;;;1285       if (psDevice->eUsbState == eDRVUSB_DETACHED)
00000e  6fe0              LDR      r0,[r4,#0x7c]
000010  2800              CMP      r0,#0
000012  d101              BNE      |L46.24|
                  |L46.20|
;;;1286       {
;;;1287           /* There should be something wrong. */
;;;1288           return;
;;;1289       }
;;;1290   
;;;1291       /* Only care EP events and Setup event */
;;;1292       u32INTSTS &= (INTSTS_EPTF0 | INTSTS_EPTF1 | INTSTS_EPTF2 | INTSTS_EPTF3 | INTSTS_EPTF4 | INTSTS_EPTF5 | INTSTS_SETUP);
;;;1293   
;;;1294       if (u32INTSTS & INTSTS_SETUP)
;;;1295       {
;;;1296           /* Record the event to procee it later */
;;;1297           psDevice->u16MiscEventFlags |= DRVUSB_EVENT_FLAG_SETUP;
;;;1298           
;;;1299           /* Clear setup event flag */
;;;1300           _DRVUSB_SET_EVENT_FLAG(INTSTS_SETUP);
;;;1301           
;;;1302           /* Assign the toggle bit for data phase */
;;;1303           psDevice->abData0[0] = 1;
;;;1304       }
;;;1305       
;;;1306       u32INTSTS = inp32(&USBD->INTSTS); 
;;;1307       outp32(&USBD->INTSTS, (u32INTSTS & 0x00FF0000UL));
;;;1308   
;;;1309       for (i=16;i<16+MAX_EP_ID;i++)
;;;1310       {
;;;1311           if (u32INTSTS & (1 << i))
;;;1312           {
;;;1313               u32EpId = i - 16;
;;;1314   
;;;1315               /* Get the address of EP */
;;;1316               u32EpNum = (_DRVUSB_GET_CFG(u32EpId) & CFG_EPT);    
;;;1317               
;;;1318               u32PacketType = ((u32EPSTS >> (4 + u32EpId * 3)) & EPSTS_STS);
;;;1319               
;;;1320               if (u32PacketType == EPSTS_IN_ACK)
;;;1321               {
;;;1322                   /* Set this EP event as non-handled. */
;;;1323                   psDevice->u16EPEventFlags |= (1 << (u32EpNum*2));
;;;1324               }
;;;1325               else if(u32PacketType == EPSTS_OUT0_ACK)
;;;1326               {
;;;1327                   /* Set this EP event as non-handled. */
;;;1328                   psDevice->u16EPEventFlags |= (1 << (u32EpNum*2 + 1));
;;;1329                   
;;;1330                   /* Assign the toggle bit of data packet */
;;;1331                   psDevice->abData0[u32EpId] = 1;
;;;1332               }
;;;1333               else if(u32PacketType == EPSTS_OUT1_ACK)
;;;1334               {
;;;1335                   /* Set this EP event as non-handled. */
;;;1336                   psDevice->u16EPEventFlags |= (1 << (u32EpNum*2 + 1));
;;;1337                   
;;;1338                   /* Assign the toggle bit of data packet */
;;;1339                   psDevice->abData0[u32EpId] = 0;
;;;1340               }
;;;1341               else if(u32PacketType == EPSTS_ISO)
;;;1342               {
;;;1343                   u32ISOPacketType = (_DRVUSB_GET_CFG(u32EpId) & CFG_STATE);
;;;1344                   
;;;1345                   psDevice->abData0[u32EpId] = 0;
;;;1346                   
;;;1347                   if (u32ISOPacketType == 0x20)
;;;1348                   {
;;;1349                       /* This is isochronous out translation end. Call relative handler */
;;;1350                       if(g_sUsbOps[u32EpNum*2 + 1].apfnCallback != 0)
;;;1351                       {
;;;1352                           g_sUsbOps[u32EpNum*2 + 1].apfnCallback(g_sUsbOps[u32EpNum*2 + 1].apCallbackArgu);
;;;1353                       }
;;;1354                   }
;;;1355                   else if(u32ISOPacketType == 0x40)
;;;1356                   {
;;;1357                       /* This is isochronous in translation end. Call relative handler */
;;;1358                       if (g_sUsbOps[u32EpNum*2].apfnCallback != 0)
;;;1359                       {
;;;1360                           g_sUsbOps[u32EpNum*2].apfnCallback(g_sUsbOps[u32EpNum*2].apCallbackArgu);
;;;1361                       }
;;;1362                   }
;;;1363               }       
;;;1364           }
;;;1365       }
;;;1366   }
000014  b005              ADD      sp,sp,#0x14
000016  bdf0              POP      {r4-r7,pc}
                  |L46.24|
000018  4950              LDR      r1,|L46.348|
00001a  9803              LDR      r0,[sp,#0xc]          ;1292
00001c  4008              ANDS     r0,r0,r1              ;1292
00001e  9003              STR      r0,[sp,#0xc]          ;1292
000020  9803              LDR      r0,[sp,#0xc]          ;1294
000022  0fc0              LSRS     r0,r0,#31             ;1294
000024  07c0              LSLS     r0,r0,#31             ;1294
000026  d00a              BEQ      |L46.62|
000028  2080              MOVS     r0,#0x80              ;1297
00002a  5b00              LDRH     r0,[r0,r4]            ;1297
00002c  2120              MOVS     r1,#0x20              ;1297
00002e  4308              ORRS     r0,r0,r1              ;1297
000030  2180              MOVS     r1,#0x80              ;1297
000032  5308              STRH     r0,[r1,r4]            ;1297
000034  0608              LSLS     r0,r1,#24             ;1300
000036  494a              LDR      r1,|L46.352|
000038  6048              STR      r0,[r1,#4]            ;1300
00003a  2001              MOVS     r0,#1                 ;1303
00003c  6120              STR      r0,[r4,#0x10]         ;1303
                  |L46.62|
00003e  4848              LDR      r0,|L46.352|
000040  6840              LDR      r0,[r0,#4]            ;1306
000042  9003              STR      r0,[sp,#0xc]          ;1306
000044  21ff              MOVS     r1,#0xff              ;1307
000046  0409              LSLS     r1,r1,#16             ;1307
000048  9803              LDR      r0,[sp,#0xc]          ;1307
00004a  4008              ANDS     r0,r0,r1              ;1307
00004c  4944              LDR      r1,|L46.352|
00004e  6048              STR      r0,[r1,#4]            ;1307
000050  2010              MOVS     r0,#0x10              ;1309
000052  9000              STR      r0,[sp,#0]            ;1309
000054  e07c              B        |L46.336|
                  |L46.86|
000056  2001              MOVS     r0,#1                 ;1311
000058  9900              LDR      r1,[sp,#0]            ;1311
00005a  4088              LSLS     r0,r0,r1              ;1311
00005c  9903              LDR      r1,[sp,#0xc]          ;1311
00005e  4208              TST      r0,r1                 ;1311
000060  d073              BEQ      |L46.330|
000062  9800              LDR      r0,[sp,#0]            ;1313
000064  4606              MOV      r6,r0                 ;1313
000066  3e10              SUBS     r6,r6,#0x10           ;1313
000068  0130              LSLS     r0,r6,#4              ;1316
00006a  493d              LDR      r1,|L46.352|
00006c  1840              ADDS     r0,r0,r1              ;1316
00006e  6a80              LDR      r0,[r0,#0x28]         ;1316
000070  0705              LSLS     r5,r0,#28             ;1316
000072  0f2d              LSRS     r5,r5,#28             ;1316
000074  0070              LSLS     r0,r6,#1              ;1318
000076  1831              ADDS     r1,r6,r0              ;1318
000078  1d09              ADDS     r1,r1,#4              ;1318
00007a  9802              LDR      r0,[sp,#8]            ;1318
00007c  40c8              LSRS     r0,r0,r1              ;1318
00007e  2170              MOVS     r1,#0x70              ;1318
000080  4607              MOV      r7,r0                 ;1318
000082  400f              ANDS     r7,r7,r1              ;1318
000084  2f00              CMP      r7,#0                 ;1320
000086  d109              BNE      |L46.156|
000088  2082              MOVS     r0,#0x82              ;1323
00008a  5b00              LDRH     r0,[r0,r4]            ;1323
00008c  006a              LSLS     r2,r5,#1              ;1323
00008e  2101              MOVS     r1,#1                 ;1323
000090  4091              LSLS     r1,r1,r2              ;1323
000092  4308              ORRS     r0,r0,r1              ;1323
000094  b281              UXTH     r1,r0                 ;1323
000096  2082              MOVS     r0,#0x82              ;1323
000098  5301              STRH     r1,[r0,r4]            ;1323
00009a  e056              B        |L46.330|
                  |L46.156|
00009c  2f20              CMP      r7,#0x20              ;1325
00009e  d10f              BNE      |L46.192|
0000a0  2082              MOVS     r0,#0x82              ;1328
0000a2  5b00              LDRH     r0,[r0,r4]            ;1328
0000a4  0069              LSLS     r1,r5,#1              ;1328
0000a6  1c49              ADDS     r1,r1,#1              ;1328
0000a8  2201              MOVS     r2,#1                 ;1328
0000aa  408a              LSLS     r2,r2,r1              ;1328
0000ac  4310              ORRS     r0,r0,r2              ;1328
0000ae  b281              UXTH     r1,r0                 ;1328
0000b0  2082              MOVS     r0,#0x82              ;1328
0000b2  5301              STRH     r1,[r0,r4]            ;1328
0000b4  2101              MOVS     r1,#1                 ;1331
0000b6  00b2              LSLS     r2,r6,#2              ;1331
0000b8  4620              MOV      r0,r4                 ;1331
0000ba  3010              ADDS     r0,r0,#0x10           ;1331
0000bc  5081              STR      r1,[r0,r2]            ;1331
0000be  e044              B        |L46.330|
                  |L46.192|
0000c0  2f60              CMP      r7,#0x60              ;1333
0000c2  d10f              BNE      |L46.228|
0000c4  2082              MOVS     r0,#0x82              ;1336
0000c6  5b00              LDRH     r0,[r0,r4]            ;1336
0000c8  0069              LSLS     r1,r5,#1              ;1336
0000ca  1c49              ADDS     r1,r1,#1              ;1336
0000cc  2201              MOVS     r2,#1                 ;1336
0000ce  408a              LSLS     r2,r2,r1              ;1336
0000d0  4310              ORRS     r0,r0,r2              ;1336
0000d2  b281              UXTH     r1,r0                 ;1336
0000d4  2082              MOVS     r0,#0x82              ;1336
0000d6  5301              STRH     r1,[r0,r4]            ;1336
0000d8  2100              MOVS     r1,#0                 ;1339
0000da  00b2              LSLS     r2,r6,#2              ;1339
0000dc  4620              MOV      r0,r4                 ;1339
0000de  3010              ADDS     r0,r0,#0x10           ;1339
0000e0  5081              STR      r1,[r0,r2]            ;1339
0000e2  e032              B        |L46.330|
                  |L46.228|
0000e4  2f70              CMP      r7,#0x70              ;1341
0000e6  d130              BNE      |L46.330|
0000e8  0130              LSLS     r0,r6,#4              ;1343
0000ea  491d              LDR      r1,|L46.352|
0000ec  1840              ADDS     r0,r0,r1              ;1343
0000ee  6a80              LDR      r0,[r0,#0x28]         ;1343
0000f0  2160              MOVS     r1,#0x60              ;1343
0000f2  4008              ANDS     r0,r0,r1              ;1343
0000f4  9001              STR      r0,[sp,#4]            ;1343
0000f6  2100              MOVS     r1,#0                 ;1345
0000f8  00b2              LSLS     r2,r6,#2              ;1345
0000fa  4620              MOV      r0,r4                 ;1345
0000fc  3010              ADDS     r0,r0,#0x10           ;1345
0000fe  5081              STR      r1,[r0,r2]            ;1345
000100  9801              LDR      r0,[sp,#4]            ;1347
000102  2820              CMP      r0,#0x20              ;1347
000104  d112              BNE      |L46.300|
000106  0068              LSLS     r0,r5,#1              ;1350
000108  1c40              ADDS     r0,r0,#1              ;1350
00010a  00c0              LSLS     r0,r0,#3              ;1350
00010c  4915              LDR      r1,|L46.356|
00010e  5808              LDR      r0,[r1,r0]            ;1350
000110  2800              CMP      r0,#0                 ;1350
000112  d01a              BEQ      |L46.330|
000114  006a              LSLS     r2,r5,#1              ;1352
000116  1c52              ADDS     r2,r2,#1              ;1352
000118  00d2              LSLS     r2,r2,#3              ;1352
00011a  460b              MOV      r3,r1                 ;1352
00011c  18d2              ADDS     r2,r2,r3              ;1352
00011e  6850              LDR      r0,[r2,#4]            ;1352
000120  006a              LSLS     r2,r5,#1              ;1352
000122  1c52              ADDS     r2,r2,#1              ;1352
000124  00d2              LSLS     r2,r2,#3              ;1352
000126  5899              LDR      r1,[r3,r2]            ;1352
000128  4788              BLX      r1                    ;1352
00012a  e00e              B        |L46.330|
                  |L46.300|
00012c  9801              LDR      r0,[sp,#4]            ;1355
00012e  2840              CMP      r0,#0x40              ;1355
000130  d10b              BNE      |L46.330|
000132  0128              LSLS     r0,r5,#4              ;1358
000134  490b              LDR      r1,|L46.356|
000136  5808              LDR      r0,[r1,r0]            ;1358
000138  2800              CMP      r0,#0                 ;1358
00013a  d006              BEQ      |L46.330|
00013c  012a              LSLS     r2,r5,#4              ;1360
00013e  460b              MOV      r3,r1                 ;1360
000140  18d2              ADDS     r2,r2,r3              ;1360
000142  6850              LDR      r0,[r2,#4]            ;1360
000144  012a              LSLS     r2,r5,#4              ;1360
000146  5899              LDR      r1,[r3,r2]            ;1360
000148  4788              BLX      r1                    ;1360
                  |L46.330|
00014a  9800              LDR      r0,[sp,#0]            ;1309
00014c  1c40              ADDS     r0,r0,#1              ;1309
00014e  9000              STR      r0,[sp,#0]            ;1309
                  |L46.336|
000150  9800              LDR      r0,[sp,#0]            ;1309
000152  2816              CMP      r0,#0x16              ;1309
000154  da00              BGE      |L46.344|
000156  e77e              B        |L46.86|
                  |L46.344|
000158  bf00              NOP      
00015a  e75b              B        |L46.20|
;;;1367   
                          ENDP

                  |L46.348|
                          DCD      0x803f0000
                  |L46.352|
                          DCD      0x40060000
                  |L46.356|
                          DCD      g_sUsbOps

                          AREA ||i.DrvUSB_PreDispatchEvent||, CODE, READONLY, ALIGN=2

                  DrvUSB_PreDispatchEvent PROC
;;;180    /*---------------------------------------------------------------------------------------------------------*/
;;;181    void DrvUSB_PreDispatchEvent(void)
000000  b510              PUSH     {r4,lr}
;;;182    {
;;;183        gsUsbDevice.u32INTSTS = _DRVUSB_GET_EVENT_FLAG();
000002  481f              LDR      r0,|L47.128|
000004  6840              LDR      r0,[r0,#4]
000006  491f              LDR      r1,|L47.132|
000008  60c8              STR      r0,[r1,#0xc]  ; gsUsbDevice
;;;184    
;;;185        if (gsUsbDevice.u32INTSTS & INTSTS_WAKEUP)
00000a  4608              MOV      r0,r1
00000c  68c0              LDR      r0,[r0,#0xc]  ; gsUsbDevice
00000e  2108              MOVS     r1,#8
000010  4208              TST      r0,r1
000012  d006              BEQ      |L47.34|
;;;186        {
;;;187            /* Clear wakeup event. write one clear */
;;;188            _DRVUSB_SET_EVENT_FLAG(INTSTS_WAKEUP);
000014  2008              MOVS     r0,#8
000016  491a              LDR      r1,|L47.128|
000018  6048              STR      r0,[r1,#4]
;;;189            
;;;190            /* Pre-dispatch wakeup event. */
;;;191            DrvUSB_PreDispatchWakeupEvent(&gsUsbDevice);
00001a  481a              LDR      r0,|L47.132|
00001c  f7fffffe          BL       DrvUSB_PreDispatchWakeupEvent
000020  e02d              B        |L47.126|
                  |L47.34|
;;;192        }
;;;193        else if (gsUsbDevice.u32INTSTS & INTSTS_FLDET)
000022  4818              LDR      r0,|L47.132|
000024  68c0              LDR      r0,[r0,#0xc]  ; gsUsbDevice
000026  2104              MOVS     r1,#4
000028  4208              TST      r0,r1
00002a  d00c              BEQ      |L47.70|
;;;194        {
;;;195            gsUsbDevice.u32FLDET = USBD->FLDET.FLDET;
00002c  4814              LDR      r0,|L47.128|
00002e  6940              LDR      r0,[r0,#0x14]
000030  07c0              LSLS     r0,r0,#31
000032  0fc0              LSRS     r0,r0,#31
000034  4913              LDR      r1,|L47.132|
000036  6088              STR      r0,[r1,#8]  ; gsUsbDevice
;;;196            /* Clear float-detection event. Write one clear */
;;;197            _DRVUSB_SET_EVENT_FLAG(INTSTS_FLDET);
000038  2004              MOVS     r0,#4
00003a  4911              LDR      r1,|L47.128|
00003c  6048              STR      r0,[r1,#4]
;;;198    
;;;199            /* Pre-dispatch float-detection event. */
;;;200            DrvUSB_PreDispatchFDTEvent(&gsUsbDevice);
00003e  4811              LDR      r0,|L47.132|
000040  f7fffffe          BL       DrvUSB_PreDispatchFDTEvent
000044  e01b              B        |L47.126|
                  |L47.70|
;;;201        }
;;;202        else if (gsUsbDevice.u32INTSTS & INTSTS_BUS)
000046  480f              LDR      r0,|L47.132|
000048  68c0              LDR      r0,[r0,#0xc]  ; gsUsbDevice
00004a  07c0              LSLS     r0,r0,#31
00004c  0fc0              LSRS     r0,r0,#31
00004e  d00a              BEQ      |L47.102|
;;;203        {
;;;204            gsUsbDevice.u32ATTR = *((__IO uint32_t *)(&USBD->ATTR));
000050  480b              LDR      r0,|L47.128|
000052  6900              LDR      r0,[r0,#0x10]
000054  490b              LDR      r1,|L47.132|
000056  6008              STR      r0,[r1,#0]  ; gsUsbDevice
;;;205            /* Clear bus event. Write one clear */
;;;206            _DRVUSB_SET_EVENT_FLAG(INTSTS_BUS);
000058  2001              MOVS     r0,#1
00005a  4909              LDR      r1,|L47.128|
00005c  6048              STR      r0,[r1,#4]
;;;207            
;;;208            /* Pre-dispatch bus event. */
;;;209            DrvUSB_PreDispatchBusEvent(&gsUsbDevice);
00005e  4809              LDR      r0,|L47.132|
000060  f7fffffe          BL       DrvUSB_PreDispatchBusEvent
000064  e00b              B        |L47.126|
                  |L47.102|
;;;210        }
;;;211        else if (gsUsbDevice.u32INTSTS & INTSTS_USB)
000066  4807              LDR      r0,|L47.132|
000068  68c0              LDR      r0,[r0,#0xc]  ; gsUsbDevice
00006a  2102              MOVS     r1,#2
00006c  4208              TST      r0,r1
00006e  d006              BEQ      |L47.126|
;;;212        {
;;;213            gsUsbDevice.u32EPSTS = _DRVUSB_GET_EPSTS();
000070  4803              LDR      r0,|L47.128|
000072  68c0              LDR      r0,[r0,#0xc]
000074  4903              LDR      r1,|L47.132|
000076  6048              STR      r0,[r1,#4]  ; gsUsbDevice
;;;214            
;;;215            /* Clear USB events individually instead of in total.
;;;216               Otherwise, incoming USB events may be cleared mistakenly.
;;;217               Pre-dispatch USB event. */
;;;218            DrvUSB_PreDispatchEPEvent(&gsUsbDevice);
000078  4608              MOV      r0,r1
00007a  f7fffffe          BL       DrvUSB_PreDispatchEPEvent
                  |L47.126|
;;;219        }
;;;220    }
00007e  bd10              POP      {r4,pc}
;;;221    
                          ENDP

                  |L47.128|
                          DCD      0x40060000
                  |L47.132|
                          DCD      gsUsbDevice

                          AREA ||i.DrvUSB_PreDispatchFDTEvent||, CODE, READONLY, ALIGN=1

                  DrvUSB_PreDispatchFDTEvent PROC
;;;1175   /*---------------------------------------------------------------------------------------------------------*/
;;;1176   void DrvUSB_PreDispatchFDTEvent(S_DRVUSB_DEVICE *psDevice)
000000  b510              PUSH     {r4,lr}
;;;1177   {
000002  4603              MOV      r3,r0
;;;1178       /* Clear all pending events on USB attach/detach to
;;;1179          handle the scenario that the time sequence of event happening
;;;1180          is different from that of event handling. */
;;;1181   
;;;1182       uint32_t u32FLDET = psDevice->u32FLDET;
000004  689c              LDR      r4,[r3,#8]
;;;1183       
;;;1184       if (u32FLDET & 1)
000006  07e0              LSLS     r0,r4,#31
000008  0fc0              LSRS     r0,r0,#31
00000a  d00e              BEQ      |L48.42|
;;;1185       {
;;;1186           /* attached */
;;;1187           if (psDevice->eUsbState == eDRVUSB_DETACHED)
00000c  6fd8              LDR      r0,[r3,#0x7c]
00000e  2800              CMP      r0,#0
000010  d104              BNE      |L48.28|
;;;1188           {
;;;1189               psDevice->eUsbState = eDRVUSB_ATTACHED;
000012  2001              MOVS     r0,#1
000014  67d8              STR      r0,[r3,#0x7c]
;;;1190               DrvUSB_EnableUsb(psDevice);
000016  4618              MOV      r0,r3
000018  f7fffffe          BL       DrvUSB_EnableUsb
                  |L48.28|
;;;1191           }
;;;1192   
;;;1193           psDevice->u16MiscEventFlags |= DRVUSB_EVENT_FLAG_ATTACH;
00001c  2080              MOVS     r0,#0x80
00001e  5ac0              LDRH     r0,[r0,r3]
000020  2101              MOVS     r1,#1
000022  4308              ORRS     r0,r0,r1
000024  2180              MOVS     r1,#0x80
000026  52c8              STRH     r0,[r1,r3]
000028  e00a              B        |L48.64|
                  |L48.42|
;;;1194       }
;;;1195       else
;;;1196       {
;;;1197           /* detached */
;;;1198           psDevice->eUsbState = eDRVUSB_DETACHED;
00002a  2000              MOVS     r0,#0
00002c  67d8              STR      r0,[r3,#0x7c]
;;;1199           DrvUSB_DisableUsb(psDevice);
00002e  4618              MOV      r0,r3
000030  f7fffffe          BL       DrvUSB_DisableUsb
;;;1200   
;;;1201           psDevice->u16MiscEventFlags |= DRVUSB_EVENT_FLAG_DETACH;
000034  2080              MOVS     r0,#0x80
000036  5ac0              LDRH     r0,[r0,r3]
000038  2102              MOVS     r1,#2
00003a  4308              ORRS     r0,r0,r1
00003c  2180              MOVS     r1,#0x80
00003e  52c8              STRH     r0,[r1,r3]
                  |L48.64|
;;;1202       }
;;;1203   }
000040  bd10              POP      {r4,pc}
;;;1204   
                          ENDP


                          AREA ||i.DrvUSB_PreDispatchWakeupEvent||, CODE, READONLY, ALIGN=1

                  DrvUSB_PreDispatchWakeupEvent PROC
;;;1156   /*---------------------------------------------------------------------------------------------------------*/
;;;1157   void DrvUSB_PreDispatchWakeupEvent(S_DRVUSB_DEVICE *psDevice)
000000  4770              BX       lr
;;;1158   {
;;;1159   
;;;1160   }
;;;1161   
                          ENDP


                          AREA ||i.DrvUSB_Reset||, CODE, READONLY, ALIGN=2

                  DrvUSB_Reset PROC
;;;829    /*---------------------------------------------------------------------------------------------------------*/
;;;830    void DrvUSB_Reset(uint32_t u32EpNum)
000000  b530              PUSH     {r4,r5,lr}
;;;831    {
000002  4605              MOV      r5,r0
;;;832        uint32_t u32EpId;
;;;833        u32EpId = DrvUSB_GetEpIdentity(u32EpNum, EP_INPUT);
000004  2180              MOVS     r1,#0x80
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       DrvUSB_GetEpIdentity
00000c  4604              MOV      r4,r0
;;;834        
;;;835        if(u32EpId != E_DRVUSB_INVALID_EP_NUM)
00000e  4813              LDR      r0,|L50.92|
000010  4284              CMP      r4,r0
000012  d00c              BEQ      |L50.46|
;;;836        {
;;;837            _DRVUSB_SET_CFG(u32EpId,  CFG_EP_SETTING[u32EpId]);
000014  00a0              LSLS     r0,r4,#2
000016  4912              LDR      r1,|L50.96|
000018  5808              LDR      r0,[r1,r0]
00001a  0580              LSLS     r0,r0,#22
00001c  0d80              LSRS     r0,r0,#22
00001e  0121              LSLS     r1,r4,#4
000020  4a10              LDR      r2,|L50.100|
000022  1889              ADDS     r1,r1,r2
000024  6288              STR      r0,[r1,#0x28]
;;;838            _DRVUSB_SET_CFGP(u32EpId, CFGP_CLRRDY);
000026  2001              MOVS     r0,#1
000028  0121              LSLS     r1,r4,#4
00002a  1889              ADDS     r1,r1,r2
00002c  62c8              STR      r0,[r1,#0x2c]
                  |L50.46|
;;;839        }
;;;840    
;;;841        u32EpId = DrvUSB_GetEpIdentity(u32EpNum, EP_OUTPUT);
00002e  2100              MOVS     r1,#0
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       DrvUSB_GetEpIdentity
000036  4604              MOV      r4,r0
;;;842        
;;;843        if(u32EpId != E_DRVUSB_INVALID_EP_NUM)
000038  4808              LDR      r0,|L50.92|
00003a  4284              CMP      r4,r0
00003c  d00c              BEQ      |L50.88|
;;;844        {
;;;845            _DRVUSB_SET_CFG(u32EpId,  CFG_EP_SETTING[u32EpId]);
00003e  00a0              LSLS     r0,r4,#2
000040  4907              LDR      r1,|L50.96|
000042  5808              LDR      r0,[r1,r0]
000044  0580              LSLS     r0,r0,#22
000046  0d80              LSRS     r0,r0,#22
000048  0121              LSLS     r1,r4,#4
00004a  4a06              LDR      r2,|L50.100|
00004c  1889              ADDS     r1,r1,r2
00004e  6288              STR      r0,[r1,#0x28]
;;;846            _DRVUSB_SET_CFGP(u32EpId, CFGP_CLRRDY);
000050  2001              MOVS     r0,#1
000052  0121              LSLS     r1,r4,#4
000054  1889              ADDS     r1,r1,r2
000056  62c8              STR      r0,[r1,#0x2c]
                  |L50.88|
;;;847        }
;;;848    
;;;849    
;;;850    }
000058  bd30              POP      {r4,r5,pc}
;;;851    
                          ENDP

00005a  0000              DCW      0x0000
                  |L50.92|
                          DCD      0xffff9902
                  |L50.96|
                          DCD      CFG_EP_SETTING
                  |L50.100|
                          DCD      0x40060000

                          AREA ||i.DrvUSB_SetMaxPower||, CODE, READONLY, ALIGN=2

                  DrvUSB_SetMaxPower PROC
;;;1071   /*---------------------------------------------------------------------------------------------------------*/
;;;1072   int32_t DrvUSB_SetMaxPower(uint32_t u32MaxPower)
000000  4601              MOV      r1,r0
;;;1073   {   
;;;1074       
;;;1075       if (u32MaxPower > 0xFA)
000002  29fa              CMP      r1,#0xfa
000004  d901              BLS      |L51.10|
;;;1076       {
;;;1077           return E_DRVUSB_VALUE_INVALID;
000006  4803              LDR      r0,|L51.20|
                  |L51.8|
;;;1078       }
;;;1079       
;;;1080       gsUsbDevice.u8MaxPower = (uint8_t)u32MaxPower;
;;;1081       
;;;1082       return 0;
;;;1083   }
000008  4770              BX       lr
                  |L51.10|
00000a  4803              LDR      r0,|L51.24|
00000c  7001              STRB     r1,[r0,#0]            ;1080
00000e  2000              MOVS     r0,#0                 ;1082
000010  e7fa              B        |L51.8|
;;;1084   
                          ENDP

000012  0000              DCW      0x0000
                  |L51.20|
                          DCD      0xffff9904
                  |L51.24|
                          DCD      gsUsbDevice+0xa0

                          AREA ||i.DrvUSB_SetUsbState||, CODE, READONLY, ALIGN=2

                  DrvUSB_SetUsbState PROC
;;;306    /*---------------------------------------------------------------------------------------------------------*/
;;;307    void DrvUSB_SetUsbState(E_DRVUSB_STATE eUsbState)
000000  4901              LDR      r1,|L52.8|
;;;308    {
;;;309        gsUsbDevice.eUsbState = eUsbState;
000002  67c8              STR      r0,[r1,#0x7c]  ; gsUsbDevice
;;;310    }
000004  4770              BX       lr
;;;311    
                          ENDP

000006  0000              DCW      0x0000
                  |L52.8|
                          DCD      gsUsbDevice

                          AREA ||i.DrvUSB_UnInit||, CODE, READONLY, ALIGN=2

                  DrvUSB_UnInit PROC
;;;1503   /*---------------------------------------------------------------------------------------------------------*/
;;;1504   static void DrvUSB_UnInit(void)
000000  203b              MOVS     r0,#0x3b
;;;1505   {
;;;1506       /* Disable USB */
;;;1507       _DRVUSB_DISABLE_USB();
000002  0140              LSLS     r0,r0,#5
000004  4904              LDR      r1,|L53.24|
000006  6108              STR      r0,[r1,#0x10]
;;;1508       
;;;1509       /* Disable the USB clock */
;;;1510       SYSCLK->APBCLK.USBD_EN = 0;
000008  4804              LDR      r0,|L53.28|
00000a  6880              LDR      r0,[r0,#8]
00000c  2101              MOVS     r1,#1
00000e  06c9              LSLS     r1,r1,#27
000010  4388              BICS     r0,r0,r1
000012  4902              LDR      r1,|L53.28|
000014  6088              STR      r0,[r1,#8]
;;;1511   }
000016  4770              BX       lr
;;;1512   
                          ENDP

                  |L53.24|
                          DCD      0x40060000
                  |L53.28|
                          DCD      0x50000200

                          AREA ||i.DrvUSB_memcpy||, CODE, READONLY, ALIGN=1

                  DrvUSB_memcpy PROC
;;;1809   /*---------------------------------------------------------------------------------------------------------*/
;;;1810   void DrvUSB_memcpy(uint8_t *pi8Dest, uint8_t *pi8Src, uint32_t u32Size)
000000  b510              PUSH     {r4,lr}
;;;1811   {
000002  4603              MOV      r3,r0
;;;1812       int32_t i;
;;;1813       
;;;1814       for(i=0;i<u32Size;i++)
000004  2000              MOVS     r0,#0
000006  e002              B        |L54.14|
                  |L54.8|
;;;1815       {
;;;1816           pi8Dest[i] = pi8Src[i];
000008  5c0c              LDRB     r4,[r1,r0]
00000a  541c              STRB     r4,[r3,r0]
00000c  1c40              ADDS     r0,r0,#1              ;1814
                  |L54.14|
00000e  4290              CMP      r0,r2                 ;1814
000010  d3fa              BCC      |L54.8|
;;;1817       }
;;;1818   
;;;1819   }
000012  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||i.NVIC_SetPriority||, CODE, READONLY, ALIGN=2

                  NVIC_SetPriority PROC
;;;866     */
;;;867    static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  b510              PUSH     {r4,lr}
;;;868    {
;;;869      if(IRQn < 0) {
000002  2800              CMP      r0,#0
000004  da19              BGE      |L55.58|
;;;870        SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) | 
000006  4a1a              LDR      r2,|L55.112|
000008  0703              LSLS     r3,r0,#28
00000a  0f1b              LSRS     r3,r3,#28
00000c  3b08              SUBS     r3,r3,#8
00000e  089b              LSRS     r3,r3,#2
000010  009b              LSLS     r3,r3,#2
000012  58d2              LDR      r2,[r2,r3]
000014  0783              LSLS     r3,r0,#30
000016  0edc              LSRS     r4,r3,#27
000018  23ff              MOVS     r3,#0xff
00001a  40a3              LSLS     r3,r3,r4
00001c  439a              BICS     r2,r2,r3
00001e  078b              LSLS     r3,r1,#30
000020  0e1b              LSRS     r3,r3,#24
000022  0784              LSLS     r4,r0,#30
000024  0ee4              LSRS     r4,r4,#27
000026  40a3              LSLS     r3,r3,r4
000028  431a              ORRS     r2,r2,r3
00002a  4b11              LDR      r3,|L55.112|
00002c  0704              LSLS     r4,r0,#28
00002e  0f24              LSRS     r4,r4,#28
000030  3c08              SUBS     r4,r4,#8
000032  08a4              LSRS     r4,r4,#2
000034  00a4              LSLS     r4,r4,#2
000036  511a              STR      r2,[r3,r4]
000038  e018              B        |L55.108|
                  |L55.58|
;;;871            (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
;;;872      else {
;;;873        NVIC->IPR[_IP_IDX(IRQn)] = (NVIC->IPR[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
00003a  4a0e              LDR      r2,|L55.116|
00003c  2303              MOVS     r3,#3
00003e  021b              LSLS     r3,r3,#8
000040  18d2              ADDS     r2,r2,r3
000042  0883              LSRS     r3,r0,#2
000044  009b              LSLS     r3,r3,#2
000046  58d2              LDR      r2,[r2,r3]
000048  0783              LSLS     r3,r0,#30
00004a  0edc              LSRS     r4,r3,#27
00004c  23ff              MOVS     r3,#0xff
00004e  40a3              LSLS     r3,r3,r4
000050  439a              BICS     r2,r2,r3
000052  078b              LSLS     r3,r1,#30
000054  0e1b              LSRS     r3,r3,#24
000056  0784              LSLS     r4,r0,#30
000058  0ee4              LSRS     r4,r4,#27
00005a  40a3              LSLS     r3,r3,r4
00005c  431a              ORRS     r2,r2,r3
00005e  4b05              LDR      r3,|L55.116|
000060  2403              MOVS     r4,#3
000062  0224              LSLS     r4,r4,#8
000064  191b              ADDS     r3,r3,r4
000066  0884              LSRS     r4,r0,#2
000068  00a4              LSLS     r4,r4,#2
00006a  511a              STR      r2,[r3,r4]
                  |L55.108|
;;;874            (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
;;;875    }
00006c  bd10              POP      {r4,pc}
;;;876    
                          ENDP

00006e  0000              DCW      0x0000
                  |L55.112|
                          DCD      0xe000ed1c
                  |L55.116|
                          DCD      0xe000e100

                          AREA ||i.USBD_IRQHandler||, CODE, READONLY, ALIGN=2

                  USBD_IRQHandler PROC
;;;60     /*---------------------------------------------------------------------------------------------------------*/
;;;61     void USBD_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;62     {
;;;63          DrvUSB_PreDispatchEvent();
000002  f7fffffe          BL       DrvUSB_PreDispatchEvent
;;;64          if (g_FnIntCallBack)
000006  4804              LDR      r0,|L56.24|
000008  6800              LDR      r0,[r0,#0]  ; g_FnIntCallBack
00000a  2800              CMP      r0,#0
00000c  d003              BEQ      |L56.22|
;;;65              g_FnIntCallBack((void *)&gsUsbDevice);
00000e  4803              LDR      r0,|L56.28|
000010  4901              LDR      r1,|L56.24|
000012  6809              LDR      r1,[r1,#0]  ; g_FnIntCallBack
000014  4788              BLX      r1
                  |L56.22|
;;;66     }
000016  bd10              POP      {r4,pc}
;;;67     
                          ENDP

                  |L56.24|
                          DCD      g_FnIntCallBack
                  |L56.28|
                          DCD      gsUsbDevice

                          AREA ||i.WordsCpy||, CODE, READONLY, ALIGN=1

                  WordsCpy PROC
;;;15     
;;;16     void WordsCpy(void *dest, void *src, int32_t size)
000000  b570              PUSH     {r4-r6,lr}
;;;17     {
000002  4603              MOV      r3,r0
;;;18         uint8_t *pu8Src, *pu8Dest;
;;;19         int32_t i;
;;;20         
;;;21         pu8Dest = (uint8_t *)dest;
000004  461d              MOV      r5,r3
;;;22         pu8Src  = (uint8_t *)src;
000006  460c              MOV      r4,r1
;;;23         
;;;24         for(i=0;i<size;i++)
000008  2000              MOVS     r0,#0
00000a  e002              B        |L57.18|
                  |L57.12|
;;;25             pu8Dest[i] = pu8Src[i]; 
00000c  5c26              LDRB     r6,[r4,r0]
00000e  542e              STRB     r6,[r5,r0]
000010  1c40              ADDS     r0,r0,#1              ;24
                  |L57.18|
000012  4290              CMP      r0,r2                 ;24
000014  dbfa              BLT      |L57.12|
;;;26     }
000016  bd70              POP      {r4-r6,pc}
;;;27     
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  gsUsbDevice
                          %        168
                  CFG_EP_SETTING
                          %        24

                          AREA ||.data||, DATA, ALIGN=2

                  g_FnIntCallBack
                          DCD      0x00000000
                  g_UsbSramBase
                          DCD      0x00000000
