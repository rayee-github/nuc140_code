; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\smpl_can.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\smpl_can.d --cpu=Cortex-M0 --apcs=interwork -O0 -I.\ -I..\..\..\..\CMSIS\CM0\CoreSupport -I..\..\..\..\CMSIS\CM0\DeviceSupport\Nuvoton\NUC1xx -I..\..\..\Include -I..\..\..\Include\Driver -I..\..\..\Include\NUC1xx-LB_002 -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\smpl_can.crf Smpl_CAN.c]
                          THUMB

                          AREA ||i.DelayNs||, CODE, READONLY, ALIGN=1

                  DelayNs PROC
;;;76     
;;;77     void DelayNs(int n)
000000  2100              MOVS     r1,#0
;;;78     {
;;;79     	int i = 0;
;;;80     	for(i=0;i<n;i++)__NOP();
000002  bf00              NOP      
000004  e001              B        |L1.10|
                  |L1.6|
000006  bf00              NOP      
000008  1c49              ADDS     r1,r1,#1
                  |L1.10|
00000a  4281              CMP      r1,r0
00000c  dbfb              BLT      |L1.6|
;;;81     }
00000e  4770              BX       lr
;;;82     
                          ENDP


                          AREA ||i.DrvGPIO_set||, CODE, READONLY, ALIGN=2

                  DrvGPIO_set PROC
;;;82     
;;;83     void DrvGPIO_set(E_DRVGPIO_IO mode)
000000  4601              MOV      r1,r0
;;;84     {
;;;85         volatile uint32_t u32Reg;
;;;86         u32Reg = (uint32_t)&GPIOA->PMD + (4*0x40);
000002  4806              LDR      r0,|L2.28|
;;;87         outpw(u32Reg, inpw(u32Reg) & ~(0x3<<(1*2)));
000004  6802              LDR      r2,[r0,#0]
000006  230c              MOVS     r3,#0xc
000008  439a              BICS     r2,r2,r3
00000a  6002              STR      r2,[r0,#0]
;;;88         if (mode == E_IO_OUTPUT)outpw(u32Reg, inpw(u32Reg) | (0x1<<(1*2)));
00000c  2901              CMP      r1,#1
00000e  d103              BNE      |L2.24|
000010  6802              LDR      r2,[r0,#0]
000012  2304              MOVS     r3,#4
000014  431a              ORRS     r2,r2,r3
000016  6002              STR      r2,[r0,#0]
                  |L2.24|
;;;89     }
000018  4770              BX       lr
;;;90     
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      0x50004100

                          AREA ||i.Read_BT70791||, CODE, READONLY, ALIGN=2

                  Read_BT70791 PROC
;;;207    
;;;208    uint16_t Read_BT70791(uint8_t data)
000000  b5f1              PUSH     {r0,r4-r7,lr}
;;;209    {
000002  b082              SUB      sp,sp,#8
;;;210    	uint8_t L,H;
;;;211    	uint32_t i;
;;;212    	int count = 0;
000004  2700              MOVS     r7,#0
;;;213        //Open I2C1 and set clock = 50Kbps
;;;214    	SystemCoreClock = DrvSYS_GetHCLKFreq(); 
000006  f7fffffe          BL       DrvSYS_GetHCLKFreq
00000a  494d              LDR      r1,|L3.320|
00000c  6008              STR      r0,[r1,#0]  ; SystemCoreClock
;;;215    	DrvI2C_Open(I2C_PORT1, 50000);
00000e  494d              LDR      r1,|L3.324|
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       DrvI2C_Open
;;;216    	//send i2c start
;;;217        DrvI2C_Ctrl(I2C_PORT1, 1, 0, 1, 1);	 	//set start
000016  2301              MOVS     r3,#1
000018  2200              MOVS     r2,#0
00001a  4619              MOV      r1,r3
00001c  4618              MOV      r0,r3
00001e  9300              STR      r3,[sp,#0]
000020  f7fffffe          BL       DrvI2C_Ctrl
;;;218    	while (I2C1->I2CON.SI == 0);				//poll si flag
000024  bf00              NOP      
                  |L3.38|
000026  4848              LDR      r0,|L3.328|
000028  6800              LDR      r0,[r0,#0]
00002a  0700              LSLS     r0,r0,#28
00002c  0fc0              LSRS     r0,r0,#31
00002e  d0fa              BEQ      |L3.38|
;;;219       	//send writer command
;;;220    	I2C1->I2CDAT = 0x16;
000030  2016              MOVS     r0,#0x16
000032  4945              LDR      r1,|L3.328|
000034  6088              STR      r0,[r1,#8]
;;;221        DrvI2C_Ctrl(I2C_PORT1, 0, 0, 1, 1);	   //clr si
000036  2301              MOVS     r3,#1
000038  2200              MOVS     r2,#0
00003a  4611              MOV      r1,r2
00003c  4618              MOV      r0,r3
00003e  9300              STR      r3,[sp,#0]
000040  f7fffffe          BL       DrvI2C_Ctrl
;;;222        while( I2C1->I2CON.SI == 0 );			   //poll si flag
000044  bf00              NOP      
                  |L3.70|
000046  4840              LDR      r0,|L3.328|
000048  6800              LDR      r0,[r0,#0]
00004a  0700              LSLS     r0,r0,#28
00004c  0fc0              LSRS     r0,r0,#31
00004e  d0fa              BEQ      |L3.70|
;;;223    	//send data
;;;224    	I2C1->I2CDAT = data;					//write data to 
000050  493d              LDR      r1,|L3.328|
000052  9802              LDR      r0,[sp,#8]
000054  6088              STR      r0,[r1,#8]
;;;225    	DrvI2C_Ctrl(I2C_PORT1, 0, 0, 1, 1); //clr si and set ack	
000056  2301              MOVS     r3,#1
000058  2200              MOVS     r2,#0
00005a  4611              MOV      r1,r2
00005c  4618              MOV      r0,r3
00005e  9300              STR      r3,[sp,#0]
000060  f7fffffe          BL       DrvI2C_Ctrl
;;;226    	while( I2C1->I2CON.SI == 0 );			//poll si flag
000064  bf00              NOP      
                  |L3.102|
000066  4838              LDR      r0,|L3.328|
000068  6800              LDR      r0,[r0,#0]
00006a  0700              LSLS     r0,r0,#28
00006c  0fc0              LSRS     r0,r0,#31
00006e  d0fa              BEQ      |L3.102|
;;;227    	//send i2c start
;;;228        DrvI2C_Ctrl(I2C_PORT1, 1, 0, 1, 1);	 	//set start
000070  2301              MOVS     r3,#1
000072  2200              MOVS     r2,#0
000074  4619              MOV      r1,r3
000076  4618              MOV      r0,r3
000078  9300              STR      r3,[sp,#0]
00007a  f7fffffe          BL       DrvI2C_Ctrl
;;;229    	while (I2C1->I2CON.SI == 0);				//poll si flag
00007e  bf00              NOP      
                  |L3.128|
000080  4831              LDR      r0,|L3.328|
000082  6800              LDR      r0,[r0,#0]
000084  0700              LSLS     r0,r0,#28
000086  0fc0              LSRS     r0,r0,#31
000088  d0fa              BEQ      |L3.128|
;;;230       	//send writer command
;;;231    	I2C1->I2CDAT = 0x17;
00008a  2017              MOVS     r0,#0x17
00008c  492e              LDR      r1,|L3.328|
00008e  6088              STR      r0,[r1,#8]
;;;232        DrvI2C_Ctrl(I2C_PORT1, 0, 0, 1, 1);	   //clr si
000090  2301              MOVS     r3,#1
000092  2200              MOVS     r2,#0
000094  4611              MOV      r1,r2
000096  4618              MOV      r0,r3
000098  9300              STR      r3,[sp,#0]
00009a  f7fffffe          BL       DrvI2C_Ctrl
;;;233        while( I2C1->I2CON.SI == 0 );			   //poll si flag
00009e  bf00              NOP      
                  |L3.160|
0000a0  4829              LDR      r0,|L3.328|
0000a2  6800              LDR      r0,[r0,#0]
0000a4  0700              LSLS     r0,r0,#28
0000a6  0fc0              LSRS     r0,r0,#31
0000a8  d0fa              BEQ      |L3.160|
;;;234    	//resive data
;;;235    	I2C1->I2CDAT = 0XFF;
0000aa  20ff              MOVS     r0,#0xff
0000ac  4926              LDR      r1,|L3.328|
0000ae  6088              STR      r0,[r1,#8]
;;;236    	DrvI2C_Ctrl(I2C_PORT1, 0, 0, 1, 1);    //clr si	
0000b0  2301              MOVS     r3,#1
0000b2  2200              MOVS     r2,#0
0000b4  4611              MOV      r1,r2
0000b6  4618              MOV      r0,r3
0000b8  9300              STR      r3,[sp,#0]
0000ba  f7fffffe          BL       DrvI2C_Ctrl
;;;237    	while( I2C1->I2CON.SI == 0 );			   //poll si flag
0000be  bf00              NOP      
                  |L3.192|
0000c0  4821              LDR      r0,|L3.328|
0000c2  6800              LDR      r0,[r0,#0]
0000c4  0700              LSLS     r0,r0,#28
0000c6  0fc0              LSRS     r0,r0,#31
0000c8  d0fa              BEQ      |L3.192|
;;;238    	L= I2C1->I2CDAT;
0000ca  481f              LDR      r0,|L3.328|
0000cc  6880              LDR      r0,[r0,#8]
0000ce  b2c4              UXTB     r4,r0
;;;239    	DAT1=L;
0000d0  481e              LDR      r0,|L3.332|
0000d2  7004              STRB     r4,[r0,#0]
;;;240    	//resive data
;;;241    	I2C1->I2CDAT = 0XFF;
0000d4  20ff              MOVS     r0,#0xff
0000d6  491c              LDR      r1,|L3.328|
0000d8  6088              STR      r0,[r1,#8]
;;;242    	DrvI2C_Ctrl(I2C_PORT1, 0, 0, 1, 0);    //clr si	
0000da  2300              MOVS     r3,#0
0000dc  9300              STR      r3,[sp,#0]
0000de  2301              MOVS     r3,#1
0000e0  2200              MOVS     r2,#0
0000e2  4611              MOV      r1,r2
0000e4  4618              MOV      r0,r3
0000e6  f7fffffe          BL       DrvI2C_Ctrl
;;;243    	while( I2C1->I2CON.SI == 0 );			   //poll si flag
0000ea  bf00              NOP      
                  |L3.236|
0000ec  4816              LDR      r0,|L3.328|
0000ee  6800              LDR      r0,[r0,#0]
0000f0  0700              LSLS     r0,r0,#28
0000f2  0fc0              LSRS     r0,r0,#31
0000f4  d0fa              BEQ      |L3.236|
;;;244    	H = I2C1->I2CDAT;
0000f6  4814              LDR      r0,|L3.328|
0000f8  6880              LDR      r0,[r0,#8]
0000fa  b2c5              UXTB     r5,r0
;;;245    	DAT2=H;
0000fc  4814              LDR      r0,|L3.336|
0000fe  7005              STRB     r5,[r0,#0]
;;;246    	//send i2c stop
;;;247     	DrvI2C_Ctrl(I2C_PORT1, 0, 1, 1, 0);    //clr si and set stop
000100  2300              MOVS     r3,#0
000102  9300              STR      r3,[sp,#0]
000104  2301              MOVS     r3,#1
000106  461a              MOV      r2,r3
000108  2100              MOVS     r1,#0
00010a  4618              MOV      r0,r3
00010c  f7fffffe          BL       DrvI2C_Ctrl
;;;248    	while( I2C1->I2CON.STO){
000110  e005              B        |L3.286|
                  |L3.274|
;;;249    		count++;
000112  1c7f              ADDS     r7,r7,#1
;;;250    		if(count>10000){
000114  480f              LDR      r0,|L3.340|
000116  4287              CMP      r7,r0
000118  dd01              BLE      |L3.286|
;;;251    			H = 0x20;
00011a  2520              MOVS     r5,#0x20
;;;252    			break;
00011c  e004              B        |L3.296|
                  |L3.286|
00011e  480a              LDR      r0,|L3.328|
000120  6800              LDR      r0,[r0,#0]            ;248
000122  06c0              LSLS     r0,r0,#27             ;248
000124  0fc0              LSRS     r0,r0,#31             ;248
000126  d1f4              BNE      |L3.274|
                  |L3.296|
000128  bf00              NOP      
;;;253    		}
;;;254    	}
;;;255    	for(i=0;i<60;i++);
00012a  2600              MOVS     r6,#0
00012c  e000              B        |L3.304|
                  |L3.302|
00012e  1c76              ADDS     r6,r6,#1
                  |L3.304|
000130  2e3c              CMP      r6,#0x3c
000132  d3fc              BCC      |L3.302|
;;;256    	DrvI2C_Close(I2C_PORT1);
000134  2001              MOVS     r0,#1
000136  f7fffffe          BL       DrvI2C_Close
;;;257    	return ((H * 0x100) | L); 
00013a  0228              LSLS     r0,r5,#8
00013c  4320              ORRS     r0,r0,r4
;;;258    }
00013e  bdfe              POP      {r1-r7,pc}
;;;259     volatile uint8_t comRbuf[16] ={0x30};
                          ENDP

                  |L3.320|
                          DCD      SystemCoreClock
                  |L3.324|
                          DCD      0x0000c350
                  |L3.328|
                          DCD      0x40120000
                  |L3.332|
                          DCD      DAT1
                  |L3.336|
                          DCD      DAT2
                  |L3.340|
                          DCD      0x00002710

                          AREA ||i.SMBus_A||, CODE, READONLY, ALIGN=2

                  SMBus_A PROC
;;;135    
;;;136    void SMBus_A(void)
000000  b500              PUSH     {lr}
;;;137    {
;;;138    	STE_DATA_READ;
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       DrvGPIO_set
;;;139    	SMBDATA = H;
000008  2001              MOVS     r0,#1
00000a  4906              LDR      r1,|L4.36|
00000c  6048              STR      r0,[r1,#4]
;;;140    	SMBCLK	= H;
00000e  6008              STR      r0,[r1,#0]
;;;141    	DelayNs(D0);
000010  2014              MOVS     r0,#0x14
000012  f7fffffe          BL       DelayNs
;;;142    	SMBCLK	= L;
000016  2000              MOVS     r0,#0
000018  4902              LDR      r1,|L4.36|
00001a  6008              STR      r0,[r1,#0]
;;;143    	DelayNs(D0);
00001c  2014              MOVS     r0,#0x14
00001e  f7fffffe          BL       DelayNs
;;;144    	//while(SMBDATA);
;;;145    }
000022  bd00              POP      {pc}
;;;146    
                          ENDP

                  |L4.36|
                          DCD      0x50004300

                          AREA ||i.SMBus_Init||, CODE, READONLY, ALIGN=2

                  SMBus_Init PROC
;;;90     
;;;91     void SMBus_Init(void)
000000  b510              PUSH     {r4,lr}
;;;92     {
;;;93     	DrvGPIO_Open(E_GPE, 0, E_IO_OUTPUT);
000002  2201              MOVS     r2,#1
000004  2100              MOVS     r1,#0
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       DrvGPIO_Open
;;;94     	DrvGPIO_Open(E_GPE, 1, E_IO_OUTPUT);
00000c  2201              MOVS     r2,#1
00000e  4611              MOV      r1,r2
000010  2004              MOVS     r0,#4
000012  f7fffffe          BL       DrvGPIO_Open
;;;95     	SMBCLK	= H;
000016  2001              MOVS     r0,#1
000018  4901              LDR      r1,|L5.32|
00001a  6008              STR      r0,[r1,#0]
;;;96     	SMBDATA	= H;
00001c  6048              STR      r0,[r1,#4]
;;;97     }
00001e  bd10              POP      {r4,pc}
;;;98     
                          ENDP

                  |L5.32|
                          DCD      0x50004300

                          AREA ||i.SMBus_NA||, CODE, READONLY, ALIGN=2

                  SMBus_NA PROC
;;;146    
;;;147    void SMBus_NA(void)
000000  b500              PUSH     {lr}
;;;148    {
;;;149    	STE_DATA_READ;
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       DrvGPIO_set
;;;150    	SMBDATA = H;
000008  2001              MOVS     r0,#1
00000a  4906              LDR      r1,|L6.36|
00000c  6048              STR      r0,[r1,#4]
;;;151    	SMBCLK	= H;
00000e  6008              STR      r0,[r1,#0]
;;;152    	DelayNs(D0);
000010  2014              MOVS     r0,#0x14
000012  f7fffffe          BL       DelayNs
;;;153    	SMBCLK	= L;
000016  2000              MOVS     r0,#0
000018  4902              LDR      r1,|L6.36|
00001a  6008              STR      r0,[r1,#0]
;;;154    	DelayNs(D0);
00001c  2014              MOVS     r0,#0x14
00001e  f7fffffe          BL       DelayNs
;;;155    	//while(!SMBDATA);
;;;156    }
000022  bd00              POP      {pc}
;;;157    
                          ENDP

                  |L6.36|
                          DCD      0x50004300

                          AREA ||i.SMBus_P||, CODE, READONLY, ALIGN=2

                  SMBus_P PROC
;;;109    
;;;110    void SMBus_P(void)
000000  b500              PUSH     {lr}
;;;111    {
;;;112    	STE_DATA_WRITE;
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       DrvGPIO_set
;;;113    	SMBCLK	= H;
000008  2001              MOVS     r0,#1
00000a  4908              LDR      r1,|L7.44|
00000c  6008              STR      r0,[r1,#0]
;;;114    	SMBDATA	= L;
00000e  2000              MOVS     r0,#0
000010  6048              STR      r0,[r1,#4]
;;;115    	DelayNs(D0);
000012  2014              MOVS     r0,#0x14
000014  f7fffffe          BL       DelayNs
;;;116    	SMBDATA	= H;
000018  2001              MOVS     r0,#1
00001a  4904              LDR      r1,|L7.44|
00001c  6048              STR      r0,[r1,#4]
;;;117    	DelayNs(D0);
00001e  2014              MOVS     r0,#0x14
000020  f7fffffe          BL       DelayNs
;;;118    	SMBCLK	= L;
000024  2000              MOVS     r0,#0
000026  4901              LDR      r1,|L7.44|
000028  6008              STR      r0,[r1,#0]
;;;119    }
00002a  bd00              POP      {pc}
;;;120    
                          ENDP

                  |L7.44|
                          DCD      0x50004300

                          AREA ||i.SMBus_RDB||, CODE, READONLY, ALIGN=2

                  SMBus_RDB PROC
;;;157    
;;;158    uint8_t SMBus_RDB(void)
000000  b570              PUSH     {r4-r6,lr}
;;;159    {
;;;160    	uint8_t mask = 0x80;
000002  2580              MOVS     r5,#0x80
;;;161    	uint8_t data = 0x00;
000004  2400              MOVS     r4,#0
;;;162    	uint8_t text = 0x00;
000006  2600              MOVS     r6,#0
;;;163    	STE_DATA_READ;
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       DrvGPIO_set
;;;164    	SMBDATA	= H;
00000e  2001              MOVS     r0,#1
000010  490f              LDR      r1,|L8.80|
000012  6048              STR      r0,[r1,#4]
;;;165    	while(mask != 0)
000014  e018              B        |L8.72|
                  |L8.22|
;;;166    	{	
;;;167    		text = (SMBDATA == 1)? H:L;
000016  480e              LDR      r0,|L8.80|
000018  6840              LDR      r0,[r0,#4]
00001a  2801              CMP      r0,#1
00001c  d100              BNE      |L8.32|
00001e  e000              B        |L8.34|
                  |L8.32|
000020  2000              MOVS     r0,#0
                  |L8.34|
000022  b2c6              UXTB     r6,r0
;;;168    		data = data | text;
000024  4620              MOV      r0,r4
000026  4330              ORRS     r0,r0,r6
000028  4604              MOV      r4,r0
;;;169    		data = data << 1;
00002a  0660              LSLS     r0,r4,#25
00002c  0e04              LSRS     r4,r0,#24
;;;170    		mask = mask >> 1;
00002e  106d              ASRS     r5,r5,#1
;;;171    		SMBCLK	= H;
000030  2001              MOVS     r0,#1
000032  4907              LDR      r1,|L8.80|
000034  6008              STR      r0,[r1,#0]
;;;172    		DelayNs(D0);
000036  2014              MOVS     r0,#0x14
000038  f7fffffe          BL       DelayNs
;;;173    		SMBCLK	= L;
00003c  2000              MOVS     r0,#0
00003e  4904              LDR      r1,|L8.80|
000040  6008              STR      r0,[r1,#0]
;;;174    		DelayNs(D0);
000042  2014              MOVS     r0,#0x14
000044  f7fffffe          BL       DelayNs
                  |L8.72|
000048  2d00              CMP      r5,#0                 ;165
00004a  d1e4              BNE      |L8.22|
;;;175    	}
;;;176    	return data;
00004c  4620              MOV      r0,r4
;;;177    }
00004e  bd70              POP      {r4-r6,pc}
;;;178    
                          ENDP

                  |L8.80|
                          DCD      0x50004300

                          AREA ||i.SMBus_S||, CODE, READONLY, ALIGN=2

                  SMBus_S PROC
;;;98     
;;;99     void SMBus_S(void)
000000  b500              PUSH     {lr}
;;;100    {
;;;101    	STE_DATA_WRITE;
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       DrvGPIO_set
;;;102    	SMBCLK	= H;
000008  2001              MOVS     r0,#1
00000a  4908              LDR      r1,|L9.44|
00000c  6008              STR      r0,[r1,#0]
;;;103    	SMBDATA	= H;
00000e  6048              STR      r0,[r1,#4]
;;;104    	DelayNs(D0);
000010  2014              MOVS     r0,#0x14
000012  f7fffffe          BL       DelayNs
;;;105    	SMBDATA	= L;
000016  2000              MOVS     r0,#0
000018  4904              LDR      r1,|L9.44|
00001a  6048              STR      r0,[r1,#4]
;;;106    	DelayNs(D0);
00001c  2014              MOVS     r0,#0x14
00001e  f7fffffe          BL       DelayNs
;;;107    	SMBCLK	= L;
000022  2000              MOVS     r0,#0
000024  4901              LDR      r1,|L9.44|
000026  6008              STR      r0,[r1,#0]
;;;108    }
000028  bd00              POP      {pc}
;;;109    
                          ENDP

00002a  0000              DCW      0x0000
                  |L9.44|
                          DCD      0x50004300

                          AREA ||i.SMBus_WDB||, CODE, READONLY, ALIGN=2

                  SMBus_WDB PROC
;;;120    
;;;121    void SMBus_WDB(uint8_t data)
000000  b530              PUSH     {r4,r5,lr}
;;;122    {
000002  4605              MOV      r5,r0
;;;123    	uint8_t mask = 0x80;
000004  2480              MOVS     r4,#0x80
;;;124    	STE_DATA_WRITE;
000006  2001              MOVS     r0,#1
000008  f7fffffe          BL       DrvGPIO_set
;;;125    	while(mask != 0)
00000c  e013              B        |L10.54|
                  |L10.14|
;;;126    	{	
;;;127    		SMBDATA = (mask&data) ? H:L;
00000e  4620              MOV      r0,r4
000010  4228              TST      r0,r5
000012  d001              BEQ      |L10.24|
000014  2001              MOVS     r0,#1
000016  e000              B        |L10.26|
                  |L10.24|
000018  2000              MOVS     r0,#0
                  |L10.26|
00001a  4908              LDR      r1,|L10.60|
00001c  6048              STR      r0,[r1,#4]
;;;128    		mask = mask >> 1;
00001e  1064              ASRS     r4,r4,#1
;;;129    		SMBCLK	= H;
000020  2001              MOVS     r0,#1
000022  6008              STR      r0,[r1,#0]
;;;130    		DelayNs(D0);
000024  2014              MOVS     r0,#0x14
000026  f7fffffe          BL       DelayNs
;;;131    		SMBCLK	= L;
00002a  2000              MOVS     r0,#0
00002c  4903              LDR      r1,|L10.60|
00002e  6008              STR      r0,[r1,#0]
;;;132    		DelayNs(D0);
000030  2014              MOVS     r0,#0x14
000032  f7fffffe          BL       DelayNs
                  |L10.54|
000036  2c00              CMP      r4,#0                 ;125
000038  d1e9              BNE      |L10.14|
;;;133    	}
;;;134    }
00003a  bd30              POP      {r4,r5,pc}
;;;135    
                          ENDP

                  |L10.60|
                          DCD      0x50004300

                          AREA ||i.UART_INT_HANDLE||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  UART_INT_HANDLE PROC
;;;269    /*---------------------------------------------------------------------------------------------------------*/
;;;270    void UART_INT_HANDLE(void)
000000  b508              PUSH     {r3,lr}
;;;271    {
;;;272    	uint8_t i;
;;;273    	uint8_t bInChar[1] = {0xFF};
000002  a018              ADR      r0,|L11.100|
000004  6800              LDR      r0,[r0,#0]
000006  9000              STR      r0,[sp,#0]
;;;274    
;;;275    	while(UART0->ISR.RDA_IF==1) 
000008  e025              B        |L11.86|
                  |L11.10|
;;;276    	{
;;;277    		DrvUART_Read(UART_PORT0,bInChar,1);	
00000a  2201              MOVS     r2,#1
00000c  4669              MOV      r1,sp
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       DrvUART_Read
;;;278    		if(comRbytes < 8) // check if Buffer is full
000014  4814              LDR      r0,|L11.104|
000016  8800              LDRH     r0,[r0,#0]  ; comRbytes
000018  2808              CMP      r0,#8
00001a  da0b              BGE      |L11.52|
;;;279    		{
;;;280    			comRbuf[comRbytes] = bInChar[0];
00001c  4668              MOV      r0,sp
00001e  7800              LDRB     r0,[r0,#0]
000020  4912              LDR      r1,|L11.108|
000022  4a11              LDR      r2,|L11.104|
000024  8812              LDRH     r2,[r2,#0]  ; comRbytes
000026  5488              STRB     r0,[r1,r2]
;;;281    			comRbytes++;
000028  480f              LDR      r0,|L11.104|
00002a  8800              LDRH     r0,[r0,#0]  ; comRbytes
00002c  1c40              ADDS     r0,r0,#1
00002e  490e              LDR      r1,|L11.104|
000030  8008              STRH     r0,[r1,#0]
000032  e010              B        |L11.86|
                  |L11.52|
;;;282    		}
;;;283    		else if (comRbytes==8)
000034  480c              LDR      r0,|L11.104|
000036  8800              LDRH     r0,[r0,#0]  ; comRbytes
000038  2808              CMP      r0,#8
00003a  d10c              BNE      |L11.86|
;;;284    		{
;;;285    			comRbytes=0;
00003c  2000              MOVS     r0,#0
00003e  490a              LDR      r1,|L11.104|
000040  8008              STRH     r0,[r1,#0]
;;;286    			sprintf(TEXT2+4,"%s",comRbuf);
000042  4a0a              LDR      r2,|L11.108|
000044  a10a              ADR      r1,|L11.112|
000046  480b              LDR      r0,|L11.116|
000048  f7fffffe          BL       __2sprintf
;;;287    			print_lcd(2,TEXT2);
00004c  4909              LDR      r1,|L11.116|
00004e  1f09              SUBS     r1,r1,#4
000050  2002              MOVS     r0,#2
000052  f7fffffe          BL       print_lcd
                  |L11.86|
000056  4808              LDR      r0,|L11.120|
000058  69c0              LDR      r0,[r0,#0x1c]         ;275
00005a  07c0              LSLS     r0,r0,#31             ;275
00005c  0fc0              LSRS     r0,r0,#31             ;275
00005e  2801              CMP      r0,#1                 ;275
000060  d0d3              BEQ      |L11.10|
;;;288    		}			
;;;289    	}
;;;290    }
000062  bd08              POP      {r3,pc}
;;;291    int main (void)
                          ENDP

                  |L11.100|
000064  ff00              DCB      255,0
000066  00                DCB      0
000067  00                DCB      0
                  |L11.104|
                          DCD      comRbytes
                  |L11.108|
                          DCD      comRbuf
                  |L11.112|
000070  257300            DCB      "%s",0
000073  00                DCB      0
                  |L11.116|
                          DCD      TEXT2+0x4
                  |L11.120|
                          DCD      0x40050000

                          AREA ||i.Write_BT70791||, CODE, READONLY, ALIGN=2

                  Write_BT70791 PROC
;;;178    
;;;179    void Write_BT70791(uint8_t address,uint8_t data )
000000  b5f8              PUSH     {r3-r7,lr}
;;;180    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;181    	uint32_t i;
;;;182    	SystemCoreClock = DrvSYS_GetHCLKFreq(); 
000006  f7fffffe          BL       DrvSYS_GetHCLKFreq
00000a  492a              LDR      r1,|L12.180|
00000c  6008              STR      r0,[r1,#0]  ; SystemCoreClock
;;;183        //Open I2C1 and set clock = 50Kbps 
;;;184    	DrvI2C_Open(I2C_PORT1, 50000);
00000e  492a              LDR      r1,|L12.184|
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       DrvI2C_Open
;;;185       	//send i2c start
;;;186    	DrvI2C_Ctrl(I2C_PORT1, 1, 0, 0, 1);	//set start
000016  2301              MOVS     r3,#1
000018  9300              STR      r3,[sp,#0]
00001a  2300              MOVS     r3,#0
00001c  461a              MOV      r2,r3
00001e  2101              MOVS     r1,#1
000020  4608              MOV      r0,r1
000022  f7fffffe          BL       DrvI2C_Ctrl
;;;187    	while (I2C1->I2CON.SI == 0);			//poll si flag
000026  bf00              NOP      
                  |L12.40|
000028  4824              LDR      r0,|L12.188|
00002a  6800              LDR      r0,[r0,#0]
00002c  0700              LSLS     r0,r0,#28
00002e  0fc0              LSRS     r0,r0,#31
000030  d0fa              BEQ      |L12.40|
;;;188    	//send writer command
;;;189    	I2C1->I2CDAT = address;					//send writer command
000032  4822              LDR      r0,|L12.188|
000034  6085              STR      r5,[r0,#8]
;;;190        DrvI2C_Ctrl(I2C_PORT1, 0, 0, 1, 1); //clr si flag
000036  2301              MOVS     r3,#1
000038  2200              MOVS     r2,#0
00003a  4611              MOV      r1,r2
00003c  4618              MOV      r0,r3
00003e  9300              STR      r3,[sp,#0]
000040  f7fffffe          BL       DrvI2C_Ctrl
;;;191        while( I2C1->I2CON.SI == 0 );		    //poll si flag
000044  bf00              NOP      
                  |L12.70|
000046  481d              LDR      r0,|L12.188|
000048  6800              LDR      r0,[r0,#0]
00004a  0700              LSLS     r0,r0,#28
00004c  0fc0              LSRS     r0,r0,#31
00004e  d0fa              BEQ      |L12.70|
;;;192    	//send data
;;;193    	I2C1->I2CDAT = data;					//write data to 
000050  481a              LDR      r0,|L12.188|
000052  6086              STR      r6,[r0,#8]
;;;194    	DrvI2C_Ctrl(I2C_PORT1, 0, 0, 1, 1); //clr si and set ack	
000054  2301              MOVS     r3,#1
000056  2200              MOVS     r2,#0
000058  4611              MOV      r1,r2
00005a  4618              MOV      r0,r3
00005c  9300              STR      r3,[sp,#0]
00005e  f7fffffe          BL       DrvI2C_Ctrl
;;;195    	while( I2C1->I2CON.SI == 0 );			//poll si flag
000062  bf00              NOP      
                  |L12.100|
000064  4815              LDR      r0,|L12.188|
000066  6800              LDR      r0,[r0,#0]
000068  0700              LSLS     r0,r0,#28
00006a  0fc0              LSRS     r0,r0,#31
00006c  d0fa              BEQ      |L12.100|
;;;196       	//send i2c stop
;;;197    	DrvI2C_Ctrl(I2C_PORT1, 0, 1, 1, 0); //send stop	
00006e  2300              MOVS     r3,#0
000070  9300              STR      r3,[sp,#0]
000072  2301              MOVS     r3,#1
000074  461a              MOV      r2,r3
000076  2100              MOVS     r1,#0
000078  4618              MOV      r0,r3
00007a  f7fffffe          BL       DrvI2C_Ctrl
;;;198    	while( I2C1->I2CON.STO);
00007e  bf00              NOP      
                  |L12.128|
000080  480e              LDR      r0,|L12.188|
000082  6800              LDR      r0,[r0,#0]
000084  06c0              LSLS     r0,r0,#27
000086  0fc0              LSRS     r0,r0,#31
000088  d1fa              BNE      |L12.128|
;;;199    	//while( I2C1->CON.SI == 0 );
;;;200    	for(i=0;i<60;i++);
00008a  2400              MOVS     r4,#0
00008c  e000              B        |L12.144|
                  |L12.142|
00008e  1c64              ADDS     r4,r4,#1
                  |L12.144|
000090  2c3c              CMP      r4,#0x3c
000092  d3fc              BCC      |L12.142|
;;;201    	DrvI2C_Close(I2C_PORT1);
000094  2001              MOVS     r0,#1
000096  f7fffffe          BL       DrvI2C_Close
;;;202    	for(i=0;i<6000;i++);
00009a  2400              MOVS     r4,#0
00009c  e000              B        |L12.160|
                  |L12.158|
00009e  1c64              ADDS     r4,r4,#1
                  |L12.160|
0000a0  4807              LDR      r0,|L12.192|
0000a2  4284              CMP      r4,r0
0000a4  d3fb              BCC      |L12.158|
;;;203    	for(i=0;i<6000;i++);
0000a6  2400              MOVS     r4,#0
0000a8  e000              B        |L12.172|
                  |L12.170|
0000aa  1c64              ADDS     r4,r4,#1
                  |L12.172|
0000ac  4804              LDR      r0,|L12.192|
0000ae  4284              CMP      r4,r0
0000b0  d3fb              BCC      |L12.170|
;;;204    }
0000b2  bdf8              POP      {r3-r7,pc}
;;;205    
                          ENDP

                  |L12.180|
                          DCD      SystemCoreClock
                  |L12.184|
                          DCD      0x0000c350
                  |L12.188|
                          DCD      0x40120000
                  |L12.192|
                          DCD      0x00001770

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  main PROC
;;;290    }
;;;291    int main (void)
000000  b08e              SUB      sp,sp,#0x38
;;;292    {
;;;293    	uint8_t  i =0;
000002  2400              MOVS     r4,#0
;;;294    
;;;295    	uint8_t  aa[8];
;;;296    	uint8_t  bb[8];
;;;297    	uint8_t  cc[8];
;;;298    	uint8_t  tt[8];
;;;299    	uint8_t  tt1[8];
;;;300    	uint8_t  tt2[8];
;;;301    	STR_UART_T sParam;
;;;302    
;;;303    	uint16_t	read	= 0,read1	= 0;
000004  2600              MOVS     r6,#0
000006  bf00              NOP      
;;;304    	uint16_t	HB	= 0;
000008  bf00              NOP      
;;;305    	uint16_t	LB	= 0;
00000a  bf00              NOP      
;;;306    	uint16_t	VoltageValue		= 0.0;
00000c  2700              MOVS     r7,#0
;;;307    	uint16_t	RunTime				=0.0;
00000e  2000              MOVS     r0,#0
000010  9000              STR      r0,[sp,#0]
;;;308    	uint16_t	Temp				=0.0;
000012  2500              MOVS     r5,#0
;;;309    	uint16_t	VoltageValue1		= 0.0;
000014  bf00              NOP      
;;;310    	int open = 0,open_common = 0,read_common = 0;
000016  bf00              NOP      
000018  bf00              NOP      
00001a  bf00              NOP      
;;;311    	UNLOCKREG();
00001c  2059              MOVS     r0,#0x59
00001e  4962              LDR      r1,|L13.424|
000020  6008              STR      r0,[r1,#0]
000022  2016              MOVS     r0,#0x16
000024  6008              STR      r0,[r1,#0]
000026  2088              MOVS     r0,#0x88
000028  6008              STR      r0,[r1,#0]
;;;312        DrvSYS_Open(48000000);
00002a  4860              LDR      r0,|L13.428|
00002c  f7fffffe          BL       DrvSYS_Open
;;;313        DrvSYS_SetOscCtrl(E_SYS_XTL12M,1);
000030  2101              MOVS     r1,#1
000032  2000              MOVS     r0,#0
000034  f7fffffe          BL       DrvSYS_SetOscCtrl
;;;314        DrvSYS_Delay(20000);/* Delay for Xtal stable */
000038  485d              LDR      r0,|L13.432|
00003a  f7fffffe          BL       DrvSYS_Delay
;;;315        while(!SYSCLK->CLKSTATUS.XTL12M_STB);
00003e  bf00              NOP      
                  |L13.64|
000040  485c              LDR      r0,|L13.436|
000042  68c0              LDR      r0,[r0,#0xc]
000044  07c0              LSLS     r0,r0,#31
000046  0fc0              LSRS     r0,r0,#31
000048  d0fa              BEQ      |L13.64|
;;;316        DrvSYS_SelectHCLKSource(0);
00004a  2000              MOVS     r0,#0
00004c  f7fffffe          BL       DrvSYS_SelectHCLKSource
;;;317    		LOCKREG();
000050  2000              MOVS     r0,#0
000052  4955              LDR      r1,|L13.424|
000054  6008              STR      r0,[r1,#0]
;;;318    			Initial_pannel();
000056  f7fffffe          BL       Initial_pannel
;;;319    	clr_all_pannal();
00005a  f7fffffe          BL       clr_all_pannal
;;;320    	print_lcd(0,"Smpl_UART0 456   ");
00005e  a156              ADR      r1,|L13.440|
000060  2000              MOVS     r0,#0
000062  f7fffffe          BL       print_lcd
;;;321    		DrvGPIO_InitFunction(E_FUNC_I2C1);
000066  2003              MOVS     r0,#3
000068  f7fffffe          BL       DrvGPIO_InitFunction
;;;322    	
;;;323    	
;;;324    	DrvGPIO_InitFunction(E_FUNC_UART0);		
00006c  2029              MOVS     r0,#0x29
00006e  f7fffffe          BL       DrvGPIO_InitFunction
;;;325    
;;;326    	/* UART Setting */
;;;327        sParam.u32BaudRate 		= 9600;
000072  204b              MOVS     r0,#0x4b
000074  01c0              LSLS     r0,r0,#7
000076  9001              STR      r0,[sp,#4]
;;;328        sParam.u8cDataBits 		= DRVUART_DATABITS_8;
000078  2103              MOVS     r1,#3
00007a  4668              MOV      r0,sp
00007c  7201              STRB     r1,[r0,#8]
;;;329        sParam.u8cStopBits 		= DRVUART_STOPBITS_1;
00007e  2100              MOVS     r1,#0
000080  7241              STRB     r1,[r0,#9]
;;;330        sParam.u8cParity 		= DRVUART_PARITY_NONE;
000082  7281              STRB     r1,[r0,#0xa]
;;;331        sParam.u8cRxTriggerLevel= DRVUART_FIFO_1BYTES;
000084  72c1              STRB     r1,[r0,#0xb]
;;;332    
;;;333    	/* Set UART Configuration */
;;;334     	if(DrvUART_Open(UART_PORT0,&sParam) != E_SUCCESS);  
000086  a901              ADD      r1,sp,#4
000088  2000              MOVS     r0,#0
00008a  f7fffffe          BL       DrvUART_Open
;;;335    
;;;336    	DrvUART_EnableInt(UART_PORT0, DRVUART_RDAINT, UART_INT_HANDLE);  
00008e  4a4f              LDR      r2,|L13.460|
000090  2101              MOVS     r1,#1
000092  2000              MOVS     r0,#0
000094  f7fffffe          BL       DrvUART_EnableInt
;;;337    	
;;;338    	while(1)
000098  e085              B        |L13.422|
                  |L13.154|
;;;339    	{
;;;340    			
;;;341    			Initial_pannel();
00009a  f7fffffe          BL       Initial_pannel
;;;342    	        clr_all_pannal();
00009e  f7fffffe          BL       clr_all_pannal
;;;343    		VoltageValue	= 0.0;
0000a2  2700              MOVS     r7,#0
;;;344    		Temp			= 0.0;
0000a4  2500              MOVS     r5,#0
;;;345    		RunTime			= 0.0;
0000a6  2000              MOVS     r0,#0
0000a8  9000              STR      r0,[sp,#0]
;;;346    
;;;347    		 /*...........抓取電量..........*/ 
;;;348    		 read  = Read_BT70791(0x09);
0000aa  2009              MOVS     r0,#9
0000ac  f7fffffe          BL       Read_BT70791
0000b0  4606              MOV      r6,r0
;;;349    		VoltageValue = read;
0000b2  4637              MOV      r7,r6
;;;350    		DrvSYS_Delay(10000);	
0000b4  4846              LDR      r0,|L13.464|
0000b6  f7fffffe          BL       DrvSYS_Delay
;;;351    
;;;352    			print_lcd(0,"VoltageValue=");
0000ba  a146              ADR      r1,|L13.468|
0000bc  2000              MOVS     r0,#0
0000be  f7fffffe          BL       print_lcd
;;;353    		 	sprintf(TEXT2,"%d mV",VoltageValue*2);
0000c2  007a              LSLS     r2,r7,#1
0000c4  a147              ADR      r1,|L13.484|
0000c6  4849              LDR      r0,|L13.492|
0000c8  f7fffffe          BL       __2sprintf
;;;354    			print_lcd(1,TEXT2);
0000cc  4947              LDR      r1,|L13.492|
0000ce  2001              MOVS     r0,#1
0000d0  f7fffffe          BL       print_lcd
;;;355    			//printf("     mV\n");
;;;356    
;;;357    
;;;358    
;;;359    	  bb[i]=DAT1;
0000d4  4846              LDR      r0,|L13.496|
0000d6  7800              LDRB     r0,[r0,#0]  ; DAT1
0000d8  a90a              ADD      r1,sp,#0x28
0000da  5508              STRB     r0,[r1,r4]
;;;360    	  cc[i]=DAT2;	 //公式(DAT2先16轉10)*256+(DAT1在16轉10)
0000dc  4845              LDR      r0,|L13.500|
0000de  7800              LDRB     r0,[r0,#0]  ; DAT2
0000e0  a908              ADD      r1,sp,#0x20
0000e2  5508              STRB     r0,[r1,r4]
;;;361    	 
;;;362    UART_TX(UART_PORT0,bb,1,i);
0000e4  4623              MOV      r3,r4
0000e6  2201              MOVS     r2,#1
0000e8  a90a              ADD      r1,sp,#0x28
0000ea  2000              MOVS     r0,#0
0000ec  f7fffffe          BL       UART_TX
;;;363    UART_TX(UART_PORT0,cc,1,i);	
0000f0  4623              MOV      r3,r4
0000f2  2201              MOVS     r2,#1
0000f4  a908              ADD      r1,sp,#0x20
0000f6  2000              MOVS     r0,#0
0000f8  f7fffffe          BL       UART_TX
;;;364    		DrvSYS_Delay(10000);	
0000fc  4834              LDR      r0,|L13.464|
0000fe  f7fffffe          BL       DrvSYS_Delay
;;;365    
;;;366    	  /*...........抓取溫度..........*/ 
;;;367    	   	
;;;368    	   Temp	= Read_BT70791(0x08);					 //TEMP抓出來是度K,抓出來是0.1度K,公式:度K=度C+273
000102  2008              MOVS     r0,#8
000104  f7fffffe          BL       Read_BT70791
000108  4605              MOV      r5,r0
;;;369    	   	DrvSYS_Delay(10000);
00010a  4831              LDR      r0,|L13.464|
00010c  f7fffffe          BL       DrvSYS_Delay
;;;370    	
;;;371    
;;;372    		Temp=Temp/10;
000110  210a              MOVS     r1,#0xa
000112  4628              MOV      r0,r5
000114  f7fffffe          BL       __aeabi_idivmod
000118  b285              UXTH     r5,r0
;;;373    		Temp=Temp-273;	
00011a  4628              MOV      r0,r5
00011c  38ff              SUBS     r0,r0,#0xff
00011e  3812              SUBS     r0,r0,#0x12
000120  b285              UXTH     r5,r0
;;;374    		sprintf(TEXT2,"TEMP= %dC", Temp);
000122  462a              MOV      r2,r5
000124  a134              ADR      r1,|L13.504|
000126  4831              LDR      r0,|L13.492|
000128  f7fffffe          BL       __2sprintf
;;;375    		print_lcd(2,TEXT2);
00012c  492f              LDR      r1,|L13.492|
00012e  2002              MOVS     r0,#2
000130  f7fffffe          BL       print_lcd
;;;376    	   
;;;377    	   	 DrvSYS_Delay(10000);
000134  4826              LDR      r0,|L13.464|
000136  f7fffffe          BL       DrvSYS_Delay
;;;378    	   	 aa[i]=Temp;										//值接丟TEMP就可
00013a  a90c              ADD      r1,sp,#0x30
00013c  550d              STRB     r5,[r1,r4]
;;;379    UART_TX(UART_PORT0,aa,1,i);
00013e  4623              MOV      r3,r4
000140  2201              MOVS     r2,#1
000142  2000              MOVS     r0,#0
000144  f7fffffe          BL       UART_TX
;;;380    	   /*...........平均時間..........*/ 
;;;381    	   	
;;;382    	   	  RunTime=Read_BT70791(0x11);
000148  2011              MOVS     r0,#0x11
00014a  f7fffffe          BL       Read_BT70791
00014e  9000              STR      r0,[sp,#0]
;;;383    		  DrvSYS_Delay(10000);
000150  481f              LDR      r0,|L13.464|
000152  f7fffffe          BL       DrvSYS_Delay
;;;384    		 	
;;;385    	   	  sprintf(TEXT2,"Time= %d",  RunTime);
000156  a12b              ADR      r1,|L13.516|
000158  4824              LDR      r0,|L13.492|
00015a  9a00              LDR      r2,[sp,#0]
00015c  f7fffffe          BL       __2sprintf
;;;386    		  print_lcd(3,TEXT2);
000160  4922              LDR      r1,|L13.492|
000162  2003              MOVS     r0,#3
000164  f7fffffe          BL       print_lcd
;;;387    		  
;;;388    		  tt1[i]=DAT1;
000168  4821              LDR      r0,|L13.496|
00016a  7800              LDRB     r0,[r0,#0]  ; DAT1
00016c  a906              ADD      r1,sp,#0x18
00016e  5508              STRB     r0,[r1,r4]
;;;389    		  tt2[i]=DAT2;
000170  4820              LDR      r0,|L13.500|
000172  7800              LDRB     r0,[r0,#0]  ; DAT2
000174  a904              ADD      r1,sp,#0x10
000176  5508              STRB     r0,[r1,r4]
;;;390    		  
;;;391    UART_TX(UART_PORT0,tt1,1,i);
000178  4623              MOV      r3,r4
00017a  2201              MOVS     r2,#1
00017c  a906              ADD      r1,sp,#0x18
00017e  2000              MOVS     r0,#0
000180  f7fffffe          BL       UART_TX
;;;392    UART_TX(UART_PORT0,tt2,1,i);
000184  4623              MOV      r3,r4
000186  2201              MOVS     r2,#1
000188  a904              ADD      r1,sp,#0x10
00018a  2000              MOVS     r0,#0
00018c  f7fffffe          BL       UART_TX
;;;393    	  
;;;394    	   	DrvSYS_Delay(10000);	
000190  480f              LDR      r0,|L13.464|
000192  f7fffffe          BL       DrvSYS_Delay
;;;395    
;;;396    	/*	DAT2=to(DAT2);		 //轉換公式
;;;397    		DAT2=DAT2*256;		  //公式(DAT2先16轉10)*256+(DAT1在16轉10)
;;;398    		DAT1=to(DAT1);		 //公式(DAT2先16轉10)*256+(DAT1在16轉10)
;;;399    		DATALL=DAT2+DAT1;	 //公式(DAT2先16轉10)*256+(DAT1在16轉10)  */
;;;400    
;;;401         
;;;402    /*	if(aa[i]>0x3c)						  //記得要用aa[i]去做判斷不能用VoltageValue
;;;403    	{
;;;404         DrvUART_Write(UART_PORT0,"Y",1);
;;;405    	}
;;;406    	else
;;;407    	{
;;;408    	DrvUART_Write(UART_PORT0,"F",1);
;;;409    	}	  */
;;;410    
;;;411    //	UART_TX(UART_PORT0,aa,1,i);
;;;412    //	UART_TX(UART_PORT0,bb,1,i);
;;;413    //	UART_TX(UART_PORT0,cc,1,i);
;;;414    			//UART_TX(UART_PORT0,aa,1,i);//1代表1次傳1個,傳了i次,重aa[0],aa][1]...
;;;415    	//	DrvUART_Write(UART_PORT0,aa,8); //UART傳值  //8代表可以顯示8個 像HELLOW只有6個就會有2格..
;;;416    //	DrvUART_Write(UART_PORT0,"H",1);
;;;417    	    	i=i+1;
000196  1c60              ADDS     r0,r4,#1
000198  b2c4              UXTB     r4,r0
;;;418    		if(i==8){i=0;}
00019a  2c08              CMP      r4,#8
00019c  d100              BNE      |L13.416|
00019e  2400              MOVS     r4,#0
                  |L13.416|
;;;419    	
;;;420    			DrvSYS_Delay(50000); 	
0001a0  481b              LDR      r0,|L13.528|
0001a2  f7fffffe          BL       DrvSYS_Delay
                  |L13.422|
0001a6  e778              B        |L13.154|
;;;421    				
;;;422    	}
;;;423    }
;;;424    
                          ENDP

                  |L13.424|
                          DCD      0x50000100
                  |L13.428|
                          DCD      0x02dc6c00
                  |L13.432|
                          DCD      0x00004e20
                  |L13.436|
                          DCD      0x50000200
                  |L13.440|
0001b8  536d706c          DCB      "Smpl_UART0 456   ",0
0001bc  5f554152
0001c0  54302034
0001c4  35362020
0001c8  2000    
0001ca  00                DCB      0
0001cb  00                DCB      0
                  |L13.460|
                          DCD      UART_INT_HANDLE
                  |L13.464|
                          DCD      0x00002710
                  |L13.468|
0001d4  566f6c74          DCB      "VoltageValue=",0
0001d8  61676556
0001dc  616c7565
0001e0  3d00    
0001e2  00                DCB      0
0001e3  00                DCB      0
                  |L13.484|
0001e4  2564206d          DCB      "%d mV",0
0001e8  5600    
0001ea  00                DCB      0
0001eb  00                DCB      0
                  |L13.492|
                          DCD      TEXT2
                  |L13.496|
                          DCD      DAT1
                  |L13.500|
                          DCD      DAT2
                  |L13.504|
0001f8  54454d50          DCB      "TEMP= %dC",0
0001fc  3d202564
000200  4300    
000202  00                DCB      0
000203  00                DCB      0
                  |L13.516|
000204  54696d65          DCB      "Time= %d",0
000208  3d202564
00020c  00      
00020d  00                DCB      0
00020e  00                DCB      0
00020f  00                DCB      0
                  |L13.528|
                          DCD      0x0000c350

                          AREA ||.data||, DATA, ALIGN=2

                  SMBUS_com
                          DCD      0x00000000
                  send
                          DCD      0x00000001
                  common
000008  00000000          DCB      0x00,0x00,0x00,0x00
                  datain
                          DCD      0x000000ff
                          %        20
                  dataout
                          DCD      0x000000ff
                          %        20
                  comRbuf
00003c  30000000          DCB      0x30,0x00,0x00,0x00
                          %        12
                  comRbytes
00004c  0000              DCW      0x0000
                  comRhead
00004e  0000              DCW      0x0000
                  comRtail
000050  0000              DCW      0x0000
                  TEXT1
000052  5458              DCB      0x54,0x58
000054  3a207365          DCB      0x3a,0x20,0x73,0x65
000058  6e64696e          DCB      0x6e,0x64,0x69,0x6e
00005c  672e2e2e          DCB      0x67,0x2e,0x2e,0x2e
000060  2020              DCB      0x20,0x20
                  TEXT2
000062  5258              DCB      0x52,0x58
000064  3a202020          DCB      0x3a,0x20,0x20,0x20
000068  20202020          DCB      0x20,0x20,0x20,0x20
00006c  20202020          DCB      0x20,0x20,0x20,0x20
000070  20200000          DCB      0x20,0x20,0x00,0x00
                  g_Spi1IntFlag
                          DCD      0x00000000
                  DAT1
000078  00                DCB      0x00
                  DAT2
000079  00                DCB      0x00
                  DATALL
00007a  00                DCB      0x00

                  __ARM_use_no_argv EQU 0
