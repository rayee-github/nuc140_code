L 1 "Smpl_CAN.c"
N// pin32 GPB0/RX0 to another board's UART TX
N// pin33 GPB1/TX0 to another board's UART RX
N// E_FUNC_I2C1,SDA1:GPA-10,SCL1:GPA-11
N//PA10 pin10    PA11 pin9
N//PA7 pin78  ~ PA0 pin71
N#include <stdio.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060019
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 7 "Smpl_CAN.c" 2
N#include <string.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060019
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 8 "Smpl_CAN.c" 2
N#include <math.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\math.h" 1
N/*
N * math.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.5
N * Copyright (C) Codemist Ltd., 1988
N * Copyright 1991-1998,2004-2006,2014 ARM Limited. All rights reserved
N */
N
N/*
N * RCS $Revision$ Codemist 0.03
N * Checkin $Date$
N * Revising $Author: statham $
N */
N
N/*
N * Parts of this file are based upon fdlibm:
N *
N * ====================================================
N * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
N *
N * Developed at SunSoft, a Sun Microsystems, Inc. business.
N * Permission to use, copy, modify, and distribute this
N * software is freely granted, provided that this notice
N * is preserved.
N * ====================================================
N */
N
N#ifndef __math_h
N#define __math_h
N#define __ARMCLIB_VERSION 5060019
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N/*
N * Some of these declarations are new in C99.  To access them in C++
N * you can use -D__USE_C99_MATH (or -D__USE_C99_ALL).
N */
N#ifndef __USE_C99_MATH
N  #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X  #if 0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N    #define __USE_C99_MATH 1
N  #endif
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#ifdef __TARGET_ARCH_AARCH64
S# define _ARMABI_SOFTFP __declspec(__nothrow)
N#else
N# define _ARMABI_SOFTFP __declspec(__nothrow) __attribute__((__pcs__("aapcs")))
N# define __HAVE_LONGDOUBLE 1
N#endif
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#ifdef __FP_FENV_EXCEPTIONS
S# define _ARMABI_FPEXCEPT _ARMABI
N#else
N# define _ARMABI_FPEXCEPT _ARMABI __attribute__((const))
N#endif
N
N#ifdef __cplusplus
S#define _ARMABI_INLINE inline
S#define _ARMABI_INLINE_DEF inline
S#elif defined __GNUC__ || defined _USE_STATIC_INLINE
X#elif 0L || 0L
S#define _ARMABI_INLINE static __inline
S#define _ARMABI_INLINE_DEF static __inline
N#elif (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#elif (1L && 199901L <= 199901L)
N#define _ARMABI_INLINE inline
N#define _ARMABI_INLINE_DEF static inline
N#else
S#define _ARMABI_INLINE __inline
S#define _ARMABI_INLINE_DEF __inline
N#endif
N
N#ifdef __TARGET_ARCH_AARCH64
S#  define _SOFTFP
N#else
N#  define _SOFTFP __attribute__((__pcs__("aapcs")))
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain the nans function, as well as the
N    * FP_NANS and FP_NANQ classification macros.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
N/*
N * Macros for our inline functions down below.
N * unsigned& __FLT(float x) - returns the bit pattern of x
N * unsigned& __HI(double x) - returns the bit pattern of the high part of x
N *                            (high part has exponent & sign bit in it)
N * unsigned& __LO(double x) - returns the bit pattern of the low part of x
N *
N * We can assign to __FLT, __HI, and __LO and the appropriate bits get set in
N * the floating point variable used.
N *
N * __HI & __LO are affected by the endianness and the target FPU.
N */
N#define __FLT(x) (*(unsigned *)&(x))
N#if defined(__ARM_BIG_ENDIAN) || defined(__BIG_ENDIAN)
X#if 0L || 0L
S#  define __LO(x) (*(1 + (unsigned *)&(x)))
S#  define __HI(x) (*(unsigned *)&(x))
N#else /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N#  define __HI(x) (*(1 + (unsigned *)&(x)))
N#  define __LO(x) (*(unsigned *)&(x))
N#endif /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N
N#   ifndef __MATH_DECLS
N#   define __MATH_DECLS
N
N
N/*
N * A set of functions that we don't actually want to put in the standard
N * namespace ever.  These are all called by the C99 macros.  As they're
N * not specified by any standard they can't belong in ::std::.  The
N * macro #defines are below amongst the standard function declarations.
N * We only include these if we actually need them later on
N */
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N#   ifdef __cplusplus
S      extern "C" {
N#   endif /* __cplusplus */
N
Nextern _SOFTFP unsigned __ARM_dcmp4(double /*x*/, double /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_dcmp4(double  , double  );
Nextern _SOFTFP unsigned __ARM_fcmp4(float /*x*/, float /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_fcmp4(float  , float  );
N    /*
N     * Compare x and y and return the CPSR in r0.  These means we can test for
N     * result types with bit pattern matching.
N     *
N     * These are a copy of the declarations in rt_fp.h keep in sync.
N     */
N
Nextern _ARMABI_SOFTFP int __ARM_fpclassifyf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassifyf(float  );
Nextern _ARMABI_SOFTFP int __ARM_fpclassify(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassify(double  );
N    /* Classify x into NaN, infinite, normal, subnormal, zero */
N    /* Used by fpclassify macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinitef(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinitef(float __x)
N{
N    return ((__FLT(__x) >> 23) & 0xff) != 0xff;
X    return (((*(unsigned *)&(__x)) >> 23) & 0xff) != 0xff;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinite(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinite(double __x)
N{
N    return ((__HI(__x) >> 20) & 0x7ff) != 0x7ff;
X    return (((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff) != 0x7ff;
N}
N    /* Return 1 if __x is finite, 0 otherwise */
N    /* Used by isfinite macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinff(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinff(float __x)
N{
N    return (__FLT(__x) << 1) == 0xff000000;
X    return ((*(unsigned *)&(__x)) << 1) == 0xff000000;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinf(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinf(double __x)
N{
N    return ((__HI(__x) << 1) == 0xffe00000) && (__LO(__x) == 0);
X    return (((*(1 + (unsigned *)&(__x))) << 1) == 0xffe00000) && ((*(unsigned *)&(__x)) == 0);
N}
N    /* Return 1 if __x is infinite, 0 otherwise */
N    /* Used by isinf macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreaterf(float __x, float __y)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreaterf(float __x, float __y)
N{
N    unsigned __f = __ARM_fcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreater(double __x, double __y)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreater(double __x, double __y)
N{
N    unsigned __f = __ARM_dcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N    /*
N     * Compare __x and __y and return 1 if __x < __y or __x > __y, 0 otherwise
N     * Used by islessgreater macro
N     */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnanf(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnanf(float __x)
N{
N    return (0x7f800000 - (__FLT(__x) & 0x7fffffff)) >> 31;
X    return (0x7f800000 - ((*(unsigned *)&(__x)) & 0x7fffffff)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnan(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnan(double __x)
N{
N    unsigned __xf = __HI(__x) | ((__LO(__x) == 0) ? 0 : 1);
X    unsigned __xf = (*(1 + (unsigned *)&(__x))) | (((*(unsigned *)&(__x)) == 0) ? 0 : 1);
N    return (0x7ff00000 - (__xf & 0x7fffffff)) >> 31;
N}
N    /* Return 1 if __x is a NaN, 0 otherwise */
N    /* Used by isnan macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormalf(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormalf(float __x)
N{
N    unsigned __xe = (__FLT(__x) >> 23) & 0xff;
X    unsigned __xe = ((*(unsigned *)&(__x)) >> 23) & 0xff;
N    return (__xe != 0xff) && (__xe != 0);
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormal(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormal(double __x)
N{
N    unsigned __xe = (__HI(__x) >> 20) & 0x7ff;
X    unsigned __xe = ((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff;
N    return (__xe != 0x7ff) && (__xe != 0);
N}
N    /* Return 1 if __x is a normalised number, 0 otherwise */
N    /* used by isnormal macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbitf(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbitf(float __x)
N{
N    return __FLT(__x) >> 31;
X    return (*(unsigned *)&(__x)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbit(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbit(double __x)
N{
N    return __HI(__x) >> 31;
X    return (*(1 + (unsigned *)&(__x))) >> 31;
N}
N    /* Return signbit of __x */
N    /* Used by signbit macro */
N
N#   ifdef __cplusplus
S      } /* extern "C" */
N#   endif /* __cplusplus */
N#endif /* Strict ANSI */
N
N#   undef __CLIBNS
N
N#   ifdef __cplusplus
S      namespace std {
S#       define __CLIBNS ::std::
S        extern "C" {
N#   else
N#       define __CLIBNS
N#   endif  /* __cplusplus */
N
N
N#ifndef __has_builtin
N  #define __has_builtin(x) 0
N#endif
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N  /* C99 additions */
N  typedef float float_t;
N  typedef double double_t;
N#if __has_builtin(__builtin_inf)
X#if 0
S#   define HUGE_VALF __builtin_inff()
S#   define HUGE_VALL __builtin_infl()
S#   define INFINITY __builtin_inff()
S#   define NAN __builtin_nanf("")
N# else
N#   define HUGE_VALF ((float)__INFINITY__)
N#   define HUGE_VALL ((long double)__INFINITY__)
N#   define INFINITY ((float)__INFINITY__)
N#   define NAN (__ESCAPE__(0f_7FC00000))
N#endif
N
N#   define MATH_ERRNO 1
N#   define MATH_ERREXCEPT 2
Nextern const int math_errhandling;
N#endif
N#if __has_builtin(__builtin_inf)
X#if 0
S# define HUGE_VAL __builtin_inf()
N#else
N# define HUGE_VAL ((double)__INFINITY__)
N#endif
N
Nextern _ARMABI double acos(double /*x*/);
Xextern __declspec(__nothrow) double acos(double  );
N   /* computes the principal value of the arc cosine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* Returns: the arc cosine in the range 0 to Pi. */
Nextern _ARMABI double asin(double /*x*/);
Xextern __declspec(__nothrow) double asin(double  );
N   /* computes the principal value of the arc sine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* and -HUGE_VAL is returned. */
N   /* Returns: the arc sine in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI_PURE double atan(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double atan(double  );
N   /* computes the principal value of the arc tangent of x */
N   /* Returns: the arc tangent in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI double atan2(double /*y*/, double /*x*/);
Xextern __declspec(__nothrow) double atan2(double  , double  );
N   /* computes the principal value of the arc tangent of y/x, using the */
N   /* signs of both arguments to determine the quadrant of the return value */
N   /* a domain error occurs if both args are zero, and -HUGE_VAL returned. */
N   /* Returns: the arc tangent of y/x, in the range -Pi to Pi. */
N
Nextern _ARMABI double cos(double /*x*/);
Xextern __declspec(__nothrow) double cos(double  );
N   /* computes the cosine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the cosine value. */
Nextern _ARMABI double sin(double /*x*/);
Xextern __declspec(__nothrow) double sin(double  );
N   /* computes the sine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the sine value. */
N
Nextern void __use_accurate_range_reduction(void);
N   /* reference this to select the larger, slower, but more accurate */
N   /* range reduction in sin, cos and tan */
N
Nextern _ARMABI double tan(double /*x*/);
Xextern __declspec(__nothrow) double tan(double  );
N   /* computes the tangent of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance */
N   /* Returns: the tangent value. */
N   /*          if range error; returns HUGE_VAL. */
N
Nextern _ARMABI double cosh(double /*x*/);
Xextern __declspec(__nothrow) double cosh(double  );
N   /* computes the hyperbolic cosine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic cosine value. */
N   /*          if range error; returns HUGE_VAL. */
Nextern _ARMABI double sinh(double /*x*/);
Xextern __declspec(__nothrow) double sinh(double  );
N   /* computes the hyperbolic sine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic sine value. */
N   /*          if range error; returns -HUGE_VAL or HUGE_VAL depending */
N   /*          on the sign of the argument */
N
Nextern _ARMABI_PURE double tanh(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double tanh(double  );
N   /* computes the hyperbolic tangent of x. */
N   /* Returns: the hyperbolic tangent value. */
N
Nextern _ARMABI double exp(double /*x*/);
Xextern __declspec(__nothrow) double exp(double  );
N   /* computes the exponential function of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the exponential value. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
N
Nextern _ARMABI double frexp(double /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double frexp(double  , int *  ) __attribute__((__nonnull__(2)));
N   /* breaks a floating-point number into a normalised fraction and an */
N   /* integral power of 2. It stores the integer in the int object pointed */
N   /* to by exp. */
N   /* Returns: the value x, such that x is a double with magnitude in the */
N   /* interval 0.5 to 1.0 or zero, and value equals x times 2 raised to the */
N   /* power *exp. If value is zero, both parts of the result are zero. */
N
Nextern _ARMABI double ldexp(double /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) double ldexp(double  , int  );
N   /* multiplies a floating-point number by an integral power of 2. */
N   /* A range error may occur. */
N   /* Returns: the value of x times 2 raised to the power of exp. */
N   /*          if range error; HUGE_VAL is returned. */
Nextern _ARMABI double log(double /*x*/);
Xextern __declspec(__nothrow) double log(double  );
N   /* computes the natural logarithm of x. A domain error occurs if the */
N   /* argument is negative, and -HUGE_VAL is returned. A range error occurs */
N   /* if the argument is zero. */
N   /* Returns: the natural logarithm. */
N   /*          if range error; -HUGE_VAL is returned. */
Nextern _ARMABI double log10(double /*x*/);
Xextern __declspec(__nothrow) double log10(double  );
N   /* computes the base-ten logarithm of x. A domain error occurs if the */
N   /* argument is negative. A range error occurs if the argument is zero. */
N   /* Returns: the base-ten logarithm. */
Nextern _ARMABI double modf(double /*value*/, double * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double modf(double  , double *  ) __attribute__((__nonnull__(2)));
N   /* breaks the argument value into integral and fraction parts, each of */
N   /* which has the same sign as the argument. It stores the integral part */
N   /* as a double in the object pointed to by iptr. */
N   /* Returns: the signed fractional part of value. */
N
Nextern _ARMABI double pow(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double pow(double  , double  );
N   /* computes x raised to the power of y. A domain error occurs if x is */
N   /* zero and y is less than or equal to zero, or if x is negative and y */
N   /* is not an integer, and -HUGE_VAL returned. A range error may occur. */
N   /* Returns: the value of x raised to the power of y. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
Nextern _ARMABI double sqrt(double /*x*/);
Xextern __declspec(__nothrow) double sqrt(double  );
N   /* computes the non-negative square root of x. A domain error occurs */
N   /* if the argument is negative, and -HUGE_VAL returned. */
N   /* Returns: the value of the square root. */
N
N#if defined(__TARGET_FPU_VFP_DOUBLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !1L
S    _ARMABI_INLINE double _sqrt(double __x) { return __sqrt(__x); }
N#else
N    _ARMABI_INLINE double _sqrt(double __x) { return sqrt(__x); }
X    inline double _sqrt(double __x) { return sqrt(__x); }
N#endif
N#if defined(__TARGET_FPU_VFP_SINGLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !1L
S    _ARMABI_INLINE float _sqrtf(float __x) { return __sqrtf(__x); }
N#else
N    _ARMABI_INLINE float _sqrtf(float __x) { return (float)sqrt(__x); }
X    inline float _sqrtf(float __x) { return (float)sqrt(__x); }
N#endif
N    /* With VFP, _sqrt and _sqrtf should expand inline as the native VFP square root
N     * instructions. They will not behave like the C sqrt() function, because
N     * they will report unusual values as IEEE exceptions (in fpmodes which
N     * support IEEE exceptions) rather than in errno. These function names
N     * are not specified in any standard. */
N
Nextern _ARMABI_PURE double ceil(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double ceil(double  );
N   /* computes the smallest integer not less than x. */
N   /* Returns: the smallest integer not less than x, expressed as a double. */
Nextern _ARMABI_PURE double fabs(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fabs(double  );
N   /* computes the absolute value of the floating-point number x. */
N   /* Returns: the absolute value of x. */
N
Nextern _ARMABI_PURE double floor(double /*d*/);
Xextern __declspec(__nothrow) __attribute__((const)) double floor(double  );
N   /* computes the largest integer not greater than x. */
N   /* Returns: the largest integer not greater than x, expressed as a double */
N
Nextern _ARMABI double fmod(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fmod(double  , double  );
N   /* computes the floating-point remainder of x/y. */
N   /* Returns: the value x - i * y, for some integer i such that, if y is */
N   /*          nonzero, the result has the same sign as x and magnitude */
N   /*          less than the magnitude of y. If y is zero, a domain error */
N   /*          occurs and -HUGE_VAL is returned. */
N
N    /* Additional Mathlib functions not defined by the ANSI standard.
N     * Not guaranteed, and not necessarily very well tested.
N     * C99 requires the user to include <math.h> to use these functions
N     * declaring them "by hand" is not sufficient
N     *
N     * The above statement is not completely true now.  Some of the above
N     * C99 functionality has been added as per the Standard, and (where
N     * necessary) old Mathlib functionality withdrawn/changed.  Before
N     * including this header #define __ENABLE_MATHLIB_LEGACY if you want to
N     * re-enable the legacy functionality.
N     */
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N
Nextern _ARMABI double acosh(double /*x*/);
Xextern __declspec(__nothrow) double acosh(double  );
N    /*
N     * Inverse cosh. EDOM if argument < 1.0
N     */
Nextern _ARMABI double asinh(double /*x*/);
Xextern __declspec(__nothrow) double asinh(double  );
N    /*
N     * Inverse sinh.
N     */
Nextern _ARMABI double atanh(double /*x*/);
Xextern __declspec(__nothrow) double atanh(double  );
N    /*
N     * Inverse tanh. EDOM if |argument| > 1.0
N     */
Nextern _ARMABI double cbrt(double /*x*/);
Xextern __declspec(__nothrow) double cbrt(double  );
N    /*
N     * Cube root.
N     */
N_ARMABI_INLINE _ARMABI_PURE double copysign(double __x, double __y)
Xinline __declspec(__nothrow) __attribute__((const)) double copysign(double __x, double __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __HI(__x) = (__HI(__x) & 0x7fffffff) | (__HI(__y) & 0x80000000);
X    (*(1 + (unsigned *)&(__x))) = ((*(1 + (unsigned *)&(__x))) & 0x7fffffff) | ((*(1 + (unsigned *)&(__y))) & 0x80000000);
N    return __x;
N}
N_ARMABI_INLINE _ARMABI_PURE float copysignf(float __x, float __y)
Xinline __declspec(__nothrow) __attribute__((const)) float copysignf(float __x, float __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __FLT(__x) = (__FLT(__x) & 0x7fffffff) | (__FLT(__y) & 0x80000000);
X    (*(unsigned *)&(__x)) = ((*(unsigned *)&(__x)) & 0x7fffffff) | ((*(unsigned *)&(__y)) & 0x80000000);
N    return __x;
N}
Nextern _ARMABI double erf(double /*x*/);
Xextern __declspec(__nothrow) double erf(double  );
N    /*
N     * Error function. (2/sqrt(pi)) * integral from 0 to x of exp(-t*t) dt.
N     */
Nextern _ARMABI double erfc(double /*x*/);
Xextern __declspec(__nothrow) double erfc(double  );
N    /*
N     * 1-erf(x). (More accurate than just coding 1-erf(x), for large x.)
N     */
Nextern _ARMABI double expm1(double /*x*/);
Xextern __declspec(__nothrow) double expm1(double  );
N    /*
N     * exp(x)-1. (More accurate than just coding exp(x)-1, for small x.)
N     */
N#define fpclassify(x) \
N    ((sizeof(x) == sizeof(float)) ? \
N        __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
X#define fpclassify(x)     ((sizeof(x) == sizeof(float)) ?         __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
N    /*
N     * Classify a floating point number into one of the following values:
N     */
N#define FP_ZERO         (0)
N#define FP_SUBNORMAL    (4)
N#define FP_NORMAL       (5)
N#define FP_INFINITE     (3)
N#define FP_NAN          (7)
N
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
S/* 
S * Note that we'll never classify a number as FP_NAN, as all NaNs will 
S * be either FP_NANQ or FP_NANS
S */
S#  define FP_NANQ       (8)
S#  define FP_NANS       (9)
N#endif
N
N
Nextern _ARMABI double hypot(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double hypot(double  , double  );
N    /*
N     * sqrt(x*x+y*y), ie the length of the vector (x,y) or the
N     * hypotenuse of a right triangle whose other two sides are x
N     * and y. Won't overflow unless the _answer_ is too big, even
N     * if the intermediate x*x+y*y is too big.
N     */
Nextern _ARMABI int ilogb(double /*x*/);
Xextern __declspec(__nothrow) int ilogb(double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
Nextern _ARMABI int ilogbf(float /*x*/);
Xextern __declspec(__nothrow) int ilogbf(float  );
N    /*
N     * Like ilogb but takes a float
N     */
Nextern _ARMABI int ilogbl(long double /*x*/);
Xextern __declspec(__nothrow) int ilogbl(long double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
N#define FP_ILOGB0   (-0x7fffffff) /* ilogb(0) == -INT_MAX */
N#define FP_ILOGBNAN ( 0x80000000) /* ilogb(NAN) == INT_MIN */
N
N#define isfinite(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isfinitef(x) \
N        : __ARM_isfinite(x))
X#define isfinite(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isfinitef(x)         : __ARM_isfinite(x))
N    /*
N     * Returns true if x is a finite number, size independent.
N     */
N
N#define isgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
X#define isgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
N    /*
N     * Returns true if x > y, throws no exceptions except on Signaling NaNs
N     *
N     * We want the C not set but the Z bit clear, V must be clear
N     */
N
N#define isgreaterequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
X#define isgreaterequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
N    /*
N     * Returns true if x >= y, throws no exceptions except on Signaling NaNs
N     *
N     * We just need to see if the C bit is set or not and ensure V clear
N     */
N
N#define isinf(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isinff(x) \
N        : __ARM_isinf(x))
X#define isinf(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isinff(x)         : __ARM_isinf(x))
N    /*
N     * Returns true if x is an infinity, size independent.
N     */
N
N#define isless(x, y)  \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
X#define isless(x, y)      (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
N    /*
N     * Returns true if x < y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than if N is set, V clear
N     */
N
N#define islessequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0) \
N        : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
X#define islessequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0)         : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
N    /*
N     * Returns true if x <= y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than or equal if one of N or Z is set, V clear
N     */
N
N#define islessgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? __ARM_islessgreaterf((x), (y)) \
N        : __ARM_islessgreater((x), (y)))
X#define islessgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? __ARM_islessgreaterf((x), (y))         : __ARM_islessgreater((x), (y)))
N    /*
N     * Returns true if x <> y, throws no exceptions except on Signaling NaNs
N     * Unfortunately this test is too complicated to do in a macro without
N     * evaluating x & y twice.  Shame really...
N     */
N
N#define isnan(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnanf(x) \
N        : __ARM_isnan(x))
X#define isnan(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnanf(x)         : __ARM_isnan(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isnormal(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnormalf(x) \
N        : __ARM_isnormal(x))
X#define isnormal(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnormalf(x)         : __ARM_isnormal(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isunordered(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
X#define isunordered(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000)         : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
N    /*
N     * Returns true if x ? y, throws no exceptions except on Signaling NaNs
N     * Unordered occurs if and only if the V bit is set
N     */
N
Nextern _ARMABI double lgamma (double /*x*/);
Xextern __declspec(__nothrow) double lgamma (double  );
N    /*
N     * The log of the absolute value of the gamma function of x. The sign
N     * of the gamma function of x is returned in the global `signgam'.
N     */
Nextern _ARMABI double log1p(double /*x*/);
Xextern __declspec(__nothrow) double log1p(double  );
N    /*
N     * log(1+x). (More accurate than just coding log(1+x), for small x.)
N     */
Nextern _ARMABI double logb(double /*x*/);
Xextern __declspec(__nothrow) double logb(double  );
N    /*
N     * Like ilogb but returns a double.
N     */
Nextern _ARMABI float logbf(float /*x*/);
Xextern __declspec(__nothrow) float logbf(float  );
N    /*
N     * Like logb but takes and returns float
N     */
Nextern _ARMABI long double logbl(long double /*x*/);
Xextern __declspec(__nothrow) long double logbl(long double  );
N    /*
N     * Like logb but takes and returns long double
N     */
Nextern _ARMABI double nextafter(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double nextafter(double  , double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nextafterf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float nextafterf(float  , float  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nextafterl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nextafterl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double nexttoward(double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) double nexttoward(double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nexttowardf(float /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) float nexttowardf(float  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nexttowardl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nexttowardl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double remainder(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double remainder(double  , double  );
N    /*
N     * Returns the remainder of x by y, in the IEEE 754 sense.
N     */
Nextern _ARMABI_FPEXCEPT double rint(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double rint(double  );
N    /*
N     * Rounds x to an integer, in the IEEE 754 sense.
N     */
Nextern _ARMABI double scalbln(double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) double scalbln(double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalblnf(float /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) float scalblnf(float  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalblnl(long double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) long double scalblnl(long double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI double scalbn(double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) double scalbn(double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalbnf(float /*x*/, int /*n*/);
Xextern __declspec(__nothrow) float scalbnf(float  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalbnl(long double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) long double scalbnl(long double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
N#define signbit(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_signbitf(x) \
N        : __ARM_signbit(x))
X#define signbit(x)     ((sizeof(x) == sizeof(float))         ? __ARM_signbitf(x)         : __ARM_signbit(x))
N    /*
N     * Returns the signbit of x, size independent macro
N     */
N#endif
N
N/* C99 float versions of functions.  math.h has always reserved these
N   identifiers for this purpose (7.13.4). */
Nextern _ARMABI_PURE float _fabsf(float); /* old ARM name */
Xextern __declspec(__nothrow) __attribute__((const)) float _fabsf(float);  
N_ARMABI_INLINE _ARMABI_PURE float fabsf(float __f) { return _fabsf(__f); }
Xinline __declspec(__nothrow) __attribute__((const)) float fabsf(float __f) { return _fabsf(__f); }
Nextern _ARMABI float sinf(float /*x*/);
Xextern __declspec(__nothrow) float sinf(float  );
Nextern _ARMABI float cosf(float /*x*/);
Xextern __declspec(__nothrow) float cosf(float  );
Nextern _ARMABI float tanf(float /*x*/);
Xextern __declspec(__nothrow) float tanf(float  );
Nextern _ARMABI float acosf(float /*x*/);
Xextern __declspec(__nothrow) float acosf(float  );
Nextern _ARMABI float asinf(float /*x*/);
Xextern __declspec(__nothrow) float asinf(float  );
Nextern _ARMABI float atanf(float /*x*/);
Xextern __declspec(__nothrow) float atanf(float  );
Nextern _ARMABI float atan2f(float /*y*/, float /*x*/);
Xextern __declspec(__nothrow) float atan2f(float  , float  );
Nextern _ARMABI float sinhf(float /*x*/);
Xextern __declspec(__nothrow) float sinhf(float  );
Nextern _ARMABI float coshf(float /*x*/);
Xextern __declspec(__nothrow) float coshf(float  );
Nextern _ARMABI float tanhf(float /*x*/);
Xextern __declspec(__nothrow) float tanhf(float  );
Nextern _ARMABI float expf(float /*x*/);
Xextern __declspec(__nothrow) float expf(float  );
Nextern _ARMABI float logf(float /*x*/);
Xextern __declspec(__nothrow) float logf(float  );
Nextern _ARMABI float log10f(float /*x*/);
Xextern __declspec(__nothrow) float log10f(float  );
Nextern _ARMABI float powf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float powf(float  , float  );
Nextern _ARMABI float sqrtf(float /*x*/);
Xextern __declspec(__nothrow) float sqrtf(float  );
Nextern _ARMABI float ldexpf(float /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) float ldexpf(float  , int  );
Nextern _ARMABI float frexpf(float /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float frexpf(float  , int *  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI_PURE float ceilf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float ceilf(float  );
Nextern _ARMABI_PURE float floorf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float floorf(float  );
Nextern _ARMABI float fmodf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fmodf(float  , float  );
Nextern _ARMABI float modff(float /*value*/, float * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float modff(float  , float *  ) __attribute__((__nonnull__(2)));
N
N/* C99 long double versions of functions. */
N/* (also need to have 'using' declarations below) */
N#define _ARMDEFLD1(f) \
N    _ARMABI long double f##l(long double /*x*/)
X#define _ARMDEFLD1(f)     _ARMABI long double f##l(long double  )
N
N#define _ARMDEFLD1P(f, T) \
N    _ARMABI long double f##l(long double /*x*/, T /*p*/)
X#define _ARMDEFLD1P(f, T)     _ARMABI long double f##l(long double  , T  )
N
N#define _ARMDEFLD2(f) \
N    _ARMABI long double f##l(long double /*x*/, long double /*y*/)
X#define _ARMDEFLD2(f)     _ARMABI long double f##l(long double  , long double  )
N
N/*
N * Long double versions of C89 functions can be defined
N * unconditionally, because C89 reserved these names in "future
N * library directions".
N */
N_ARMDEFLD1(acos);
X__declspec(__nothrow) long double acosl(long double );
N_ARMDEFLD1(asin);
X__declspec(__nothrow) long double asinl(long double );
N_ARMDEFLD1(atan);
X__declspec(__nothrow) long double atanl(long double );
N_ARMDEFLD2(atan2);
X__declspec(__nothrow) long double atan2l(long double , long double );
N_ARMDEFLD1(ceil);
X__declspec(__nothrow) long double ceill(long double );
N_ARMDEFLD1(cos);
X__declspec(__nothrow) long double cosl(long double );
N_ARMDEFLD1(cosh);
X__declspec(__nothrow) long double coshl(long double );
N_ARMDEFLD1(exp);
X__declspec(__nothrow) long double expl(long double );
N_ARMDEFLD1(fabs);
X__declspec(__nothrow) long double fabsl(long double );
N_ARMDEFLD1(floor);
X__declspec(__nothrow) long double floorl(long double );
N_ARMDEFLD2(fmod);
X__declspec(__nothrow) long double fmodl(long double , long double );
N_ARMDEFLD1P(frexp, int*) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double frexpl(long double , int* ) __attribute__((__nonnull__(2)));
N_ARMDEFLD1P(ldexp, int);
X__declspec(__nothrow) long double ldexpl(long double , int );
N_ARMDEFLD1(log);
X__declspec(__nothrow) long double logl(long double );
N_ARMDEFLD1(log10);
X__declspec(__nothrow) long double log10l(long double );
N_ARMABI long double modfl(long double /*x*/, long double * /*p*/) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double modfl(long double  , long double *  ) __attribute__((__nonnull__(2)));
N_ARMDEFLD2(pow);
X__declspec(__nothrow) long double powl(long double , long double );
N_ARMDEFLD1(sin);
X__declspec(__nothrow) long double sinl(long double );
N_ARMDEFLD1(sinh);
X__declspec(__nothrow) long double sinhl(long double );
N_ARMDEFLD1(sqrt);
X__declspec(__nothrow) long double sqrtl(long double );
N_ARMDEFLD1(tan);
X__declspec(__nothrow) long double tanl(long double );
N_ARMDEFLD1(tanh);
X__declspec(__nothrow) long double tanhl(long double );
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N
N/*
N * C99 float and long double versions of extra-C89 functions.
N */
Nextern _ARMABI float acoshf(float /*x*/);
Xextern __declspec(__nothrow) float acoshf(float  );
N_ARMDEFLD1(acosh);
X__declspec(__nothrow) long double acoshl(long double );
Nextern _ARMABI float asinhf(float /*x*/);
Xextern __declspec(__nothrow) float asinhf(float  );
N_ARMDEFLD1(asinh);
X__declspec(__nothrow) long double asinhl(long double );
Nextern _ARMABI float atanhf(float /*x*/);
Xextern __declspec(__nothrow) float atanhf(float  );
N_ARMDEFLD1(atanh);
X__declspec(__nothrow) long double atanhl(long double );
N_ARMDEFLD2(copysign);
X__declspec(__nothrow) long double copysignl(long double , long double );
Nextern _ARMABI float cbrtf(float /*x*/);
Xextern __declspec(__nothrow) float cbrtf(float  );
N_ARMDEFLD1(cbrt);
X__declspec(__nothrow) long double cbrtl(long double );
Nextern _ARMABI float erff(float /*x*/);
Xextern __declspec(__nothrow) float erff(float  );
N_ARMDEFLD1(erf);
X__declspec(__nothrow) long double erfl(long double );
Nextern _ARMABI float erfcf(float /*x*/);
Xextern __declspec(__nothrow) float erfcf(float  );
N_ARMDEFLD1(erfc);
X__declspec(__nothrow) long double erfcl(long double );
Nextern _ARMABI float expm1f(float /*x*/);
Xextern __declspec(__nothrow) float expm1f(float  );
N_ARMDEFLD1(expm1);
X__declspec(__nothrow) long double expm1l(long double );
Nextern _ARMABI float log1pf(float /*x*/);
Xextern __declspec(__nothrow) float log1pf(float  );
N_ARMDEFLD1(log1p);
X__declspec(__nothrow) long double log1pl(long double );
Nextern _ARMABI float hypotf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float hypotf(float  , float  );
N_ARMDEFLD2(hypot);
X__declspec(__nothrow) long double hypotl(long double , long double );
Nextern _ARMABI float lgammaf(float /*x*/);
Xextern __declspec(__nothrow) float lgammaf(float  );
N_ARMDEFLD1(lgamma);
X__declspec(__nothrow) long double lgammal(long double );
Nextern _ARMABI float remainderf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float remainderf(float  , float  );
N_ARMDEFLD2(remainder);
X__declspec(__nothrow) long double remainderl(long double , long double );
Nextern _ARMABI float rintf(float /*x*/);
Xextern __declspec(__nothrow) float rintf(float  );
N_ARMDEFLD1(rint);
X__declspec(__nothrow) long double rintl(long double );
N
N#endif
N
N#if (defined(__clang__) && !defined(__STRICT_ANSI)) || defined(__USE_C99_MATH)
X#if (0L && !0L) || 1L
N/*
N * Functions new in C99.
N */
Nextern _ARMABI double exp2(double /*x*/); /* * 2.^x. */
Xextern __declspec(__nothrow) double exp2(double  );  
Nextern _ARMABI float exp2f(float /*x*/);
Xextern __declspec(__nothrow) float exp2f(float  );
N_ARMDEFLD1(exp2);
X__declspec(__nothrow) long double exp2l(long double );
Nextern _ARMABI double fdim(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fdim(double  , double  );
Nextern _ARMABI float fdimf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fdimf(float  , float  );
N_ARMDEFLD2(fdim);
X__declspec(__nothrow) long double fdiml(long double , long double );
N#ifdef __FP_FAST_FMA
S#define FP_FAST_FMA
N#endif
N#ifdef __FP_FAST_FMAF
S#define FP_FAST_FMAF
N#endif
N#ifdef __FP_FAST_FMAL
S#define FP_FAST_FMAL
N#endif
Nextern _ARMABI double fma(double /*x*/, double /*y*/, double /*z*/);
Xextern __declspec(__nothrow) double fma(double  , double  , double  );
Nextern _ARMABI float fmaf(float /*x*/, float /*y*/, float /*z*/);
Xextern __declspec(__nothrow) float fmaf(float  , float  , float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z) \
N    { return (long double)fma((double)__x, (double)__y, (double)__z); }
Xinline __declspec(__nothrow) long double fmal(long double __x, long double __y, long double __z)     { return (long double)fma((double)__x, (double)__y, (double)__z); }
N#endif
Nextern _ARMABI_FPEXCEPT double fmax(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fmax(double  , double  );
Nextern _ARMABI_FPEXCEPT float fmaxf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) float fmaxf(float  , float  );
N_ARMDEFLD2(fmax);
X__declspec(__nothrow) long double fmaxl(long double , long double );
Nextern _ARMABI_FPEXCEPT double fmin(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fmin(double  , double  );
Nextern _ARMABI_FPEXCEPT float fminf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) float fminf(float  , float  );
N_ARMDEFLD2(fmin);
X__declspec(__nothrow) long double fminl(long double , long double );
Nextern _ARMABI double log2(double /*x*/); /* * log base 2 of x. */
Xextern __declspec(__nothrow) double log2(double  );  
Nextern _ARMABI float log2f(float /*x*/);
Xextern __declspec(__nothrow) float log2f(float  );
N_ARMDEFLD1(log2);
X__declspec(__nothrow) long double log2l(long double );
Nextern _ARMABI long lrint(double /*x*/);
Xextern __declspec(__nothrow) long lrint(double  );
Nextern _ARMABI long lrintf(float /*x*/);
Xextern __declspec(__nothrow) long lrintf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI long lrintl(long double __x) \
N    { return lrint((double)__x); }
Xinline __declspec(__nothrow) long lrintl(long double __x)     { return lrint((double)__x); }
N#endif
Nextern _ARMABI __LONGLONG llrint(double /*x*/);
Xextern __declspec(__nothrow) long long llrint(double  );
Nextern _ARMABI __LONGLONG llrintf(float /*x*/);
Xextern __declspec(__nothrow) long long llrintf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI __LONGLONG llrintl(long double __x) \
N    { return llrint((double)__x); }
Xinline __declspec(__nothrow) long long llrintl(long double __x)     { return llrint((double)__x); }
N#endif
Nextern _ARMABI long lround(double /*x*/);
Xextern __declspec(__nothrow) long lround(double  );
Nextern _ARMABI long lroundf(float /*x*/);
Xextern __declspec(__nothrow) long lroundf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI long lroundl(long double __x) \
N    { return lround((double)__x); }
Xinline __declspec(__nothrow) long lroundl(long double __x)     { return lround((double)__x); }
N#endif
Nextern _ARMABI __LONGLONG llround(double /*x*/);
Xextern __declspec(__nothrow) long long llround(double  );
Nextern _ARMABI __LONGLONG llroundf(float /*x*/);
Xextern __declspec(__nothrow) long long llroundf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI __LONGLONG llroundl(long double __x) \
N    { return llround((double)__x); }
Xinline __declspec(__nothrow) long long llroundl(long double __x)     { return llround((double)__x); }
N#endif
Nextern _ARMABI_PURE double nan(const char */*tagp*/);
Xextern __declspec(__nothrow) __attribute__((const)) double nan(const char * );
Nextern _ARMABI_PURE float nanf(const char */*tagp*/);
Xextern __declspec(__nothrow) __attribute__((const)) float nanf(const char * );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t) \
N    { return (long double)nan(__t); }
Xinline __declspec(__nothrow) __attribute__((const)) long double nanl(const char *__t)     { return (long double)nan(__t); }
N#endif
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
Sextern _ARMABI_PURE double nans(const char */*tagp*/);
Sextern _ARMABI_PURE float nansf(const char */*tagp*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t) \
S    { return (long double)nans(__t); }
X_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t)     { return (long double)nans(__t); }
S#endif
N#endif 
Nextern _ARMABI_FPEXCEPT double nearbyint(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double nearbyint(double  );
Nextern _ARMABI_FPEXCEPT float nearbyintf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float nearbyintf(float  );
N_ARMDEFLD1(nearbyint);
X__declspec(__nothrow) long double nearbyintl(long double );
Nextern  double remquo(double /*x*/, double /*y*/, int */*quo*/);
Nextern  float remquof(float /*x*/, float /*y*/, int */*quo*/);
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q) \
N    { return (long double)remquo((double)__x, (double)__y, __q); }
Xinline long double remquol(long double __x, long double __y, int *__q)     { return (long double)remquo((double)__x, (double)__y, __q); }
N#endif
Nextern _ARMABI_FPEXCEPT double round(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double round(double  );
Nextern _ARMABI_FPEXCEPT float roundf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float roundf(float  );
N_ARMDEFLD1(round);
X__declspec(__nothrow) long double roundl(long double );
Nextern _ARMABI double tgamma(double /*x*/); /* * The gamma function of x. */
Xextern __declspec(__nothrow) double tgamma(double  );  
Nextern _ARMABI float tgammaf(float /*x*/);
Xextern __declspec(__nothrow) float tgammaf(float  );
N_ARMDEFLD1(tgamma);
X__declspec(__nothrow) long double tgammal(long double );
Nextern _ARMABI_FPEXCEPT double trunc(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double trunc(double  );
Nextern _ARMABI_FPEXCEPT float truncf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float truncf(float  );
N_ARMDEFLD1(trunc);
X__declspec(__nothrow) long double truncl(long double );
N#endif
N
N#undef _ARMDEFLD1
N#undef _ARMDEFLD1P
N#undef _ARMDEFLD2
N
N#if defined(__cplusplus) && ((!defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)) || defined(__ARMCOMPILER_LIBCXX))
X#if 0L && ((!0L || 1L) || 0L)
S  extern "C++" {
S    inline int (fpclassify)(double __x) { return fpclassify(__x); }
S    inline bool (isfinite)(double __x) { return isfinite(__x); }
S    inline bool (isgreater)(double __x, double __y) { return isgreater(__x, __y); }
S    inline bool (isgreaterequal)(double __x, double __y) { return isgreaterequal(__x, __y); }
S    inline bool (isinf)(double __x) { return isinf(__x); }
S    inline bool (isless)(double __x, double __y) { return isless(__x, __y); }
S    inline bool (islessequal)(double __x, double __y) { return islessequal(__x, __y); }
S    inline bool (islessgreater)(double __x, double __y) { return islessgreater(__x, __y); }
S    inline bool (isnan)(double __x) { return isnan(__x); }
S    inline bool (isnormal)(double __x) { return isnormal(__x); }
S    inline bool (isunordered)(double __x, double __y) { return isunordered(__x, __y); }
S
S  }
N#endif
N
N#if defined(__cplusplus) && !defined(__ARMCOMPILER_LIBCXX)
X#if 0L && !0L
S  extern "C++" {
S    inline float abs(float __x)   { return fabsf(__x); }
S    inline float acos(float __x)  { return acosf(__x); }
S    inline float asin(float __x)  { return asinf(__x); }
S    inline float atan(float __x)  { return atanf(__x); }
S    inline float atan2(float __y, float __x)    { return atan2f(__y,__x); }
S    inline float ceil(float __x)  { return ceilf(__x); }
S    inline float cos(float __x)   { return cosf(__x); }
S    inline float cosh(float __x)  { return coshf(__x); }
S    inline float exp(float __x)   { return expf(__x); }
S    inline float fabs(float __x)  { return fabsf(__x); }
S    inline float floor(float __x) { return floorf(__x); }
S    inline float fmod(float __x, float __y)     { return fmodf(__x, __y); }
S    float frexp(float __x, int* __exp) __attribute__((__nonnull__(2)));
S    inline float frexp(float __x, int* __exp)   { return frexpf(__x, __exp); }
S    inline float ldexp(float __x, int __exp)    { return ldexpf(__x, __exp);}
S    inline float log(float __x)   { return logf(__x); }
S    inline float log10(float __x) { return log10f(__x); }
S    float modf(float __x, float* __iptr) __attribute__((__nonnull__(2)));
S    inline float modf(float __x, float* __iptr) { return modff(__x, __iptr); }
S    inline float pow(float __x, float __y)      { return powf(__x,__y); }
S    inline float pow(float __x, int __y)     { return powf(__x, (float)__y); }
S    inline float sin(float __x)   { return sinf(__x); }
S    inline float sinh(float __x)  { return sinhf(__x); }
S    inline float sqrt(float __x)  { return sqrtf(__x); }
S    inline float _sqrt(float __x) { return _sqrtf(__x); }
S    inline float tan(float __x)   { return tanf(__x); }
S    inline float tanh(float __x)  { return tanhf(__x); }
S
S    inline double abs(double __x) { return fabs(__x); }
S    inline double pow(double __x, int __y)
S                { return pow(__x, (double) __y); }
S
S#ifdef __HAVE_LONGDOUBLE
S    inline long double abs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double acos(long double __x)
S                { return (long double)acosl(__x); }
S    inline long double asin(long double __x)
S                { return (long double)asinl(__x); }
S    inline long double atan(long double __x)
S                { return (long double)atanl(__x); }
S    inline long double atan2(long double __y, long double __x)
S                { return (long double)atan2l(__y, __x); }
S    inline long double ceil(long double __x)
S                { return (long double)ceill( __x); }
S    inline long double cos(long double __x)
S                { return (long double)cosl(__x); }
S    inline long double cosh(long double __x)
S                { return (long double)coshl(__x); }
S    inline long double exp(long double __x)
S                { return (long double)expl(__x); }
S    inline long double fabs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double floor(long double __x)
S                { return (long double)floorl(__x); }
S    inline long double fmod(long double __x, long double __y)
S                { return (long double)fmodl(__x, __y); }
S    long double frexp(long double __x, int* __p) __attribute__((__nonnull__(2)));
S    inline long double frexp(long double __x, int* __p)
S                { return (long double)frexpl(__x, __p); }
S    inline long double ldexp(long double __x, int __exp)
S                { return (long double)ldexpl(__x, __exp); }
S    inline long double log(long double __x)
S                { return (long double)logl(__x); }
S    inline long double log10(long double __x)
S                { return (long double)log10l(__x); }
S    long double modf(long double __x, long double* __p) __attribute__((__nonnull__(2)));
S    inline long double modf(long double __x, long double* __p)
S                { return (long double)modfl(__x, __p); }
S    inline long double pow(long double __x, long double __y)
S                { return (long double)powl(__x, __y); }
S    inline long double pow(long double __x, int __y)
S                { return (long double)powl(__x, __y); }
S    inline long double sin(long double __x)
S                { return (long double)sinl(__x); }
S    inline long double sinh(long double __x)
S                { return (long double)sinhl(__x); }
S    inline long double sqrt(long double __x)
S                { return (long double)sqrtl(__x); }
S    inline long double _sqrt(long double __x)
S                { return (long double)_sqrt((double) __x); }
S    inline long double tan(long double __x)
S                { return (long double)tanl(__x); }
S    inline long double tanh(long double __x)
S                { return (long double)tanhl(__x); }
S#endif
S
S#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S    inline float acosh(float __x) { return acoshf(__x); }
S    inline float asinh(float __x) { return asinhf(__x); }
S    inline float atanh(float __x) { return atanhf(__x); }
S    inline float cbrt(float __x) { return cbrtf(__x); }
S    inline float erf(float __x) { return erff(__x); }
S    inline float erfc(float __x) { return erfcf(__x); }
S    inline float expm1(float __x) { return expm1f(__x); }
S    inline float log1p(float __x) { return log1pf(__x); }
S    inline float hypot(float __x, float __y) { return hypotf(__x, __y); }
S    inline float lgamma(float __x) { return lgammaf(__x); }
S    inline float remainder(float __x, float __y) { return remainderf(__x, __y); }
S    inline float rint(float __x) { return rintf(__x); }
S#endif
S
S#ifdef __USE_C99_MATH
S    inline float exp2(float __x) { return exp2f(__x); }
S    inline float fdim(float __x, float __y) { return fdimf(__x, __y); }
S    inline float fma(float __x, float __y, float __z) { return fmaf(__x, __y, __z); }
S    inline float fmax(float __x, float __y) { return fmaxf(__x, __y); }
S    inline float fmin(float __x, float __y) { return fminf(__x, __y); }
S    inline float log2(float __x) { return log2f(__x); }
S    inline _ARMABI long lrint(float __x) { return lrintf(__x); }
S    inline _ARMABI __LONGLONG llrint(float __x) { return llrintf(__x); }
S    inline _ARMABI long lround(float __x) { return lroundf(__x); }
S    inline _ARMABI __LONGLONG llround(float __x) { return llroundf(__x); }
S    inline _ARMABI_FPEXCEPT float nearbyint(float __x) { return nearbyintf(__x); }
S    inline float remquo(float __x, float __y, int *__q) { return remquof(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT float round(float __x) { return roundf(__x); }
S    inline float tgamma(float __x) { return tgammaf(__x); }
S    inline _ARMABI_FPEXCEPT float trunc(float __x) { return truncf(__x); }
S
S    inline int (fpclassify)(float __x) { return fpclassify(__x); }
S    inline bool (isfinite)(float __x) { return isfinite(__x); }
S    inline bool (isgreater)(float __x, float __y) { return isgreater(__x, __y); }
S    inline bool (isgreaterequal)(float __x, float __y) { return isgreaterequal(__x, __y); }
S    inline bool (isinf)(float __x) { return isinf(__x); }
S    inline bool (isless)(float __x, float __y) { return isless(__x, __y); }
S    inline bool (islessequal)(float __x, float __y) { return islessequal(__x, __y); }
S    inline bool (islessgreater)(float __x, float __y) { return islessgreater(__x, __y); }
S    inline bool (isnan)(float __x) { return isnan(__x); }
S    inline bool (isnormal)(float __x) { return isnormal(__x); }
S    inline bool (isunordered)(float __x, float __y) { return isunordered(__x, __y); }
S
S#ifdef __HAVE_LONGDOUBLE
S    inline long double acosh(long double __x) { return acoshl(__x); }
S    inline long double asinh(long double __x) { return asinhl(__x); }
S    inline long double atanh(long double __x) { return atanhl(__x); }
S    inline long double cbrt(long double __x) { return cbrtl(__x); }
S    inline long double erf(long double __x) { return erfl(__x); }
S    inline long double erfc(long double __x) { return erfcl(__x); }
S    inline long double expm1(long double __x) { return expm1l(__x); }
S    inline long double log1p(long double __x) { return log1pl(__x); }
S    inline long double hypot(long double __x, long double __y) { return hypotl(__x, __y); }
S    inline long double lgamma(long double __x) { return lgammal(__x); }
S    inline long double remainder(long double __x, long double __y) { return remainderl(__x, __y); }
S    inline long double rint(long double __x) { return rintl(__x); }
S    inline long double exp2(long double __x) { return exp2l(__x); }
S    inline long double fdim(long double __x, long double __y) { return fdiml(__x, __y); }
S    inline long double fma(long double __x, long double __y, long double __z) { return fmal(__x, __y, __z); }
S    inline long double fmax(long double __x, long double __y) { return fmaxl(__x, __y); }
S    inline long double fmin(long double __x, long double __y) { return fminl(__x, __y); }
S    inline long double log2(long double __x) { return log2l(__x); }
S    inline _ARMABI long lrint(long double __x) { return lrintl(__x); }
S    inline _ARMABI __LONGLONG llrint(long double __x) { return llrintl(__x); }
S    inline _ARMABI long lround(long double __x) { return lroundl(__x); }
S    inline _ARMABI __LONGLONG llround(long double __x) { return llroundl(__x); }
S    inline _ARMABI_FPEXCEPT long double nearbyint(long double __x) { return nearbyintl(__x); }
S    inline long double remquo(long double __x, long double __y, int *__q) { return remquol(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT long double round(long double __x) { return roundl(__x); }
S    inline long double tgamma(long double __x) { return tgammal(__x); }
S    inline _ARMABI_FPEXCEPT long double trunc(long double __x) { return truncl(__x); }
S    inline int (fpclassify)(long double __x) { return fpclassify(__x); }
S    inline bool (isfinite)(long double __x) { return isfinite(__x); }
S    inline bool (isgreater)(long double __x, long double __y) { return isgreater(__x, __y); }
S    inline bool (isgreaterequal)(long double __x, long double __y) { return isgreaterequal(__x, __y); }
S    inline bool (isinf)(long double __x) { return isinf(__x); }
S    inline bool (isless)(long double __x, long double __y) { return isless(__x, __y); }
S    inline bool (islessequal)(long double __x, long double __y) { return islessequal(__x, __y); }
S    inline bool (islessgreater)(long double __x, long double __y) { return islessgreater(__x, __y); }
S    inline bool (isnan)(long double __x) { return isnan(__x); }
S    inline bool (isnormal)(long double __x) { return isnormal(__x); }
S    inline bool (isunordered)(long double __x, long double __y) { return isunordered(__x, __y); }
S#endif
S
S#undef fpclassify
S#undef isfinite
S#undef isgreater
S#undef isgreaterequal
S#undef isinf
S#undef isless
S#undef islessequal
S#undef islessgreater
S#undef isnan
S#undef isnormal
S#undef isunordered
S
S#endif
S
S  }
N#endif
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __MATH_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__MATH_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::__use_accurate_range_reduction;
S    #ifndef __ARMCOMPILER_LIBCXX
S      using ::std::abs;
S    #endif
S    using ::std::acos;
S    using ::std::asin;
S    using ::std::atan2;
S    using ::std::atan;
S    using ::std::ceil;
S    using ::std::cos;
S    using ::std::cosh;
S    using ::std::exp;
S    using ::std::fabs;
S    using ::std::floor;
S    using ::std::fmod;
S    using ::std::frexp;
S    using ::std::ldexp;
S    using ::std::log10;
S    using ::std::log;
S    using ::std::modf;
S    using ::std::pow;
S    using ::std::sin;
S    using ::std::sinh;
S    using ::std::sqrt;
S    using ::std::_sqrt;
S    using ::std::_sqrtf;
S    using ::std::tan;
S    using ::std::tanh;
S    using ::std::_fabsf;
S    /* C99 float and long double versions in already-C89-reserved namespace */
S    using ::std::acosf;
S    using ::std::acosl;
S    using ::std::asinf;
S    using ::std::asinl;
S    using ::std::atan2f;
S    using ::std::atan2l;
S    using ::std::atanf;
S    using ::std::atanl;
S    using ::std::ceilf;
S    using ::std::ceill;
S    using ::std::cosf;
S    using ::std::coshf;
S    using ::std::coshl;
S    using ::std::cosl;
S    using ::std::expf;
S    using ::std::expl;
S    using ::std::fabsf;
S    using ::std::fabsl;
S    using ::std::floorf;
S    using ::std::floorl;
S    using ::std::fmodf;
S    using ::std::fmodl;
S    using ::std::frexpf;
S    using ::std::frexpl;
S    using ::std::ldexpf;
S    using ::std::ldexpl;
S    using ::std::log10f;
S    using ::std::log10l;
S    using ::std::logf;
S    using ::std::logl;
S    using ::std::modff;
S    using ::std::modfl;
S    using ::std::powf;
S    using ::std::powl;
S    using ::std::sinf;
S    using ::std::sinhf;
S    using ::std::sinhl;
S    using ::std::sinl;
S    using ::std::sqrtf;
S    using ::std::sqrtl;
S    using ::std::tanf;
S    using ::std::tanhf;
S    using ::std::tanhl;
S    using ::std::tanl;
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      /* C99 additions which for historical reasons appear in non-strict mode */
S      using ::std::acosh;
S      using ::std::asinh;
S      using ::std::atanh;
S      using ::std::cbrt;
S      using ::std::copysign;
S      using ::std::copysignf;
S      using ::std::erf;
S      using ::std::erfc;
S      using ::std::expm1;
S      using ::std::hypot;
S      using ::std::ilogb;
S      using ::std::ilogbf;
S      using ::std::ilogbl;
S      using ::std::lgamma;
S      using ::std::log1p;
S      using ::std::logb;
S      using ::std::logbf;
S      using ::std::logbl;
S      using ::std::nextafter;
S      using ::std::nextafterf;
S      using ::std::nextafterl;
S      using ::std::nexttoward;
S      using ::std::nexttowardf;
S      using ::std::nexttowardl;
S      using ::std::remainder;
S      using ::std::rint;
S      using ::std::scalbln;
S      using ::std::scalblnf;
S      using ::std::scalblnl;
S      using ::std::scalbn;
S      using ::std::scalbnf;
S      using ::std::scalbnl;
S      using ::std::math_errhandling;
S      using ::std::acoshf;
S      using ::std::acoshl;
S      using ::std::asinhf;
S      using ::std::asinhl;
S      using ::std::atanhf;
S      using ::std::atanhl;
S      using ::std::copysignl;
S      using ::std::cbrtf;
S      using ::std::cbrtl;
S      using ::std::erff;
S      using ::std::erfl;
S      using ::std::erfcf;
S      using ::std::erfcl;
S      using ::std::expm1f;
S      using ::std::expm1l;
S      using ::std::log1pf;
S      using ::std::log1pl;
S      using ::std::hypotf;
S      using ::std::hypotl;
S      using ::std::lgammaf;
S      using ::std::lgammal;
S      using ::std::remainderf;
S      using ::std::remainderl;
S      using ::std::rintf;
S      using ::std::rintl;
S      /* New in C99. */
S      using ::std::float_t;
S      using ::std::double_t;
S    #endif
S    #if (defined(__clang__) && !defined(__STRICT_ANSI)) || defined(__USE_C99_MATH)
S      /* Functions new in C99. */
S      using ::std::exp2;
S      using ::std::exp2f;
S      using ::std::exp2l;
S      using ::std::fdim;
S      using ::std::fdimf;
S      using ::std::fdiml;
S      using ::std::fma;
S      using ::std::fmaf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::fmal;
S#endif
S      using ::std::fmax;
S      using ::std::fmaxf;
S      using ::std::fmaxl;
S      using ::std::fmin;
S      using ::std::fminf;
S      using ::std::fminl;
S      using ::std::log2;
S      using ::std::log2f;
S      using ::std::log2l;
S      using ::std::lrint;
S      using ::std::lrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lrintl;
S#endif
S      using ::std::llrint;
S      using ::std::llrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llrintl;
S#endif
S      using ::std::lround;
S      using ::std::lroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lroundl;
S#endif
S      using ::std::llround;
S      using ::std::llroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llroundl;
S#endif
S      using ::std::nan;
S      using ::std::nanf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::nanl;
S#endif
S      using ::std::nearbyint;
S      using ::std::nearbyintf;
S      using ::std::nearbyintl;
S      using ::std::remquo;
S      using ::std::remquof;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::remquol;
S#endif
S      using ::std::round;
S      using ::std::roundf;
S      using ::std::roundl;
S      using ::std::tgamma;
S      using ::std::tgammaf;
S      using ::std::tgammal;
S      using ::std::trunc;
S      using ::std::truncf;
S      using ::std::truncl;
S    #endif
S
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      using ::std::fpclassify;
S      using ::std::isfinite;
S      using ::std::isgreater;
S      using ::std::isgreaterequal;
S      using ::std::isinf;
S      using ::std::isless;
S      using ::std::islessequal;
S      using ::std::islessgreater;
S      using ::std::isnan;
S      using ::std::isnormal;
S      using ::std::isunordered;
S    #endif
N  #endif
N
N#undef __LONGLONG
N
N#endif /* __math_h */
N
N/* end of math.h */
L 9 "Smpl_CAN.c" 2
N#include <stdlib.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060019
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 10 "Smpl_CAN.c" 2
N#include "NUC1xx.h"
L 1 "..\..\..\..\CMSIS\CM0\DeviceSupport\Nuvoton\NUC1xx\NUC1xx.h" 1
N/*---------------------------------------------------------------------------------------------------------*/
N/*                                                                                                         */
N/* Copyright (c) Nuvoton Technology Corp. All rights reserved.                                             */
N/*                                                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#ifndef __NUC1xx_H__
N#define __NUC1xx_H__
N						
N              
N/*
N * ==========================================================================
N * ---------- Interrupt Number Definition -----------------------------------
N * ==========================================================================
N*/
N 
Ntypedef enum IRQn
N{
N/******  Cortex-M0 Processor Exceptions Numbers ***************************************************/
N  NonMaskableInt_IRQn         = -14,    /*!< 2 Non Maskable Interrupt                             */
N  HardFault_IRQn              = -13,    /*!< 3 Cortex-M0 Hard Fault Interrupt                     */
N  SVCall_IRQn                 = -5,     /*!< 11 Cortex-M0 SV Call Interrupt                       */
N  PendSV_IRQn                 = -2,     /*!< 14 Cortex-M0 Pend SV Interrupt                       */
N  SysTick_IRQn                = -1,     /*!< 15 Cortex-M0 System Tick Interrupt                   */
N
N/************************ NUC1xx Interrupt Numbers ************************************************/
N  BOD_IRQn                  = 0,
N  WDT_IRQn                  = 1,
N  EINT0_IRQn                = 2,
N  EINT1_IRQn                = 3,
N  GPAB_IRQn                 = 4,
N  GPCDE_IRQn                = 5,
N  PWMA_IRQn                 = 6,
N  PWMB_IRQn                 = 7,
N  TMR0_IRQn                 = 8,
N  TMR1_IRQn                 = 9,
N  TMR2_IRQn                 = 10,
N  TMR3_IRQn                 = 11,
N  UART0_IRQn                = 12,
N  UART1_IRQn                = 13,
N  SPI0_IRQn                 = 14,
N  SPI1_IRQn                 = 15,
N  SPI2_IRQn                 = 16,
N  SPI3_IRQn                 = 17,
N  I2C0_IRQn                 = 18,
N  I2C1_IRQn                 = 19,
N  CAN0_IRQn                 = 20,
N  CAN1_IRQn                 = 21,
N  SD_IRQn                   = 22,
N  USBD_IRQn                 = 23,
N  PS2_IRQn                  = 24,
N  ACMP_IRQn                 = 25,
N  PDMA_IRQn                 = 26,
N  I2S_IRQn                  = 27,
N  PWRWU_IRQn                = 28,
N  ADC_IRQn                  = 29,
N  DAC_IRQn                  = 30,
N  RTC_IRQn                  = 31
N} IRQn_Type;
N
N
N/*
N * ==========================================================================
N * ----------- Processor and Core Peripheral Section ------------------------
N * ==========================================================================
N */
N
N/* Configuration of the Cortex-M0 Processor and Core Peripherals */
N#define __MPU_PRESENT           0       /*!< armikcmu does not provide a MPU present or not       */
N#define __NVIC_PRIO_BITS        2       /*!< armikcmu Supports 2 Bits for the Priority Levels     */
N#define __Vendor_SysTickConfig  0       /*!< Set to 1 if different SysTick Config is used         */
N
N
N#include "core_cm0.h"                   /* Cortex-M0 processor and core peripherals               */
L 1 "..\..\..\..\CMSIS\CM0\CoreSupport\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V1.30
N * @date     30. October 2009
N *
N * @note
N * Copyright (C) 2009 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CM0_CORE_H__
N#define __CM0_CORE_H__
N
N/** @addtogroup CMSIS_CM0_core_LintCinfiguration CMSIS CM0 Core Lint Configuration
N *
N * List of Lint messages which will be suppressed and not shown:
N *   - not yet checked
N * .
N * Note:  To re-enable a Message, insert a space before 'lint' *
N *
N */
N
N
N/** @addtogroup CMSIS_CM0_core_definitions CM0 Core Definitions
N  This file defines all structures and symbols for CMSIS core:
N    - CMSIS version number
N    - Cortex-M core registers and bitfields
N    - Cortex-M core peripheral base address
N  @{
N */
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
N#define __CM0_CMSIS_VERSION_MAIN  (0x01)                                                       /*!< [31:16] CMSIS HAL main version */
N#define __CM0_CMSIS_VERSION_SUB   (0x30)                                                       /*!< [15:0]  CMSIS HAL sub version  */
N#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) | __CM0_CMSIS_VERSION_SUB) /*!< CMSIS HAL version number       */
N
N#define __CORTEX_M                (0x00)                                                       /*!< Cortex core                    */
N
N#include <stdint.h>                           /* Include standard types */
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 56 "..\..\..\..\CMSIS\CM0\CoreSupport\core_cm0.h" 2
N
N#if defined (__ICCARM__)
X#if 0L
S  #include <intrinsics.h>                     /* IAR Intrinsics   */
N#endif
N
N
N#ifndef __NVIC_PRIO_BITS
S  #define __NVIC_PRIO_BITS    2               /*!< standard definition for NVIC Priority Bits */
N#endif
N
N
N
N
N/**
N * IO definitions
N *
N * define access restrictions to peripheral registers
N */
N
N#ifdef __cplusplus
S  #define     __I     volatile                /*!< defines 'read only' permissions      */
N#else
N  #define     __I     volatile const          /*!< defines 'read only' permissions      */
N#endif
N#define     __O     volatile                  /*!< defines 'write only' permissions     */
N#define     __IO    volatile                  /*!< defines 'read / write' permissions   */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N ******************************************************************************/
N/** @addtogroup CMSIS_CM0_core_register CMSIS CM0 Core Register
N @{
N*/
N
N
N/** @addtogroup CMSIS_CM0_NVIC CMSIS CM0 NVIC
N  memory mapped structure for Nested Vectored Interrupt Controller (NVIC)
N  @{
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[1];                      /*!< (Offset: 0x000) Interrupt Set Enable Register            */
X  volatile uint32_t ISER[1];                       
N       uint32_t RESERVED0[31];
N  __IO uint32_t ICER[1];                      /*!< (Offset: 0x080) Interrupt Clear Enable Register          */
X  volatile uint32_t ICER[1];                       
N       uint32_t RSERVED1[31];
N  __IO uint32_t ISPR[1];                      /*!< (Offset: 0x100) Interrupt Set Pending Register           */
X  volatile uint32_t ISPR[1];                       
N       uint32_t RESERVED2[31];
N  __IO uint32_t ICPR[1];                      /*!< (Offset: 0x180) Interrupt Clear Pending Register         */
X  volatile uint32_t ICPR[1];                       
N       uint32_t RESERVED3[31];
N       uint32_t RESERVED4[64];
N  __IO uint32_t IPR[8];                       /*!< (Offset: 0x3EC) Interrupt Priority Register              */
X  volatile uint32_t IPR[8];                        
N}  NVIC_Type;
N/*@}*/ /* end of group CMSIS_CM0_NVIC */
N
N
N/** @addtogroup CMSIS_CM0_SCB CMSIS CM0 SCB
N  memory mapped structure for System Control Block (SCB)
N  @{
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                        /*!< Offset: 0x00  CPU ID Base Register                                  */
X  volatile const  uint32_t CPUID;                         
N  __IO uint32_t ICSR;                         /*!< Offset: 0x04  Interrupt Control State Register                      */
X  volatile uint32_t ICSR;                          
N       uint32_t RESERVED0;                                      
N  __IO uint32_t AIRCR;                        /*!< Offset: 0x0C  Application Interrupt / Reset Control Register        */
X  volatile uint32_t AIRCR;                         
N  __IO uint32_t SCR;                          /*!< Offset: 0x10  System Control Register                               */
X  volatile uint32_t SCR;                           
N  __IO uint32_t CCR;                          /*!< Offset: 0x14  Configuration Control Register                        */
X  volatile uint32_t CCR;                           
N       uint32_t RESERVED1;                                      
N  __IO uint32_t SHP[2];                       /*!< Offset: 0x1C  System Handlers Priority Registers. [0] is RESERVED   */
X  volatile uint32_t SHP[2];                        
N  __IO uint32_t SHCSR;                        /*!< Offset: 0x24  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                         
N       uint32_t RESERVED2[2];                                   
N  __IO uint32_t DFSR;                         /*!< Offset: 0x30  Debug Fault Status Register                           */
X  volatile uint32_t DFSR;                          
N} SCB_Type;                                                
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFul << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFul << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFul << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFul << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFul << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1ul << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1ul << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1ul << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1ul << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1ul << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1ul << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1ul << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFul << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFul << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFul << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFul << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1ul << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1ul << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1ul << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1ul << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1ul << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1ul << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1ul << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1ul << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1ul << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1ul << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1ul << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1ul << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1ul << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1ul << SCB_DFSR_HALTED_Pos)                   /*!< SCB DFSR: HALTED Mask */
N/*@}*/ /* end of group CMSIS_CM0_SCB */
N
N
N/** @addtogroup CMSIS_CM0_SysTick CMSIS CM0 SysTick
N  memory mapped structure for SysTick
N  @{
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                         /*!< Offset: 0x00  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                          
N  __IO uint32_t LOAD;                         /*!< Offset: 0x04  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                          
N  __IO uint32_t VAL;                          /*!< Offset: 0x08  SysTick Current Value Register      */
X  volatile uint32_t VAL;                           
N  __I  uint32_t CALIB;                        /*!< Offset: 0x0C  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                         
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1ul << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1ul << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1ul << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1ul << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFul << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFul << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1ul << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1ul << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFul << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N/*@}*/ /* end of group CMSIS_CM0_SysTick */
N
N
N/** @addtogroup CMSIS_CM0_CoreDebug CMSIS CM0 Core Debug
N  memory mapped structure for Core Debug Register
N  @{
N */
Ntypedef struct
N{
N  __IO uint32_t DHCSR;                        /*!< Offset: 0x00  Debug Halting Control and Status Register    */
X  volatile uint32_t DHCSR;                         
N  __O  uint32_t DCRSR;                        /*!< Offset: 0x04  Debug Core Register Selector Register        */
X  volatile  uint32_t DCRSR;                         
N  __IO uint32_t DCRDR;                        /*!< Offset: 0x08  Debug Core Register Data Register            */
X  volatile uint32_t DCRDR;                         
N  __IO uint32_t DEMCR;                        /*!< Offset: 0x0C  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                         
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFul << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1ul << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1ul << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1ul << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1ul << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1ul << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1ul << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1ul << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1ul << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1ul << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1ul << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register */
N#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1ul << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1Ful << CoreDebug_DCRSR_REGSEL_Pos)         /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register */
N#define CoreDebug_DEMCR_DWTENA_Pos         24                                             /*!< CoreDebug DEMCR: DWTENA Position */
N#define CoreDebug_DEMCR_DWTENA_Msk         (1ul << CoreDebug_DEMCR_DWTENA_Pos)            /*!< CoreDebug DEMCR: DWTENA Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1ul << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1ul << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N/*@}*/ /* end of group CMSIS_CM0_CoreDebug */
N
N
N/* Memory mapping of Cortex-M0 Hardware */
N#define SCS_BASE            (0xE000E000)                              /*!< System Control Space Base Address */
N#define CoreDebug_BASE      (0xE000EDF0)                              /*!< Core Debug Base Address           */
N#define SysTick_BASE        (SCS_BASE +  0x0010)                      /*!< SysTick Base Address              */
N#define NVIC_BASE           (SCS_BASE +  0x0100)                      /*!< NVIC Base Address                 */
N#define SCB_BASE            (SCS_BASE +  0x0D00)                      /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type *)           SCB_BASE)         /*!< SCB configuration struct          */
N#define SysTick             ((SysTick_Type *)       SysTick_BASE)     /*!< SysTick configuration struct      */
N#define NVIC                ((NVIC_Type *)          NVIC_BASE)        /*!< NVIC configuration struct         */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct   */
N
N/*@}*/ /* end of group CMSIS_CM0_core_register */
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N ******************************************************************************/
N
N#if defined ( __CC_ARM   )
X#if 1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N
N#elif defined ( __ICCARM__ )
S  #define __ASM           __asm                                       /*!< asm keyword for IAR Compiler          */
S  #define __INLINE        inline                                      /*!< inline keyword for IAR Compiler. Only avaiable in High optimization mode! */
S
S#elif defined   (  __GNUC__  )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S
S#elif defined   (  __TASKING__  )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S
N#endif
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N
N#if defined ( __CC_ARM   ) /*------------------RealView Compiler -----------------*/
X#if 1L  
N/* ARM armcc specific functions */
N
N#define __enable_fault_irq                __enable_fiq
N#define __disable_fault_irq               __disable_fiq
N
N#define __NOP                             __nop
N#define __WFI                             __wfi
N#define __WFE                             __wfe
N#define __SEV                             __sev
N#define __ISB()                           __isb(0)
N#define __DSB()                           __dsb(0)
N#define __DMB()                           __dmb(0)
N#define __REV                             __rev
N
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N
N/**
N * @brief  Return the Process Stack Pointer
N *
N * @return ProcessStackPointer
N *
N * Return the actual process stack pointer
N */
Nextern uint32_t __get_PSP(void);
N
N/**
N * @brief  Set the Process Stack Pointer
N *
N * @param  topOfProcStack  Process Stack Pointer
N *
N * Assign the value ProcessStackPointer to the MSP 
N * (process stack pointer) Cortex processor register
N */
Nextern void __set_PSP(uint32_t topOfProcStack);
N
N/**
N * @brief  Return the Main Stack Pointer
N *
N * @return Main Stack Pointer
N *
N * Return the current value of the MSP (main stack pointer)
N * Cortex processor register
N */
Nextern uint32_t __get_MSP(void);
N
N/**
N * @brief  Set the Main Stack Pointer
N *
N * @param  topOfMainStack  Main Stack Pointer
N *
N * Assign the value mainStackPointer to the MSP 
N * (main stack pointer) Cortex processor register
N */
Nextern void __set_MSP(uint32_t topOfMainStack);
N
N/**
N * @brief  Reverse byte order in unsigned short value
N *
N * @param   value  value to reverse
N * @return         reversed value
N *
N * Reverse byte order in unsigned short value
N */
Nextern uint32_t __REV16(uint16_t value);
N
N/**
N * @brief  Reverse byte order in signed short value with sign extension to integer
N *
N * @param   value  value to reverse
N * @return         reversed value
N *
N * Reverse byte order in signed short value with sign extension to integer
N */
Nextern int32_t __REVSH(int16_t value);
N
N
N#if (__ARMCC_VERSION < 400000)
X#if (5060422 < 400000)
S
S/**
S * @brief  Return the Priority Mask value
S *
S * @return PriMask
S *
S * Return state of the priority mask bit from the priority mask register
S */
Sextern uint32_t __get_PRIMASK(void);
S
S/**
S * @brief  Set the Priority Mask value
S *
S * @param   priMask  PriMask
S *
S * Set the priority mask bit in the priority mask register
S */
Sextern void __set_PRIMASK(uint32_t priMask);
S
S/**
S * @brief  Return the Control Register value
S * 
S * @return Control value
S *
S * Return the content of the control register
S */
Sextern uint32_t __get_CONTROL(void);
S
S/**
S * @brief  Set the Control Register value
S *
S * @param  control  Control value
S *
S * Set the control register
S */
Sextern void __set_CONTROL(uint32_t control);
S
N#else  /* (__ARMCC_VERSION >= 400000)  */
N
N
N/**
N * @brief  Return the Priority Mask value
N *
N * @return PriMask
N *
N * Return state of the priority mask bit from the priority mask register
N */
Nstatic __INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N/**
N * @brief  Set the Priority Mask value
N *
N * @param  priMask  PriMask
N *
N * Set the priority mask bit in the priority mask register
N */
Nstatic __INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N/**
N * @brief  Return the Control Register value
N * 
N * @return Control value
N *
N * Return the content of the control register
N */
Nstatic __INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N/**
N * @brief  Set the Control Register value
N *
N * @param  control  Control value
N *
N * Set the control register
N */
Nstatic __INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N#endif /* __ARMCC_VERSION  */ 
N
N
N
N#elif (defined (__ICCARM__)) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#define __enable_irq                              __enable_interrupt        /*!< global Interrupt enable */
S#define __disable_irq                             __disable_interrupt       /*!< global Interrupt disable */
S
Sstatic __INLINE void __enable_fault_irq()         { __ASM ("cpsie f"); }
Sstatic __INLINE void __disable_fault_irq()        { __ASM ("cpsid f"); }
S
S#define __NOP                                     __no_operation            /*!< no operation intrinsic in IAR Compiler */ 
Sstatic __INLINE  void __WFI()                     { __ASM ("wfi"); }
Sstatic __INLINE  void __WFE()                     { __ASM ("wfe"); }
Sstatic __INLINE  void __SEV()                     { __ASM ("sev"); }
S
S/* intrinsic void __ISB(void)                                     */
S/* intrinsic void __DSB(void)                                     */
S/* intrinsic void __DMB(void)                                     */
S/* intrinsic void __set_PRIMASK();                                */
S/* intrinsic void __get_PRIMASK();                                */
S
S
S/* intrinsic uint32_t __REV(uint32_t value);                      */
S/* intrinsic uint32_t __REVSH(uint32_t value);                    */
S
S
S/**
S * @brief  Return the Process Stack Pointer
S *
S * @return ProcessStackPointer
S *
S * Return the actual process stack pointer
S */
Sextern uint32_t __get_PSP(void);
S
S/**
S * @brief  Set the Process Stack Pointer
S *
S * @param  topOfProcStack  Process Stack Pointer
S *
S * Assign the value ProcessStackPointer to the MSP 
S * (process stack pointer) Cortex processor register
S */
Sextern void __set_PSP(uint32_t topOfProcStack);
S
S/**
S * @brief  Return the Main Stack Pointer
S *
S * @return Main Stack Pointer
S *
S * Return the current value of the MSP (main stack pointer)
S * Cortex processor register
S */
Sextern uint32_t __get_MSP(void);
S
S/**
S * @brief  Set the Main Stack Pointer
S *
S * @param  topOfMainStack  Main Stack Pointer
S *
S * Assign the value mainStackPointer to the MSP 
S * (main stack pointer) Cortex processor register
S */
Sextern void __set_MSP(uint32_t topOfMainStack);
S
S/**
S * @brief  Reverse byte order in unsigned short value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in unsigned short value
S */
Sextern uint32_t __REV16(uint16_t value);
S
S
S
S
S
S#elif (defined (__GNUC__)) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
Sstatic __INLINE void __enable_irq()               { __ASM volatile ("cpsie i"); }
Sstatic __INLINE void __disable_irq()              { __ASM volatile ("cpsid i"); }
S
Sstatic __INLINE void __enable_fault_irq()         { __ASM volatile ("cpsie f"); }
Sstatic __INLINE void __disable_fault_irq()        { __ASM volatile ("cpsid f"); }
S
Sstatic __INLINE void __NOP()                      { __ASM volatile ("nop"); }
Sstatic __INLINE void __WFI()                      { __ASM volatile ("wfi"); }
Sstatic __INLINE void __WFE()                      { __ASM volatile ("wfe"); }
Sstatic __INLINE void __SEV()                      { __ASM volatile ("sev"); }
Sstatic __INLINE void __ISB()                      { __ASM volatile ("isb"); }
Sstatic __INLINE void __DSB()                      { __ASM volatile ("dsb"); }
Sstatic __INLINE void __DMB()                      { __ASM volatile ("dmb"); }
S
S
S/**
S * @brief  Return the Process Stack Pointer
S *
S * @return ProcessStackPointer
S *
S * Return the actual process stack pointer
S */
Sextern uint32_t __get_PSP(void);
S
S/**
S * @brief  Set the Process Stack Pointer
S *
S * @param  topOfProcStack  Process Stack Pointer
S *
S * Assign the value ProcessStackPointer to the MSP 
S * (process stack pointer) Cortex processor register
S */
Sextern void __set_PSP(uint32_t topOfProcStack);
S
S/**
S * @brief  Return the Main Stack Pointer
S *
S * @return Main Stack Pointer
S *
S * Return the current value of the MSP (main stack pointer)
S * Cortex processor register
S */
Sextern uint32_t __get_MSP(void);
S
S/**
S * @brief  Set the Main Stack Pointer
S *
S * @param  topOfMainStack  Main Stack Pointer
S *
S * Assign the value mainStackPointer to the MSP 
S * (main stack pointer) Cortex processor register
S */
Sextern void __set_MSP(uint32_t topOfMainStack);
S
S/**
S * @brief  Return the Priority Mask value
S *
S * @return PriMask
S *
S * Return state of the priority mask bit from the priority mask register
S */
Sextern uint32_t  __get_PRIMASK(void);
S
S/**
S * @brief  Set the Priority Mask value
S *
S * @param  priMask  PriMask
S *
S * Set the priority mask bit in the priority mask register
S */
Sextern void __set_PRIMASK(uint32_t priMask);
S
S/**
S * @brief  Return the Control Register value
S* 
S*  @return Control value
S *
S * Return the content of the control register
S */
Sextern uint32_t __get_CONTROL(void);
S
S/**
S * @brief  Set the Control Register value
S *
S * @param  control  Control value
S *
S * Set the control register
S */
Sextern void __set_CONTROL(uint32_t control);
S
S/**
S * @brief  Reverse byte order in integer value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in integer value
S */
Sextern uint32_t __REV(uint32_t value);
S
S/**
S * @brief  Reverse byte order in unsigned short value
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in unsigned short value
S */
Sextern uint32_t __REV16(uint16_t value);
S
S/**
S * @brief  Reverse byte order in signed short value with sign extension to integer
S *
S * @param  value  value to reverse
S * @return        reversed value
S *
S * Reverse byte order in signed short value with sign extension to integer
S */
Sextern int32_t __REVSH(int16_t value);
S
S
S#elif (defined (__TASKING__)) /*------------------ TASKING Compiler ---------------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N
N/** @addtogroup CMSIS_CM0_Core_FunctionInterface CMSIS CM0 Core Function Interface
N  Core  Function Interface containing:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Reset Functions
N*/
N/*@{*/
N
N/* ##########################   NVIC functions  #################################### */
N
N/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  (((uint32_t)(IRQn)       )    &  0x03) * 8 )
N#define _SHP_IDX(IRQn)           ( ((((uint32_t)(IRQn) & 0x0F)-8) >>    2)     )
N#define _IP_IDX(IRQn)            (   ((uint32_t)(IRQn)            >>    2)     )
N
N
N/**
N * @brief  Enable Interrupt in NVIC Interrupt Controller
N *
N * @param  IRQn   The positive number of the external interrupt to enable
N *
N * Enable a device specific interupt in the NVIC interrupt controller.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Disable the interrupt line for external interrupt specified
N * 
N * @param  IRQn   The positive number of the external interrupt to disable
N * 
N * Disable a device specific interupt in the NVIC interrupt controller.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Read the interrupt pending bit for a device specific interrupt source
N * 
N * @param  IRQn    The number of the device specifc interrupt
N * @return         1 = interrupt pending, 0 = interrupt not pending
N *
N * Read the pending register in NVIC and return 1 if its status is pending, 
N * otherwise it returns 0
N */
Nstatic __INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if pending else 0 */
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000) + 0x0100))->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N/**
N * @brief  Set the pending bit for an external interrupt
N * 
N * @param  IRQn    The number of the interrupt for set pending
N *
N * Set the pending bit for the specified interrupt.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Clear the pending bit for an external interrupt
N *
N * @param  IRQn    The number of the interrupt for clear pending
N *
N * Clear the pending bit for the specified interrupt. 
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Set the priority for an interrupt
N *
N * @param  IRQn      The number of the interrupt for set priority
N * @param  priority  The priority to set
N *
N * Set the priority for the specified interrupt. The interrupt 
N * number can be positive to specify an external (device specific) 
N * interrupt, or negative to specify an internal (core) interrupt.
N *
N * Note: The priority cannot be set for every core interrupt.
N */
Nstatic __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) | 
X    ((SCB_Type *) ((0xE000E000) + 0x0D00))->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] = (((SCB_Type *) ((0xE000E000) + 0x0D00))->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) | 
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N  else {
N    NVIC->IPR[_IP_IDX(IRQn)] = (NVIC->IPR[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000) + 0x0100))->IPR[( ((uint32_t)(IRQn) >> 2) )] = (((NVIC_Type *) ((0xE000E000) + 0x0100))->IPR[( ((uint32_t)(IRQn) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N}
N
N/**
N * @brief  Read the priority for an interrupt
N *
N * @param  IRQn      The number of the interrupt for get priority
N * @return           The priority for the interrupt
N *
N * Read the priority for the specified interrupt. The interrupt 
N * number can be positive to specify an external (device specific) 
N * interrupt, or negative to specify an internal (core) interrupt.
N *
N * The returned priority value is automatically aligned to the implemented
N * priority bits of the microcontroller.
N *
N * Note: The priority cannot be set for every core interrupt.
N */
Nstatic __INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M0 system interrupts */
X    return((uint32_t)((((SCB_Type *) ((0xE000E000) + 0x0D00))->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) >> (8 - 2)));  }  
N  else {
N    return((uint32_t)((NVIC->IPR[_IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)((((NVIC_Type *) ((0xE000E000) + 0x0100))->IPR[( ((uint32_t)(IRQn) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) >> (8 - 2)));  }  
N}
N
N
N
N/* ##################################    SysTick function  ############################################ */
N
N#if (!defined (__Vendor_SysTickConfig)) || (__Vendor_SysTickConfig == 0)
X#if (!1L) || (0 == 0)
N
N/**
N * @brief  Initialize and start the SysTick counter and its interrupt.
N *
N * @param   ticks   number of ticks between two interrupts
N * @return  1 = failed, 0 = successful
N *
N * Initialise the system tick timer and its interrupt and start the
N * system tick timer / counter in free running mode to generate 
N * periodical interrupts.
N */
Nstatic __INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{ 
N  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
X  if (ticks > (0xFFFFFFul << 0))  return (1);             
N                                                               
N  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->LOAD  = (ticks & (0xFFFFFFul << 0)) - 1;       
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */
X  NVIC_SetPriority (SysTick_IRQn, (1<<2) - 1);   
N  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->VAL   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk | 
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->CTRL  = (1ul << 2) | 
N                   SysTick_CTRL_TICKINT_Msk   | 
X                   (1ul << 1)   | 
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1ul << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N
N
N
N/* ##################################    Reset function  ############################################ */
N
N/**
N * @brief  Initiate a system reset request.
N *
N * Initiate a system reset request to reset the MCU
N */
Nstatic __INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      | 
X  ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR  = ((0x5FA << 16)      | 
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1ul << 2));
N  __DSB();                                                                             /* Ensure completion of memory access */              
X  __dsb(0);                                                                                            
N  while(1);                                                                            /* wait until reset */
N}
N
N/*@}*/ /* end of group CMSIS_CM0_Core_FunctionInterface */
N
N#ifdef __cplusplus
S}
N#endif
N
N/*@}*/ /* end of group CMSIS_CM0_core_definitions */
N
N#endif /* __CM0_CORE_H__ */
N
N/*lint -restore */
L 75 "..\..\..\..\CMSIS\CM0\DeviceSupport\Nuvoton\NUC1xx\NUC1xx.h" 2
N#include "system_NUC1xx.h"              /* NUC1xx System                                          */
L 1 "..\..\..\..\CMSIS\CM0\DeviceSupport\Nuvoton\NUC1xx\system_NUC1xx.h" 1
N/*---------------------------------------------------------------------------------------------------------*/
N/*                                                                                                         */
N/* Copyright(c) 2009 Nuvoton Technology Corp. All rights reserved.                                         */
N/*                                                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#ifndef __SYSTEM_NUC1xx_H
N#define __SYSTEM_NUC1xx_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N/*---------------------------------------------------------------------------------------------------------*/
N/* Macro Definition                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N
N//#define DEBUG_ENABLE_SEMIHOST   /* To enable semihosted. !!!The SEMIHOSTED of startup_NUC1xx.s must be {TRUE} */
N
N/* Using UART0 or UART1 */  
N#define DEBUG_PORT   0 		    /*0:UART0  1:UART1 2:UART2 */
N
N/*----------------------------------------------------------------------------
N  Define SYSCLK
N *----------------------------------------------------------------------------*/
N#define __XTAL      (12000000UL)
N#define __RTC_XTAL  (32768UL)
N#define __IRC22M    (22118400UL)
N#define __IRC10K    (10000UL)
N#define __HSI       (__IRC22M)      /* Factory Default is internal 22MHz */
N
Nextern uint32_t SystemCoreClock;                   /*!< System Clock Frequency (Core Clock) */
Nextern uint32_t CyclesPerUs;                       /* Cycles per micro second */
N
N/**
N * Initialize the system
N *
N * @param  none
N * @return none
N *
N * @brief  Setup the microcontroller system
N *         Initialise GPIO directions and values
N */
Nextern void SystemInit(void);
N
N
N/**
N * Update SystemCoreClock variable
N *
N * @param  none
N * @return none
N *
N * @brief  Updates the SystemCoreClock with current core Clock 
N *         retrieved from cpu registers.
N */
Nextern void SystemCoreClockUpdate (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 76 "..\..\..\..\CMSIS\CM0\DeviceSupport\Nuvoton\NUC1xx\NUC1xx.h" 2
N#include "System\SysInfra.h"    
L 1 "..\..\..\Include\System\SysInfra.h" 1
N/*---------------------------------------------------------------------------------------------------------*/
N/*                                                                                                         */
N/* Copyright (c) Nuvoton Technology Corp. All rights reserved.                                             */
N/*                                                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N
N
N#ifndef __SYSINFRA_H__
N#define __SYSINFRA_H__
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Includes of system headers                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#include "ModuleID.h"
L 1 "..\..\..\Include\System\ModuleID.h" 1
N/*---------------------------------------------------------------------------------------------------------*/
N/*                                                                                                         */
N/* Copyright (c) Nuvoton Technology Corp. All rights reserved.                                             */
N/*                                                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#ifndef __MODULE_ID_H__
N#define __MODULE_ID_H__
N
N
Ntypedef enum
N{
N	/* Module ID valid range: 0 ~ 255 */
N	
N	/* Driver: Module ID					Module Name */
N	MODULE_ID_DRVPROTECT		= 0,		/* DrvProtect */
N
N	MODULE_ID_DRVADC			= 2,		/* DrvADC  */
N	MODULE_ID_DRVAIC			= 4,		/* DrvAIC  */
N	MODULE_ID_DRVAPU			= 6,		/* DrvAPU  */
N	MODULE_ID_DRVAUDIOADC		= 8,		/* DrvAudioADC */
N	MODULE_ID_DRVCACHE			= 10,		/* DrvCache	*/
N	MODULE_ID_DRVCAN			= 11,		/* DrvCAN */
N	MODULE_ID_DRVEBI			= 12,		/* DrvEBI */
N	MODULE_ID_DRVEDMA			= 13,		/* DrvEDMA */
N	MODULE_ID_DRVGDMA			= 14,		/* DrvGDMA */
N	MODULE_ID_DRVFSC			= 15,		/* DrvFSC */
N	MODULE_ID_DRVGE				= 16,		/* DrvGE  */
N	MODULE_ID_DRVFMC			= 17,		/* DrvFMC */
N	MODULE_ID_DRVGPIO			= 18,		/* DrvGPIO */
N	
N	MODULE_ID_DRVGPU			= 20,		/* DrvGPU */
N	MODULE_ID_DRVI2C			= 22,		/* DrvI2C (S/W I2C for Non-UL; H/W I2C for UL) */
N	MODULE_ID_DRVI2S			= 24,		/* DrvI2S */
N	MODULE_ID_DRVI2SM			= 26,		/* DrvI2SM	*/
N	MODULE_ID_DRVMPU			= 28,		/* DrvMPU */
N	MODULE_ID_DRVNAND			= 30,		/* DrvNAND */
N	MODULE_ID_DRVNOR			= 32,		/* DrvNOR */
N	MODULE_ID_DRVPDMA     		= 33,       /* DrvPDMA */
N	MODULE_ID_DRVPWM			= 34,		/* DrvPWM */
N	MODULE_ID_DRVPS2			= 35,		/* DrvPS2 */
N	MODULE_ID_DRVRTC			= 36,		/* DrvRTC */
N	MODULE_ID_DRVSDCARD			= 38,		/* DrvSDCard */
N	MODULE_ID_DRVSIO			= 39,		/* DrvSerialIO */
N
N	MODULE_ID_DRVSPI			= 40,		/* DrvSPI */
N	MODULE_ID_DRVSPIMS			= 41,		/* DrvSPIMS	*/
N	MODULE_ID_DRVSPIFLASH		= 42,		/* DrvSPIFlash */
N	MODULE_ID_DRVSPIM			= 43,		/* DrvSPIM */
N	MODULE_ID_DRVSYS			= 44,		/* DrvSystem */
N	MODULE_ID_DRVSPU			= 45,		/* DrvSPU */
N	MODULE_ID_DRVTIMER			= 46,		/* DrvTimer	*/
N	MODULE_ID_DRVUART			= 48,		/* DrvUART */
N	MODULE_ID_DRVUSB			= 50,		/* DrvUSB */
N	MODULE_ID_DRVUSBH			= 52,		/* DrvUSBH */
N	MODULE_ID_DRVVDMA			= 54,		/* DrvVDMA */
N	MODULE_ID_DRVVIDEOIN		= 56,		/* DrvVideoIn */
N	MODULE_ID_DRVVPOST			= 58,		/* DrvVPOST	*/
N
N	MODULE_ID_DRVVRAM			= 60,		/* DrvVRAM	*/
N	MODULE_ID_DRVW55U02			= 62,		/* DrvW55U02 */
N	MODULE_ID_DRVI2CH			= 64,		/* DrvI2CH (H/W I2C for Non-UL) */
N	MODULE_ID_DRVWDT			= 66,		/* DrvWDT  */
N	MODULE_ID_DRVJPEG			= 68,		/* DrvJPEG */
N	
N	MODULE_ID_DRVZEROG			= 70,		/* DrvZeroG	 */
N	MODULE_ID_DRVSI2C			= 71,		/* DrvSI2C (S/W I2C for Non-UL) */
N
N	/* Audio: Module ID						Module Name */
N	MODULE_ID_AEC				= 81,		/* AEC	*/
N	MODULE_ID_BEATDET			= 82,		/* BeatDetection */
N	MODULE_ID_SNDEFF			= 83,		/* SoundEffect	*/
N	MODULE_ID_AUDIOSYN			= 84,		/* AudioSynthesizer */
N	MODULE_ID_G726ADPCM			= 85,		/* G726ADPCM  */
N	MODULE_ID_IMAADPCM			= 86,		/* IMAAdpcmCodec */
N	MODULE_ID_MP3DEC			= 88,		/* MP3Decoder */
N	MODULE_ID_PITCHCHANGE		= 90,		/* PitchChanger	*/
N	MODULE_ID_WAVFILEUTIL		= 92,		/* WavFileUtil */
N	MODULE_ID_WMADEC			= 96,		/* WMADecoder  */
N	MODULE_ID_WMADECDRM			= 98,		/* WMADecoderWithDrm */
N	MODULE_ID_AUDIOCTRL			= 100,		/* AudioCtrl */
N	MODULE_ID_EQ				= 106,		/* Equalizer */
N	MODULE_ID_OGGDEC			= 110,		/* OggDecoder */
N	MODULE_ID_MP3ENC			= 112,		/* MP3Encoder */
N	MODULE_ID_UADEC				= 114,		/* UltraAudioDec */
N	MODULE_ID_ULSPEECHDEC		= 115,		/* UltraLowSpeechDec */
N	MODULE_ID_USPEECHDEC		= 116,		/* UltraSpeechDec */
N	MODULE_ID_SPEECHRECOG		= 118,		/* SpeechRecog */
N
N	/* File System: Module ID				Module Name */
N	MODULE_ID_FS				= 120,		/* FileSystem */
N	
N	/* Flash Lite: Module ID				Module Name */
N	MODULE_ID_FL				= 128,		/* FlashLite */
N	
N	/* Communication: Module ID				Module Name */
N	MODULE_ID_KEYPAD			= 130,		/* Keypad  */
N	MODULE_ID_LWIP				= 132,		/* LwIP	  */
N	MODULE_ID_WLANMGR			= 134,		/* WLanMgr	*/
N	MODULE_ID_HTTPD				= 136,		/* HTTPD   */
N	MODULE_ID_VIRTUALCOM		= 139,		/* VirtualCOM */
N
N	/* Graphics: Module ID					Module Name */
N	MODULE_ID_GFXRESLDR			= 140,		/* GraphicsResLoader */
N	MODULE_ID_GFXLIB			= 141,		/* GraphicsLib */
N	MODULE_ID_IMGPROC			= 142,		/* ImageProcess	*/
N	MODULE_ID_JPEG				= 144,		/* JPEGCodec */
N	MODULE_ID_PNGDEC			= 146,		/* PNGCodec	*/
N	MODULE_ID_BARCODE2D			= 148,		/* BarCode2D */	 
N	MODULE_ID_PTNRECOG			= 150,		/* PtnRecog	*/
N	MODULE_ID_MOTIONDET			= 152,		/* MotionDection */
N	
N	/* Storage: Module ID					Module Name	*/
N	MODULE_ID_STORIF			= 160,		/* StorageInterface */
N	MODULE_ID_SDCARD			= 161,		/* SDCard */
N	MODULE_ID_SYSNAND			= 162,		/* SysNand */
N	MODULE_ID_SPIFLASH			= 163,		/* SPIFlash	*/
N	MODULE_ID_WTRIF				= 164,		/* WriterInterface */
N	MODULE_ID_NORFLASH			= 165,		/* NORFlash	*/
N	MODULE_ID_SYSNANDLITE		= 166,		/* SysNandLite */
N	
N	/* System: Module ID					Module Name */
N	MODULE_ID_INTMGR			= 180,		/* InterruptManager */
N	MODULE_ID_BLKLDR			= 181,		/* BlockLoader */
N	MODULE_ID_MEMMGR			= 182,		/* MemoryManager */
N	MODULE_ID_EVTMGR			= 183,		/* EventManager	*/
N	MODULE_ID_PROF				= 184,		/* Profiling  */
N	MODULE_ID_PROGLDR			= 186,		/* ProgramLoader */
N	MODULE_ID_SYSINFRA			= 188,		/* SysInfra	*/
N	MODULE_ID_TIMERCTRL			= 190,		/* TimerCtrl */
N	MODULE_ID_TIMEUTIL			= 192,		/* TimeUtil	*/
N	MODULE_ID_CONPROGLDR		= 194,		/* ConsoleProgramLoader */
N	
N	/* USB: Module ID						Module Name */
N	MODULE_ID_USBCOREH			= 78,		/* USBCoreH	*/
N	MODULE_ID_HID				= 220,		/* HID */
N	MODULE_ID_MASSSTOR			= 222,		/* MassStor */
N	MODULE_ID_MASSSTORHID		= 224,		/* MassStorHID */
N	MODULE_ID_MASSSTORLITE		= 226,		/* MassStorLite	*/
N	MODULE_ID_MTP				= 230,		/* MTP */
N	MODULE_ID_USBINFRA			= 232,		/* USBInfra */
N	MODULE_ID_UAC				= 234,		/* UAC */
N	MODULE_ID_UAVC				= 236,		/* UAVC	*/
N	MODULE_ID_UVC				= 238,		/* UVC */
N	MODULE_ID_MASSSTORH			= 252,		/* MassStorH */
N	MODULE_ID_HIDH				= 254,		/* HIDH	*/
N	MODULE_ID_VCOM				= 253,		/* VCOM	*/
N
N	/* Security: Module ID					Module Name */
N	MODULE_ID_MSDRMPD			= 228,		/* MsDrmPd */
N	
N	/* Video: Module ID						Module Name */
N	MODULE_ID_AVICODEC			= 240,		/* AVICodec	 */
N	MODULE_ID_MJPEG				= 242,		/* MJpegCodec  */
N	MODULE_ID_WIVICORE			= 244,		/* WiViCore	*/
N	MODULE_ID_WIVI				= 246,		/* WiViDec */	
N	MODULE_ID_AVCTRL			= 248,		/* AVControl */
N	MODULE_ID_AVIUTIL			= 250,		/* AVIUtility */
N	
N	/* Wireless Toy							Module Name */
N	MODULE_ID_WTCHAN			= 168,		/* WTChannel */
N	MODULE_ID_WTCMDSERV			= 170,		/* WTCMDService */
N	MODULE_ID_WTDISPLAY			= 172,		/* WTDisplay */
N	MODULE_ID_WTMEDIA			= 174,		/* WTMedia */
N	MODULE_ID_WTSYS				= 176,		/* WTSystem	 */
N	MODULE_ID_WTTRANS			= 178,		/* WTTransport */
N	
N	// Module ID valid range: 0 ~ 255	
N} E_SYSINFRA_MODULE_ID;
N
N
N#endif /* __MODULE_ID_H__ */
L 15 "..\..\..\Include\System\SysInfra.h" 2
N#include "stdint.h"
N#include "core_cm0.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define Version number								                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#define SYSINFRA_MAJOR_NUM		1
N#define SYSINFRA_MINOR_NUM		00
N#define SYSINFRA_BUILD_NUM		1
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Macro, type and constant definitions                                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define an error code composed of error bit, module ID, and error ID. */
N#define _SYSINFRA_ERRCODE(IS_ERROR, MODULE_ID_VALUE, ERROR_ID)      (((IS_ERROR) ? 0xFFFF0000 : 0x00000000) | ((((MODULE_ID_VALUE) & 0xFF) | ((IS_ERROR) ? 0x100 : 0x00)) << 7) | ((ERROR_ID) & 0x7F))
N#define _SYSINFRA_ERRCODE_DEF(MODULE_ID, ERROR_NAME, IS_ERROR, MODULE_ID_VALUE, ERROR_ID) enum {E_##MODULE_ID##_##ERROR_NAME = ((IS_ERROR) ? 0xFFFF0000 : 0x00000000) | ((((MODULE_ID_VALUE) & 0xFF) | ((IS_ERROR) ? 0x100 : 0x00)) << 7) | ((ERROR_ID) & 0x7F)};
N
N/* Define a module version composed of major number, minor number, and build number. */
N#define _SYSINFRA_VERSION(MAJOR_NUM, MINOR_NUM, BUILD_NUM)          (((MAJOR_NUM) << 16) | ((MINOR_NUM) << 8) | (BUILD_NUM))
N#define _SYSINFRA_VERSION_DEF(MODULE_ID, MAJOR_NUM, MINOR_NUM, BUILD_NUM)	enum {MODULE_ID##_VERSION_NUM = ((MAJOR_NUM) << 16) | ((MINOR_NUM) << 8) | (BUILD_NUM)};
N
N/* Test if this error code means an error by seeing its error bit (BIT31). */
N#define _SYSINFRA_ERRCODE_IS_ERROR(ERROR_CODE)	((ERROR_CODE) < 0)
N/* Extract module ID part of this error code. */
N#define _SYSINFRA_ERRCODE_EXTRACT_MODULE_ID(ERROR_CODE)	(((ERROR_CODE) >> 7) & 0xFF)
N/* Extract error ID part of this error code. */
N#define _SYSINFRA_ERRCODE_EXTRACT_ERROR_ID(ERROR_CODE)	((ERROR_CODE) & 0x7F)
N
N/* Define module version number.*/
N#define SYSINFRA_VERSION_NUM    _SYSINFRA_VERSION(SYSINFRA_MAJOR_NUM, SYSINFRA_MINOR_NUM, SYSINFRA_BUILD_NUM)
N
N#define E_SUCCESS		0
N#define S_OK			E_SUCCESS
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define Error Code									                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N/* #define Error Code */
N//E_SYSINFRA_NOT_DEFINE					Un-defined error code	
N//E_SYSINFRA_NULL_POINTER				A NULL pointer is passed as an argument
N//E_SYSINFRA_BUFFER_OVERRUN				Buffer size is not enough
N
N#define E_SYSINFRA_NOT_DEFINE       _SYSINFRA_ERRCODE(TRUE, MODULE_ID_SYSINFRA, 0)
N#define E_SYSINFRA_NULL_POINTER     _SYSINFRA_ERRCODE(TRUE, MODULE_ID_SYSINFRA, 1)
N#define E_SYSINFRA_BUFFER_OVERRUN   _SYSINFRA_ERRCODE(TRUE, MODULE_ID_SYSINFRA, 2)
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // __SYSINFRA_H__
N
N
N
L 77 "..\..\..\..\CMSIS\CM0\DeviceSupport\Nuvoton\NUC1xx\NUC1xx.h" 2
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma anon_unions
N#endif
N
N/******************************************************************************/
N/*                Device Specific Peripheral registers structures             */
N/******************************************************************************/
N
N/*--------------------- General Purpose Input and Ouptut ---------------------*/
Ntypedef struct
N{
N    __IO uint32_t PMD0:2;
X    volatile uint32_t PMD0:2;
N    __IO uint32_t PMD1:2;
X    volatile uint32_t PMD1:2;
N    __IO uint32_t PMD2:2;
X    volatile uint32_t PMD2:2;
N    __IO uint32_t PMD3:2;
X    volatile uint32_t PMD3:2;
N    __IO uint32_t PMD4:2;
X    volatile uint32_t PMD4:2;
N    __IO uint32_t PMD5:2;
X    volatile uint32_t PMD5:2;
N    __IO uint32_t PMD6:2;
X    volatile uint32_t PMD6:2;
N    __IO uint32_t PMD7:2;
X    volatile uint32_t PMD7:2;
N    __IO uint32_t PMD8:2;
X    volatile uint32_t PMD8:2;
N    __IO uint32_t PMD9:2;
X    volatile uint32_t PMD9:2;
N    __IO uint32_t PMD10:2;
X    volatile uint32_t PMD10:2;
N    __IO uint32_t PMD11:2;
X    volatile uint32_t PMD11:2;
N    __IO uint32_t PMD12:2;
X    volatile uint32_t PMD12:2;
N    __IO uint32_t PMD13:2;
X    volatile uint32_t PMD13:2;
N    __IO uint32_t PMD14:2;
X    volatile uint32_t PMD14:2;
N    __IO uint32_t PMD15:2;
X    volatile uint32_t PMD15:2;
N} GPIO_PMD_T;
N
Ntypedef __IO uint32_t GPIO_OFFD_T;
Xtypedef volatile uint32_t GPIO_OFFD_T;
N
Ntypedef __IO uint32_t GPIO_DOUT_T;
Xtypedef volatile uint32_t GPIO_DOUT_T;
N
Ntypedef __IO uint32_t GPIO_DMASK_T;
Xtypedef volatile uint32_t GPIO_DMASK_T;
N
Ntypedef __IO uint32_t GPIO_PIN_T;
Xtypedef volatile uint32_t GPIO_PIN_T;
N
Ntypedef __IO uint32_t GPIO_DBEN_T;
Xtypedef volatile uint32_t GPIO_DBEN_T;
N
Ntypedef __IO uint32_t GPIO_IMD_T;
Xtypedef volatile uint32_t GPIO_IMD_T;
N
Ntypedef __IO uint32_t GPIO_IEN_T;
Xtypedef volatile uint32_t GPIO_IEN_T;
N
Ntypedef __IO uint32_t GPIO_ISRC_T;
Xtypedef volatile uint32_t GPIO_ISRC_T;
N
Ntypedef struct
N{
N    union {
N        __IO uint32_t u32PMD;
X        volatile uint32_t u32PMD;
N        struct {
N            __IO uint32_t PMD0:2;
X            volatile uint32_t PMD0:2;
N            __IO uint32_t PMD1:2;
X            volatile uint32_t PMD1:2;
N            __IO uint32_t PMD2:2;
X            volatile uint32_t PMD2:2;
N            __IO uint32_t PMD3:2;
X            volatile uint32_t PMD3:2;
N            __IO uint32_t PMD4:2;
X            volatile uint32_t PMD4:2;
N            __IO uint32_t PMD5:2;
X            volatile uint32_t PMD5:2;
N            __IO uint32_t PMD6:2;
X            volatile uint32_t PMD6:2;
N            __IO uint32_t PMD7:2;
X            volatile uint32_t PMD7:2;
N            __IO uint32_t PMD8:2;
X            volatile uint32_t PMD8:2;
N            __IO uint32_t PMD9:2;
X            volatile uint32_t PMD9:2;
N            __IO uint32_t PMD10:2;
X            volatile uint32_t PMD10:2;
N            __IO uint32_t PMD11:2;
X            volatile uint32_t PMD11:2;
N            __IO uint32_t PMD12:2;
X            volatile uint32_t PMD12:2;
N            __IO uint32_t PMD13:2;
X            volatile uint32_t PMD13:2;
N            __IO uint32_t PMD14:2;
X            volatile uint32_t PMD14:2;
N            __IO uint32_t PMD15:2;
X            volatile uint32_t PMD15:2;
N        } PMD;
N    };
N
N    union {
N        __IO uint32_t u32OFFD;
X        volatile uint32_t u32OFFD;
N        __IO uint32_t OFFD;
X        volatile uint32_t OFFD;
N    };
N
N    union {
N        __IO uint32_t u32DOUT;
X        volatile uint32_t u32DOUT;
N        __IO uint32_t DOUT;
X        volatile uint32_t DOUT;
N    };
N
N    union {
N        __IO uint32_t u32DMASK;
X        volatile uint32_t u32DMASK;
N        __IO uint32_t DMASK;
X        volatile uint32_t DMASK;
N    };
N
N    union {
N        __IO uint32_t u32PIN;
X        volatile uint32_t u32PIN;
N        __IO uint32_t PIN;
X        volatile uint32_t PIN;
N    };
N
N    union {
N        __IO uint32_t u32DBEN;
X        volatile uint32_t u32DBEN;
N        __IO uint32_t DBEN;
X        volatile uint32_t DBEN;
N    };
N
N    union {
N        __IO uint32_t u32IMD;
X        volatile uint32_t u32IMD;
N        __IO uint32_t IMD;
X        volatile uint32_t IMD;
N    };
N
N    union {
N        __IO uint32_t u32IEN;
X        volatile uint32_t u32IEN;
N        __IO uint32_t IEN;
X        volatile uint32_t IEN;
N    };
N
N    union {
N        __IO uint32_t u32ISRC;
X        volatile uint32_t u32ISRC;
N        __IO uint32_t ISRC;
X        volatile uint32_t ISRC;
N    };
N} GPIO_T;
N
Ntypedef struct
N{
N    union {
N        __IO uint32_t u32DBNCECON;
X        volatile uint32_t u32DBNCECON;
N        struct {
N            __IO uint32_t   DBCLKSEL:4;
X            volatile uint32_t   DBCLKSEL:4;
N            __IO uint32_t   DBCLKSRC:1;
X            volatile uint32_t   DBCLKSRC:1;
N            __IO uint32_t   ICLK_ON:1;
X            volatile uint32_t   ICLK_ON:1;
N            __I  uint32_t   RESERVE:26;    
X            volatile const  uint32_t   RESERVE:26;    
N        } DBNCECON;
N    };
N} GPIO_DBNCECON_T;
N
N/* GPIO PMD Bit Field Definitions */
N#define GPIO_PMD_PMD15_Pos          30
N#define GPIO_PMD_PMD15_Msk          (0x3ul << GPIO_PMD_PMD15_Pos)
N
N#define GPIO_PMD_PMD14_Pos          28
N#define GPIO_PMD_PMD14_Msk          (0x3ul << GPIO_PMD_PMD14_Pos)
N
N#define GPIO_PMD_PMD13_Pos          26
N#define GPIO_PMD_PMD13_Msk          (0x3ul << GPIO_PMD_PMD13_Pos)
N
N#define GPIO_PMD_PMD12_Pos          24
N#define GPIO_PMD_PMD12_Msk          (0x3ul << GPIO_PMD_PMD12_Pos)
N
N#define GPIO_PMD_PMD11_Pos          22
N#define GPIO_PMD_PMD11_Msk          (0x3ul << GPIO_PMD_PMD11_Pos)
N
N#define GPIO_PMD_PMD10_Pos          20
N#define GPIO_PMD_PMD10_Msk          (0x3ul << GPIO_PMD_PMD10_Pos)
N
N#define GPIO_PMD_PMD9_Pos           18
N#define GPIO_PMD_PMD9_Msk           (0x3ul << GPIO_PMD_PMD9_Pos)
N
N#define GPIO_PMD_PMD8_Pos           16
N#define GPIO_PMD_PMD8_Msk           (0x3ul << GPIO_PMD_PMD8_Pos)
N
N#define GPIO_PMD_PMD7_Pos           14
N#define GPIO_PMD_PMD7_Msk           (0x3ul << GPIO_PMD_PMD7_Pos)
N
N#define GPIO_PMD_PMD6_Pos           12
N#define GPIO_PMD_PMD6_Msk           (0x3ul << GPIO_PMD_PMD6_Pos)
N
N#define GPIO_PMD_PMD5_Pos           10
N#define GPIO_PMD_PMD5_Msk           (0x3ul << GPIO_PMD_PMD5_Pos)
N
N#define GPIO_PMD_PMD4_Pos           8
N#define GPIO_PMD_PMD4_Msk           (0x3ul << GPIO_PMD_PMD4_Pos)
N
N#define GPIO_PMD_PMD3_Pos           6
N#define GPIO_PMD_PMD3_Msk           (0x3ul << GPIO_PMD_PMD3_Pos)
N
N#define GPIO_PMD_PMD2_Pos           4
N#define GPIO_PMD_PMD2_Msk           (0x3ul << GPIO_PMD_PMD2_Pos)
N
N#define GPIO_PMD_PMD1_Pos           2
N#define GPIO_PMD_PMD1_Msk           (0x3ul << GPIO_PMD_PMD1_Pos)
N
N#define GPIO_PMD_PMD0_Pos           0
N#define GPIO_PMD_PMD0_Msk           (0x3ul << GPIO_PMD_PMD0_Pos)
N
N/* GPIO OFFD Bit Field Definitions */
N#define GPIO_OFFD_Pos               16
N#define GPIO_OFFD_Msk               (0xFFFFul << GPIO_OFFD_Pos)
N
N/* GPIO DOUT Bit Field Definitions */
N#define GPIO_DOUT_Pos               0
N#define GPIO_DOUT_Msk               (0xFFFFul << GPIO_DOUT_Pos)
N
N/* GPIO DMASK Bit Field Definitions */
N#define GPIO_DMASK_Pos              0
N#define GPIO_DMASK_Msk              (0xFFFFul << GPIO_DMASK_Pos)
N
N/* GPIO PIN Bit Field Definitions */
N#define GPIO_PIN_Pos                0
N#define GPIO_PIN_Msk                (0xFFFFul << GPIO_PIN_Pos)
N
N/* GPIO DBEN Bit Field Definitions */
N#define GPIO_DBEN_Pos               0
N#define GPIO_DBEN_Msk               (0xFFFFul << GPIO_DBEN_Pos)
N
N/* GPIO IMD Bit Field Definitions */
N#define GPIO_IMD_Pos                0
N#define GPIO_IMD_Msk                (0xFFFFul << GPIO_IMD_Pos)
N
N/* GPIO IEN Bit Field Definitions */
N#define GPIO_IEN_IR_EN_Pos          16
N#define GPIO_IEN_IR_EN_Msk          (0xFFFFul << GPIO_IEN_IR_EN_Pos)
N
N#define GPIO_IEN_IF_EN_Pos          0
N#define GPIO_IEN_IF_EN_Msk          (0xFFFFul << GPIO_IEN_IF_EN_Pos)
N
N/* GPIO ISRC Bit Field Definitions */
N#define GPIO_ISRC_Pos               0
N#define GPIO_ISRC_Msk               (0xFFFFul << GPIO_ISRC_Pos)
N
N/* GPIO DBNCECON Bit Field Definitions */
N#define GPIO_DBNCECON_ICLK_ON_Pos   5
N#define GPIO_DBNCECON_ICLK_ON_Msk   (1ul << GPIO_DBNCECON_ICLK_ON_Pos)
N
N#define GPIO_DBNCECON_DBCLKSRC_Pos  4
N#define GPIO_DBNCECON_DBCLKSRC_Msk  (1ul << GPIO_DBNCECON_DBCLKSRC_Pos)
N
N#define GPIO_DBNCECON_DBCLKSEL_Pos  0
N#define GPIO_DBNCECON_DBCLKSEL_Msk  (0xFul << GPIO_DBNCECON_DBCLKSEL_Pos)
N
N/* GPIO Port[x] Pin I/O Bit Output/Input Control Bit Field Definitions */
N#define GPIO_GPIOx_DOUT_Pos         0
N#define GPIO_GPIOx_DOUT_Msk         (1ul << GPIO_GPIOx_DOUT_Pos)
N
N/*------------------------- UART Interface Controller ------------------------*/
N
Ntypedef __IO uint32_t UART_DATA_T;
Xtypedef volatile uint32_t UART_DATA_T;
N
N
Ntypedef struct
N{
N    __IO uint32_t  RDA_IEN:1;
X    volatile uint32_t  RDA_IEN:1;
N    __IO uint32_t  THRE_IEN:1;
X    volatile uint32_t  THRE_IEN:1;
N    __IO uint32_t  RLS_IEN:1;
X    volatile uint32_t  RLS_IEN:1;
N    __IO uint32_t  MODEM_IEN:1;
X    volatile uint32_t  MODEM_IEN:1;
N    __IO uint32_t  RTO_IEN:1;     
X    volatile uint32_t  RTO_IEN:1;     
N    __IO uint32_t  BUF_ERR_IEN:1;
X    volatile uint32_t  BUF_ERR_IEN:1;
N    __IO uint32_t  WAKE_EN:1;
X    volatile uint32_t  WAKE_EN:1;
N    __I  uint32_t  RESERVE0:1;
X    volatile const  uint32_t  RESERVE0:1;
N    __IO uint32_t  LIN_RX_BRK_IEN:1;
X    volatile uint32_t  LIN_RX_BRK_IEN:1;
N    __I  uint32_t  RESERVE1:2;
X    volatile const  uint32_t  RESERVE1:2;
N    __IO uint32_t  TIME_OUT_EN:1;      /* Time-out counter enable */
X    volatile uint32_t  TIME_OUT_EN:1;       
N    __IO uint32_t  AUTO_RTS_EN:1;
X    volatile uint32_t  AUTO_RTS_EN:1;
N    __IO uint32_t  AUTO_CTS_EN:1;
X    volatile uint32_t  AUTO_CTS_EN:1;
N    __IO uint32_t  DMA_TX_EN:1;
X    volatile uint32_t  DMA_TX_EN:1;
N    __IO uint32_t  DMA_RX_EN:1;
X    volatile uint32_t  DMA_RX_EN:1;
N    __I  uint32_t  RESERVE2:16;    
X    volatile const  uint32_t  RESERVE2:16;    
N    
N} UART_IER_T;
N
Ntypedef struct
N{
N    __I  uint32_t  RESERVE0:1;
X    volatile const  uint32_t  RESERVE0:1;
N    __IO uint32_t  RFR:1;
X    volatile uint32_t  RFR:1;
N    __IO uint32_t  TFR:1;
X    volatile uint32_t  TFR:1;
N    __I  uint32_t  RESERVE1:1;
X    volatile const  uint32_t  RESERVE1:1;
N    __IO uint32_t  RFITL:4;             /* Rx FIFO Interrupt Trigger Level */
X    volatile uint32_t  RFITL:4;              
N    __IO uint32_t  RX_DIS:1;
X    volatile uint32_t  RX_DIS:1;
N    __I  uint32_t  RESERVE2:7;
X    volatile const  uint32_t  RESERVE2:7;
N    __IO uint32_t  RTS_TRI_LEV:4;
X    volatile uint32_t  RTS_TRI_LEV:4;
N    __I  uint32_t  RESERVE3:12;
X    volatile const  uint32_t  RESERVE3:12;
N} UART_FCR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  WLS:2;               /* Word length select */
X    volatile uint32_t  WLS:2;                
N    __IO uint32_t  NSB:1;               /* Number of STOP bit */
X    volatile uint32_t  NSB:1;                
N    __IO uint32_t  PBE:1;               /* Parity bit enable  */
X    volatile uint32_t  PBE:1;                
N    __IO uint32_t  EPE:1;               /* Even parity enable */
X    volatile uint32_t  EPE:1;                
N    __IO uint32_t  SPE:1;               /* Stick parity enable*/
X    volatile uint32_t  SPE:1;                
N    __IO uint32_t  BCB:1;               /* Break control bit  */
X    volatile uint32_t  BCB:1;                
N    __I  uint32_t  RESERVE:25;
X    volatile const  uint32_t  RESERVE:25;
N} UART_LCR_T;
N
Ntypedef struct
N{
N    __I  uint32_t  RESERVE0:1;
X    volatile const  uint32_t  RESERVE0:1;
N    __IO uint32_t  RTS:1;
X    volatile uint32_t  RTS:1;
N    __I  uint32_t  RESERVE1:2;
X    volatile const  uint32_t  RESERVE1:2;
N    __IO uint32_t  LBME:1;
X    volatile uint32_t  LBME:1;
N    __I  uint32_t  RESERVE2:4;
X    volatile const  uint32_t  RESERVE2:4;
N    __IO uint32_t  LEV_RTS:1;
X    volatile uint32_t  LEV_RTS:1;
N    __I  uint32_t  RESERVE3:3;
X    volatile const  uint32_t  RESERVE3:3;
N    __I  uint32_t  RTS_ST:1;               /* RTS status */
X    volatile const  uint32_t  RTS_ST:1;                
N    __I  uint32_t  RESERVE4:18;
X    volatile const  uint32_t  RESERVE4:18;
N} UART_MCR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  DCTSF:1;
X    volatile uint32_t  DCTSF:1;
N    __I  uint32_t  RESERVE0:3;
X    volatile const  uint32_t  RESERVE0:3;
N    __I  uint32_t  CTS_ST:1;               /* CTS status */
X    volatile const  uint32_t  CTS_ST:1;                
N    __I  uint32_t  RESERVE1:3;
X    volatile const  uint32_t  RESERVE1:3;
N    __IO uint32_t  LEV_CTS:1;
X    volatile uint32_t  LEV_CTS:1;
N    __I  uint32_t  RESERVE2:23;
X    volatile const  uint32_t  RESERVE2:23;
N} UART_MSR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  RX_OVER_IF:1;
X    volatile uint32_t  RX_OVER_IF:1;
N    __I  uint32_t  RESERVE0:2;
X    volatile const  uint32_t  RESERVE0:2;
N    __IO uint32_t  RS485_ADD_DETF:1;
X    volatile uint32_t  RS485_ADD_DETF:1;
N    __IO uint32_t  PEF:1;
X    volatile uint32_t  PEF:1;
N    __IO uint32_t  FEF:1;
X    volatile uint32_t  FEF:1;
N    __IO uint32_t  BIF:1;
X    volatile uint32_t  BIF:1;
N    __I  uint32_t  RESERVE1:1;
X    volatile const  uint32_t  RESERVE1:1;
N    __I  uint32_t  RX_POINTER:6;
X    volatile const  uint32_t  RX_POINTER:6;
N    __I  uint32_t  RX_EMPTY:1;
X    volatile const  uint32_t  RX_EMPTY:1;
N    __I  uint32_t  RX_FULL:1;
X    volatile const  uint32_t  RX_FULL:1;
N    __I  uint32_t  TX_POINTER:6;
X    volatile const  uint32_t  TX_POINTER:6;
N    __I  uint32_t  TX_EMPTY:1;
X    volatile const  uint32_t  TX_EMPTY:1;
N    __I  uint32_t  TX_FULL:1;
X    volatile const  uint32_t  TX_FULL:1;
N    __IO uint32_t  TX_OVER_IF:1;
X    volatile uint32_t  TX_OVER_IF:1;
N    __I  uint32_t  RESERVE2:3;
X    volatile const  uint32_t  RESERVE2:3;
N    __I  uint32_t  TE_FLAG:1;                /* Transmitter empty flag */
X    volatile const  uint32_t  TE_FLAG:1;                 
N    __I  uint32_t  RESERVE3:3;
X    volatile const  uint32_t  RESERVE3:3;
N} UART_FSR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  RDA_IF:1;
X    volatile uint32_t  RDA_IF:1;
N    __IO uint32_t  THRE_IF:1;
X    volatile uint32_t  THRE_IF:1;
N    __IO uint32_t  RLS_IF:1;
X    volatile uint32_t  RLS_IF:1;
N    __IO uint32_t  MODEM_IF:1;
X    volatile uint32_t  MODEM_IF:1;
N    __IO uint32_t  TOUT_IF:1;
X    volatile uint32_t  TOUT_IF:1;
N    __IO uint32_t  BUF_ERR_IF:1;
X    volatile uint32_t  BUF_ERR_IF:1;
N    __I  uint32_t  RESERVE0:1;
X    volatile const  uint32_t  RESERVE0:1;
N    __IO uint32_t  LIN_RX_BREAK_IF:1;
X    volatile uint32_t  LIN_RX_BREAK_IF:1;
N
N    __IO uint32_t  RDA_INT:1;
X    volatile uint32_t  RDA_INT:1;
N    __IO uint32_t  THRE_INT:1;
X    volatile uint32_t  THRE_INT:1;
N    __IO uint32_t  RLS_INT:1;
X    volatile uint32_t  RLS_INT:1;
N    __IO uint32_t  MODEM_INT:1;
X    volatile uint32_t  MODEM_INT:1;
N    __IO uint32_t  TOUT_INT:1;
X    volatile uint32_t  TOUT_INT:1;
N    __IO uint32_t  BUF_ERR_INT:1;
X    volatile uint32_t  BUF_ERR_INT:1;
N    __I  uint32_t  RESERVE1:1;
X    volatile const  uint32_t  RESERVE1:1;
N    __IO uint32_t  LIN_RX_BREAK_INT:1;
X    volatile uint32_t  LIN_RX_BREAK_INT:1;
N
N    __I  uint32_t  RESERVE2:2;
X    volatile const  uint32_t  RESERVE2:2;
N    __IO uint32_t  HW_RLS_IF:1;
X    volatile uint32_t  HW_RLS_IF:1;
N    __IO uint32_t  HW_MODEM_IF:1;
X    volatile uint32_t  HW_MODEM_IF:1;
N    __IO uint32_t  HW_TOUT_IF:1;
X    volatile uint32_t  HW_TOUT_IF:1;
N    __IO uint32_t  HW_BUF_ERR_IF:1;
X    volatile uint32_t  HW_BUF_ERR_IF:1;
N    __IO uint32_t  RESERVE3:1;
X    volatile uint32_t  RESERVE3:1;
N    __IO uint32_t  HW_LIN_RX_BREAK_IF:1;
X    volatile uint32_t  HW_LIN_RX_BREAK_IF:1;
N
N    __I  uint32_t  RESERVE4:2;
X    volatile const  uint32_t  RESERVE4:2;
N    __IO uint32_t  HW_RLS_INT:1;
X    volatile uint32_t  HW_RLS_INT:1;
N    __IO uint32_t  HW_MODEM_INT:1;
X    volatile uint32_t  HW_MODEM_INT:1;
N    __IO uint32_t  HW_TOUT_INT:1;
X    volatile uint32_t  HW_TOUT_INT:1;
N    __IO uint32_t  HW_BUF_ERR_INT:1;
X    volatile uint32_t  HW_BUF_ERR_INT:1;
N    __IO uint32_t  RESERVE5:1;
X    volatile uint32_t  RESERVE5:1;
N    __IO uint32_t  HW_LIN_RX_BREAK_INT:1;
X    volatile uint32_t  HW_LIN_RX_BREAK_INT:1;
N} UART_ISR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  TOIC:7;
X    volatile uint32_t  TOIC:7;
N    __I  uint32_t  RESERVE0:1;
X    volatile const  uint32_t  RESERVE0:1;
N    __IO uint32_t  DLY:8;
X    volatile uint32_t  DLY:8;
N    __I  uint32_t  RESERVE1:16;
X    volatile const  uint32_t  RESERVE1:16;
N
N} UART_TOR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  BRD:16;
X    volatile uint32_t  BRD:16;
N    __I  uint32_t  RESERVE0:8;
X    volatile const  uint32_t  RESERVE0:8;
N    __IO uint32_t  DIVIDER_X:4;
X    volatile uint32_t  DIVIDER_X:4;
N    __IO uint32_t  DIV_X_ONE:1;            
X    volatile uint32_t  DIV_X_ONE:1;            
N    __IO uint32_t  DIV_X_EN:1;            
X    volatile uint32_t  DIV_X_EN:1;            
N    __I  uint32_t  RESERVE1:2;
X    volatile const  uint32_t  RESERVE1:2;
N} UART_BAUD_T;
N
Ntypedef struct
N{
N    __I  uint32_t  RESERVE0:1;
X    volatile const  uint32_t  RESERVE0:1;
N    __IO uint32_t  TX_SELECT:1;
X    volatile uint32_t  TX_SELECT:1;
N    __I  uint32_t  RESERVE1:3;
X    volatile const  uint32_t  RESERVE1:3;
N    __IO uint32_t  INV_TX:1;            
X    volatile uint32_t  INV_TX:1;            
N    __IO uint32_t  INV_RX:1;
X    volatile uint32_t  INV_RX:1;
N    __I  uint32_t  RESERVE2:25;
X    volatile const  uint32_t  RESERVE2:25;
N} UART_IRCR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  LIN_BKFL:4;
X    volatile uint32_t  LIN_BKFL:4;
N    __I  uint32_t  RESERVE0:2;
X    volatile const  uint32_t  RESERVE0:2;
N    __IO uint32_t  LIN_RX_EN:1;
X    volatile uint32_t  LIN_RX_EN:1;
N    __IO uint32_t  LIN_TX_EN:1;            
X    volatile uint32_t  LIN_TX_EN:1;            
N    __IO uint32_t  RS485_NMM:1;
X    volatile uint32_t  RS485_NMM:1;
N    __IO uint32_t  RS485_AAD:1;
X    volatile uint32_t  RS485_AAD:1;
N    __IO uint32_t  RS485_AUD:1;
X    volatile uint32_t  RS485_AUD:1;
N    __I  uint32_t  RESERVE1:4;
X    volatile const  uint32_t  RESERVE1:4;
N    __IO uint32_t  RS485_ADD_EN:1;
X    volatile uint32_t  RS485_ADD_EN:1;
N    __I  uint32_t  RESERVE2:8;
X    volatile const  uint32_t  RESERVE2:8;
N    __IO uint32_t  ADDR_MATCH:8;
X    volatile uint32_t  ADDR_MATCH:8;
N} UART_ALTCON_T;
N
N
N
Ntypedef struct
N{
N    __IO uint32_t  FUN_SEL:2;
X    volatile uint32_t  FUN_SEL:2;
N    __I  uint32_t  RESERVE0:30;
X    volatile const  uint32_t  RESERVE0:30;
N
N} UART_FUNSEL_T;
N
N
Ntypedef struct
N{
N    
N    union {
N        __IO uint32_t u32DATA;
X        volatile uint32_t u32DATA;
N        __IO uint32_t DATA;
X        volatile uint32_t DATA;
N    };
N    union {
N        __IO uint32_t u32IER;
X        volatile uint32_t u32IER;
N        struct {
N            __IO uint32_t  RDA_IEN:1;
X            volatile uint32_t  RDA_IEN:1;
N            __IO uint32_t  THRE_IEN:1;
X            volatile uint32_t  THRE_IEN:1;
N            __IO uint32_t  RLS_IEN:1;
X            volatile uint32_t  RLS_IEN:1;
N            __IO uint32_t  MODEM_IEN:1;
X            volatile uint32_t  MODEM_IEN:1;
N            __IO uint32_t  RTO_IEN:1;          
X            volatile uint32_t  RTO_IEN:1;          
N            __IO uint32_t  BUF_ERR_IEN:1;        
X            volatile uint32_t  BUF_ERR_IEN:1;        
N            __IO uint32_t  WAKE_EN:1;
X            volatile uint32_t  WAKE_EN:1;
N            __I  uint32_t  RESERVE0:1; 
X            volatile const  uint32_t  RESERVE0:1; 
N            __IO uint32_t  LIN_RX_BRK_IEN:1;
X            volatile uint32_t  LIN_RX_BRK_IEN:1;
N            __I  uint32_t  RESERVE1:2;
X            volatile const  uint32_t  RESERVE1:2;
N            __IO uint32_t  TIME_OUT_EN:1;
X            volatile uint32_t  TIME_OUT_EN:1;
N            __IO uint32_t  AUTO_RTS_EN:1;
X            volatile uint32_t  AUTO_RTS_EN:1;
N            __IO uint32_t  AUTO_CTS_EN:1;
X            volatile uint32_t  AUTO_CTS_EN:1;
N            __IO uint32_t  DMA_TX_EN:1;
X            volatile uint32_t  DMA_TX_EN:1;
N            __IO uint32_t  DMA_RX_EN:1;
X            volatile uint32_t  DMA_RX_EN:1;
N            __I  uint32_t  RESERVE2:16;
X            volatile const  uint32_t  RESERVE2:16;
N        } IER;
N    };
N
N    union {
N        __IO uint32_t u32FCR;
X        volatile uint32_t u32FCR;
N        struct {
N            __I  uint32_t  RESERVE0:1;
X            volatile const  uint32_t  RESERVE0:1;
N            __IO uint32_t  RFR:1;
X            volatile uint32_t  RFR:1;
N            __IO uint32_t  TFR:1;
X            volatile uint32_t  TFR:1;
N            __IO uint32_t  RESERVE1:1;
X            volatile uint32_t  RESERVE1:1;
N            __IO uint32_t  RFITL:4;          
X            volatile uint32_t  RFITL:4;          
N            __IO uint32_t  RX_DIS:1; 
X            volatile uint32_t  RX_DIS:1; 
N            __I  uint32_t  RESERVE2 :7;
X            volatile const  uint32_t  RESERVE2 :7;
N            __IO uint32_t  RTS_TRI_LEV:4;
X            volatile uint32_t  RTS_TRI_LEV:4;
N            __I  uint32_t  RESERVE3 :4;
X            volatile const  uint32_t  RESERVE3 :4;
N        } FCR;
N    };
N
N    union {
N        __IO uint32_t u32LCR;
X        volatile uint32_t u32LCR;
N        struct {
N            __IO uint32_t  WLS:2;
X            volatile uint32_t  WLS:2;
N            __IO uint32_t  NSB:1;
X            volatile uint32_t  NSB:1;
N            __IO uint32_t  PBE:1;
X            volatile uint32_t  PBE:1;
N            __IO uint32_t  EPE:1;
X            volatile uint32_t  EPE:1;
N            __IO uint32_t  SPE:1;          
X            volatile uint32_t  SPE:1;          
N            __IO uint32_t  BCB:1; 
X            volatile uint32_t  BCB:1; 
N            __I  uint32_t  RESERVE :25;
X            volatile const  uint32_t  RESERVE :25;
N        } LCR;
N    };
N
N    union {
N        __IO uint32_t u32MCR;
X        volatile uint32_t u32MCR;
N        struct {
N            __I  uint32_t  RESERVE0:1;
X            volatile const  uint32_t  RESERVE0:1;
N            __IO uint32_t  RTS:1;
X            volatile uint32_t  RTS:1;
N            __I  uint32_t  RESERVE1:7;
X            volatile const  uint32_t  RESERVE1:7;
N            __IO uint32_t  LEV_RTS:1;
X            volatile uint32_t  LEV_RTS:1;
N            __I  uint32_t  RESERVE2:3;          
X            volatile const  uint32_t  RESERVE2:3;          
N            __IO uint32_t  RTS_ST:1; 
X            volatile uint32_t  RTS_ST:1; 
N            __I  uint32_t  RESERVE3:18;
X            volatile const  uint32_t  RESERVE3:18;
N        } MCR;
N    };
N
N
N    union {
N        __IO uint32_t u32MSR;
X        volatile uint32_t u32MSR;
N        struct {
N            __IO uint32_t  DCTSF:1;
X            volatile uint32_t  DCTSF:1;
N            __I  uint32_t  RESERVE0:3;
X            volatile const  uint32_t  RESERVE0:3;
N            __IO uint32_t  CTS_ST:1;
X            volatile uint32_t  CTS_ST:1;
N            __I  uint32_t  RESERVE1:3;
X            volatile const  uint32_t  RESERVE1:3;
N            __IO uint32_t  LEV_CTS:1;          
X            volatile uint32_t  LEV_CTS:1;          
N            __I  uint32_t  RESERVE2:23;
X            volatile const  uint32_t  RESERVE2:23;
N        } MSR;
N    };
N
N
N    union {
N        __IO uint32_t u32FSR;
X        volatile uint32_t u32FSR;
N        struct {
N            __IO uint32_t  RX_OVER_IF:1;
X            volatile uint32_t  RX_OVER_IF:1;
N            __I  uint32_t  RESERVE0:2;
X            volatile const  uint32_t  RESERVE0:2;
N            __IO uint32_t  RS485_ADD_DETF:1;
X            volatile uint32_t  RS485_ADD_DETF:1;
N            __IO uint32_t  PEF:1;
X            volatile uint32_t  PEF:1;
N            __IO uint32_t  FEF:1;
X            volatile uint32_t  FEF:1;
N            __IO uint32_t  BIF:1;
X            volatile uint32_t  BIF:1;
N            __I  uint32_t  RESERVE1:1;
X            volatile const  uint32_t  RESERVE1:1;
N            __IO uint32_t  RX_POINTER:6;
X            volatile uint32_t  RX_POINTER:6;
N            __IO uint32_t  RX_EMPTY:1;
X            volatile uint32_t  RX_EMPTY:1;
N            __IO uint32_t  RX_FULL:1;
X            volatile uint32_t  RX_FULL:1;
N            __IO uint32_t  TX_POINTER:6;
X            volatile uint32_t  TX_POINTER:6;
N            __IO uint32_t  TX_EMPTY:1;
X            volatile uint32_t  TX_EMPTY:1;
N            __IO uint32_t  TX_FULL:1;
X            volatile uint32_t  TX_FULL:1;
N            __IO uint32_t  TX_OVER_IF:1;
X            volatile uint32_t  TX_OVER_IF:1;
N            __I  uint32_t  RESERVE2:3;
X            volatile const  uint32_t  RESERVE2:3;
N            __IO uint32_t  TE_FLAG:1;
X            volatile uint32_t  TE_FLAG:1;
N            __I  uint32_t  RESERVE3:3;
X            volatile const  uint32_t  RESERVE3:3;
N        } FSR;
N    };
N
N    union {
N        __IO uint32_t u32ISR;
X        volatile uint32_t u32ISR;
N        struct {
N            __IO uint32_t  RDA_IF:1;
X            volatile uint32_t  RDA_IF:1;
N            __IO uint32_t  THRE_IF:1;
X            volatile uint32_t  THRE_IF:1;
N            __IO uint32_t  RLS_IF:1;
X            volatile uint32_t  RLS_IF:1;
N            __IO uint32_t  MODEM_IF:1;
X            volatile uint32_t  MODEM_IF:1;
N            __IO uint32_t  TOUT_IF:1;
X            volatile uint32_t  TOUT_IF:1;
N            __IO uint32_t  BUF_ERR_IF:1;
X            volatile uint32_t  BUF_ERR_IF:1;
N            __I  uint32_t  RESERVE0:1;
X            volatile const  uint32_t  RESERVE0:1;
N            __IO uint32_t  LIN_RX_BREAK_IF:1;
X            volatile uint32_t  LIN_RX_BREAK_IF:1;
N            __IO uint32_t  RDA_INT:1;
X            volatile uint32_t  RDA_INT:1;
N            __IO uint32_t  THRE_INT:1;
X            volatile uint32_t  THRE_INT:1;
N            __IO uint32_t  RLS_INT:1;
X            volatile uint32_t  RLS_INT:1;
N            __IO uint32_t  MODEM_INT:1;
X            volatile uint32_t  MODEM_INT:1;
N            __IO uint32_t  TOUT_INT:1;
X            volatile uint32_t  TOUT_INT:1;
N            __IO uint32_t  BUF_ERR_INT:1;
X            volatile uint32_t  BUF_ERR_INT:1;
N            __I  uint32_t  RESERVE1:1;
X            volatile const  uint32_t  RESERVE1:1;
N            __IO uint32_t  LIN_RX_BREAK_INT:1;
X            volatile uint32_t  LIN_RX_BREAK_INT:1;
N            __I  uint32_t  RESERVE2:2;
X            volatile const  uint32_t  RESERVE2:2;
N            __IO uint32_t  HW_RLS_IF:1;
X            volatile uint32_t  HW_RLS_IF:1;
N            __IO uint32_t  HW_MODEM_IF:1;
X            volatile uint32_t  HW_MODEM_IF:1;
N            __IO uint32_t  HW_TOUT_IF:1;
X            volatile uint32_t  HW_TOUT_IF:1;
N            __IO uint32_t  HW_BUF_ERR_IF:1;
X            volatile uint32_t  HW_BUF_ERR_IF:1;
N            __I  uint32_t  RESERVE3:1;
X            volatile const  uint32_t  RESERVE3:1;
N            __IO uint32_t  HW_LIN_RX_BREAK_IF:1;
X            volatile uint32_t  HW_LIN_RX_BREAK_IF:1;
N            __I  uint32_t  RESERVE4:2;
X            volatile const  uint32_t  RESERVE4:2;
N            __IO uint32_t  HW_RLS_INT:1;
X            volatile uint32_t  HW_RLS_INT:1;
N            __IO uint32_t  HW_MODEM_INT:1;
X            volatile uint32_t  HW_MODEM_INT:1;
N            __IO uint32_t  HW_TOUT_INT:1;
X            volatile uint32_t  HW_TOUT_INT:1;
N            __IO uint32_t  HW_BUF_ERR_INT:1;
X            volatile uint32_t  HW_BUF_ERR_INT:1;
N            __I  uint32_t  RESERVE5:1;
X            volatile const  uint32_t  RESERVE5:1;
N            __IO uint32_t  HW_LIN_RX_BREAK_INT:1;
X            volatile uint32_t  HW_LIN_RX_BREAK_INT:1;
N
N        } ISR;
N    };
N
N    union {
N        __IO uint32_t u32TOR;
X        volatile uint32_t u32TOR;
N        struct {
N            __IO uint32_t  TOIC:8;
X            volatile uint32_t  TOIC:8;
N            __IO uint32_t  DLY:8;
X            volatile uint32_t  DLY:8;
N            __I  uint32_t  RESERVE1:16;
X            volatile const  uint32_t  RESERVE1:16;
N        } TOR;
N    };
N
N    union {
N        __IO uint32_t u32BAUD;
X        volatile uint32_t u32BAUD;
N        struct {
N            __IO uint32_t  BRD:16;
X            volatile uint32_t  BRD:16;
N            __I  uint32_t  RESERVE0:8;
X            volatile const  uint32_t  RESERVE0:8;
N            __IO uint32_t  DIVIDER_X:4;
X            volatile uint32_t  DIVIDER_X:4;
N            __IO uint32_t  DIV_X_ONE:1;
X            volatile uint32_t  DIV_X_ONE:1;
N            __IO uint32_t  DIV_X_EN:1;
X            volatile uint32_t  DIV_X_EN:1;
N            __I  uint32_t  RESERVE1:2;
X            volatile const  uint32_t  RESERVE1:2;
N        } BAUD;
N    };
N
N    union {
N        __IO uint32_t u32IRCR;
X        volatile uint32_t u32IRCR;
N        struct {
N            __I  uint32_t  RESERVE0:1;
X            volatile const  uint32_t  RESERVE0:1;
N            __IO uint32_t  TX_SELECT:1;
X            volatile uint32_t  TX_SELECT:1;
N            __I  uint32_t  RESERVE1:3;
X            volatile const  uint32_t  RESERVE1:3;
N            __IO uint32_t  INV_TX:1;
X            volatile uint32_t  INV_TX:1;
N            __IO uint32_t  INV_RX:1;
X            volatile uint32_t  INV_RX:1;
N            __I  uint32_t  RESERVE2:25;
X            volatile const  uint32_t  RESERVE2:25;
N        } IRCR;
N    };
N
N    union {
N        __IO uint32_t u32ALTCON;
X        volatile uint32_t u32ALTCON;
N        struct {
N            __IO uint32_t  LIN_BKFL:4;
X            volatile uint32_t  LIN_BKFL:4;
N            __I  uint32_t  RESERVE0:2;
X            volatile const  uint32_t  RESERVE0:2;
N            __IO uint32_t  LIN_RX_EN:1;
X            volatile uint32_t  LIN_RX_EN:1;
N            __IO uint32_t  LIN_TX_EN:1;
X            volatile uint32_t  LIN_TX_EN:1;
N            __IO uint32_t  RS485_NMM:1;
X            volatile uint32_t  RS485_NMM:1;
N            __IO uint32_t  RS485_AAD:1;
X            volatile uint32_t  RS485_AAD:1;
N            __IO uint32_t  RS485_AUD:1;
X            volatile uint32_t  RS485_AUD:1;
N            __I  uint32_t  RESERVE1:4;
X            volatile const  uint32_t  RESERVE1:4;
N            __IO uint32_t  RS485_ADD_EN :1;
X            volatile uint32_t  RS485_ADD_EN :1;
N            __I  uint32_t  RESERVE2 :8;
X            volatile const  uint32_t  RESERVE2 :8;
N            __IO uint32_t  ADDR_MATCH :8;
X            volatile uint32_t  ADDR_MATCH :8;
N        } ALTCON;
N    };
N
N
N    union {
N        __IO uint32_t u32FUNSEL;
X        volatile uint32_t u32FUNSEL;
N        struct {
N            __IO uint32_t  FUN_SEL:2;
X            volatile uint32_t  FUN_SEL:2;
N            __I  uint32_t  RESERVE0:30;
X            volatile const  uint32_t  RESERVE0:30;
N        } FUNSEL;
N    };
N} UART_T;
N
N
N
N
N/* UART THR Bit Field Definitions */
N#define UART_THR_THR_Pos         0
N#define UART_THR_THR_Msk        (0xFul << UART_THR_THR_Pos)
N
N/* UART RBR Bit Field Definitions */
N#define UART_RBR_RBR_Pos         0
N#define UART_RBR_RBR_Msk        (0xFul << UART_RBR_RBR_Pos)
N
N/* UART IER Bit Field Definitions */
N#define UART_IER_DMA_RX_EN_Pos      15
N#define UART_IER_DMA_RX_EN_Msk      (1ul << UART_IER_DMA_RX_EN_Pos)
N
N#define UART_IER_DMA_TX_EN_Pos      14
N#define UART_IER_DMA_TX_EN_Msk      (1ul << UART_IER_DMA_TX_EN_Pos)
N
N#define UART_IER_AUTO_CTS_EN_Pos    13
N#define UART_IER_AUTO_CTS_EN_Msk    (1ul << UART_IER_AUTO_CTS_EN_Pos)
N
N#define UART_IER_AUTO_RTS_EN_Pos    12
N#define UART_IER_AUTO_RTS_EN_Msk    (1ul << UART_IER_AUTO_RTS_EN_Pos)
N
N#define UART_IER_TIME_OUT_EN_Pos    11
N#define UART_IER_TIME_OUT_EN_Msk    (1ul << UART_IER_TIME_OUT_EN_Pos)
N
N#define UART_IER_LIN_RX_BRK_IEN_Pos 8
N#define UART_IER_LIN_RX_BRK_IEN_Msk (1ul << UART_IER_LIN_RX_BRK_IEN_Pos)
N
N#define UART_IER_WAKE_EN_Pos        6
N#define UART_IER_WAKE_EN_Msk        (1ul << UART_IER_WAKE_EN_Pos)
N
N#define UART_IER_BUF_ERR_IEN_Pos    5
N#define UART_IER_BUF_ERR_IEN_Msk    (1ul << UART_IER_BUF_ERR_IEN_Pos)
N
N#define UART_IER_RTO_IEN_Pos        4
N#define UART_IER_RTO_IEN_Msk        (1ul << UART_IER_RTO_IEN_Pos)
N
N#define UART_IER_MODEM_IEN_Pos      3
N#define UART_IER_MODEM_IEN_Msk      (1ul << UART_IER_MODEM_IEN_Pos)
N
N#define UART_IER_RLS_IEN_Pos        2
N#define UART_IER_RLS_IEN_Msk        (1ul << UART_IER_RLS_IENN_Pos)
N
N#define UART_IER_THRE_IEN_Pos       1
N#define UART_IER_THRE_IEN_Msk       (1ul << UART_IER_THRE_IEN_Pos)
N
N#define UART_IER_RDA_IEN_Pos        0
N#define UART_IER_RDA_IEN_Msk        (1ul << UART_IER_RDA_IEN_Pos)
N
N/* UART FCR Bit Field Definitions */
N#define UART_FCR_RTS_TRI_LEV_Pos    16
N#define UART_FCR_RTS_TRI_LEV_Msk    (0xFul << UART_FCR_RTS_TRI_LEV_Pos)
N
N#define UART_FCR_RX_DIS_Pos         8
N#define UART_FCR_RX_DIS_Msk         (1ul << UART_FCR_RX_DIS_Pos)
N
N#define UART_FCR_RFITL_Pos          4
N#define UART_FCR_RFITL_Msk          (0xFul << UART_FCR_RFITL_Pos)
N
N#define UART_FCR_TFR_Pos            2
N#define UART_FCR_TFR_Msk            (1ul << UART_FCR_TFR_Pos)
N
N#define UART_FCR_RFR_Pos            1
N#define UART_FCR_RFR_Msk            (1ul << UART_FCR_RFR_Pos)
N
N/* UART LCR Bit Field Definitions */
N#define UART_LCR_BCB_Pos            6
N#define UART_LCR_BCB_Msk            (1ul << UART_LCR_BCB_Pos)
N
N#define UART_LCR_SPE_Pos            5
N#define UART_LCR_SPE_Msk            (1ul << UART_LCR_SPE_Pos)
N
N#define UART_LCR_EPE_Pos            4
N#define UART_LCR_EPE_Msk            (1ul << UART_LCR_EPE_Pos)
N
N#define UART_LCR_PBE_Pos            3
N#define UART_LCR_PBE_Msk            (1ul << UART_LCR_PBE_Pos)
N
N#define UART_LCR_NSB_Pos            2
N#define UART_LCR_NSB_Msk            (1ul << UART_LCR_NSB_Pos)
N
N#define UART_LCR_WLS_Pos            0
N#define UART_LCR_WLS_Msk            (0x3ul << UART_LCR_WLS_Pos)
N
N/* UART MCR Bit Field Definitions */
N#define UART_MCR_RTS_ST_Pos         13
N#define UART_MCR_RTS_ST_Msk         (1ul << UART_MCR_RTS_ST_Pos)
N
N#define UART_MCR_LEV_RTS_Pos        9
N#define UART_MCR_LEV_RTS_Msk        (1ul << UART_MCR_LEV_RTS_Pos)
N
N#define UART_MCR_RTS_Pos            1
N#define UART_MCR_RTS_Msk            (1ul << UART_MCR_RTS_Pos)
N
N
N/* UART MSR Bit Field Definitions */
N#define UART_MSR_LEV_CTS_Pos        8
N#define UART_MSR_LEV_CTS_Msk        (1ul << UART_MSR_LEV_CTS_Pos)
N
N#define UART_MSR_CTS_ST_Pos         4
N#define UART_MSR_CTS_ST_Msk         (1ul << UART_MSR_CTS_ST_Pos)
N
N#define UART_MSR_DCTSF_Pos          0
N#define UART_MSR_DCTSF_Msk          (1ul << UART_MSR_DCTSF_Pos)
N
N
N/* UART FSR Bit Field Definitions */
N#define UART_FSR_TE_FLAG_Pos        28
N#define UART_FSR_TE_FLAG_Msk        (1ul << UART_FSR_TE_FLAG_Pos)
N
N#define UART_FSR_TX_OVER_IF_Pos     24
N#define UART_FSR_TX_OVER_IF_Msk     (1ul << UART_FSR_TX_OVER_IF_Pos)
N
N#define UART_FSR_TX_FULL_Pos        23
N#define UART_FSR_TX_FULL_Msk        (1ul << UART_FSR_TX_FULL_Pos)
N
N#define UART_FSR_TX_EMPTY_Pos       22
N#define UART_FSR_TX_EMPTY_Msk       (1ul << UART_FSR_TX_EMPTY_Pos)
N
N#define UART_FSR_TX_POINTER_Pos     16
N#define UART_FSR_TX_POINTER_Msk     (0x3Ful << UART_FSR_TX_POINTER_Pos)
N
N#define UART_FSR_RX_FULL_Pos        15
N#define UART_FSR_RX_FULL_Msk        (1ul << UART_FSR_RX_FULL_Pos)
N
N#define UART_FSR_RX_EMPTY_Pos       14
N#define UART_FSR_RX_EMPTY_Msk       (1ul << UART_FSR_RX_EMPTY_Pos)
N
N#define UART_FSR_RX_POINTER_Pos     8
N#define UART_FSR_RX_POINTER_Msk     (0x3Ful << UART_FSR_RX_POINTER_Pos)
N
N#define UART_FSR_BIF_Pos            6
N#define UART_FSR_BIF_Msk            (1ul << UART_FSR_BIF_Pos)
N
N#define UART_FSR_FEF_Pos            5
N#define UART_FSR_FEF_Msk            (1ul << UART_FSR_FEF_Pos)
N
N#define UART_FSR_PEF_Pos            4
N#define UART_FSR_PEF_Msk            (1ul << UART_FSR_PEF_Pos)
N
N#define UART_FSR_RS485_ADD_DETF_Pos 3
N#define UART_FSR_RS485_ADD_DETF_Msk (1ul << UART_FSR_RS485_ADD_DETF_Pos)
N
N#define UART_FSR_RX_OVER_IF_Pos     0
N#define UART_FSR_RX_OVER_IF_Msk     (1ul << UART_FSR_RX_OVER_IF_Pos)
N
N/* UART ISR Bit Field Definitions */
N#define UART_ISR_HW_LIN_RX_BREAK_INT_Pos   31
N#define UART_ISR_HW_LIN_RX_BREAK_INT_Msk   (1ul << UART_ISR_HW_LIN_RX_BREAK_INT_Pos)
N
N#define UART_ISR_HW_BUF_ERR_INT_Pos        29
N#define UART_ISR_HW_BUF_ERR_INT_Msk        (1ul << UART_ISR_HW_BUF_ERR_INT_Pos)
N
N#define UART_ISR_HW_TOUT_INT_Pos           28
N#define UART_ISR_HW_TOUT_INT_Msk           (1ul << UART_ISR_HW_TOUT_INT_Pos)
N
N#define UART_ISR_HW_MODEM_INT_Pos          27
N#define UART_ISR_HW_MODEM_INT_Msk          (1ul << UART_ISR_HW_MODEM_INT_Pos)
N
N#define UART_ISR_HW_RLS_INT_Pos            26
N#define UART_ISR_HW_RLS_INT_Msk            (1ul << UART_ISR_HW_RLS_INT_Pos)
N
N#define UART_ISR_HW_LIN_RX_BREAK_IF_Pos    23
N#define UART_ISR_HW_LIN_RX_BREAK_IF_Msk    (1ul << UART_ISR_HW_LIN_RX_BREAK_IF_Pos)
N
N#define UART_ISR_HW_BUF_ERR_IF_Pos         21
N#define UART_ISR_HW_BUF_ERR_IF_Msk         (1ul << UART_ISR_HW_BUF_ERR_IF_Pos)
N
N#define UART_ISR_HW_TOUT_IF_Pos            20
N#define UART_ISR_HW_TOUT_IF_Msk            (1ul << UART_ISR_HW_TOUT_IFF_Pos)
N
N#define UART_ISR_HW_MODEM_IF_Pos           19
N#define UART_ISR_HW_MODEM_IF_Msk           (1ul << UART_ISR_HW_MODEM_IF_Pos)
N
N#define UART_ISR_HW_RLS_IF_Pos             18
N#define UART_ISR_HW_RLS_IF_Msk             (1ul << UART_ISR_HW_RLS_IF_Pos)
N
N#define UART_ISR_LIN_RX_BREAK_INT_Pos      15
N#define UART_ISR_LIN_RX_BREAK_INT_Msk      (1ul << UART_ISR_LIN_RX_BREAK_INT_Pos)
N
N#define UART_ISR_BUF_ERR_INT_Pos           13
N#define UART_ISR_BUF_ERR_INT_Msk           (1ul << UART_ISR_BUF_ERR_INT_Pos)
N
N#define UART_ISR_TOUT_INT_Pos              12
N#define UART_ISR_TOUT_INT_Msk              (1ul << UART_ISR_TOUT_INT_Pos)
N
N#define UART_ISR_MODEM_INT_Pos             11    
N#define UART_ISR_MODEM_INT_Msk             (1ul << UART_ISR_MODEM_INT_Pos)
N
N#define UART_ISR_RLS_INT_Pos               10    
N#define UART_ISR_RLS_INT_Msk               (1ul << UART_ISR_RLS_INT_Pos)
N
N#define UART_ISR_THRE_INT_Pos              9    
N#define UART_ISR_THRE_INT_Msk              (1ul << UART_ISR_THRE_INT_Pos)
N
N#define UART_ISR_RDA_INT_Pos               8    
N#define UART_ISR_RDA_INT_Msk               (1ul << UART_ISR_RDA_INT_Pos)
N
N#define UART_ISR_LIN_RX_BREAK_IF_Pos       7    
N#define UART_ISR_LIN_RX_BREAK_IF_Msk       (1ul << UART_ISR_LIN_RX_BREAK_IF_Pos)
N
N#define UART_ISR_BUF_ERR_IF_Pos            5    
N#define UART_ISR_BUF_ERR_IF_Msk            (1ul << UART_ISR_BUF_ERR_IF_Pos)
N
N#define UART_ISR_TOUT_IF_Pos               4    
N#define UART_ISR_TOUT_IF_Msk               (1ul << UART_ISR_TOUT_IF_Pos)
N
N#define UART_ISR_MODEM_IF_Pos              3    
N#define UART_ISR_MODEM_IF_Msk              (1ul << UART_ISR_MODEM_IF_Pos)
N
N#define UART_ISR_RLS_IF_Pos                2    
N#define UART_ISR_RLS_IF_Msk                (1ul << UART_ISR_RLS_IF_Pos)
N
N#define UART_ISR_THRE_IF_Pos               1    
N#define UART_ISR_THRE_IF_Msk               (1ul << UART_ISR_THRE_IF_Pos)
N
N#define UART_ISR_RDA_IF_Pos                0    
N#define UART_ISR_RDA_IF_Msk                (1ul << UART_ISR_RDA_IF_Pos)
N
N
N/* UART TOR Bit Field Definitions */
N#define UART_TOR_DLY_Pos          8
N#define UART_TOR_DLY_Msk          (0xFFul << UART_TOR_DLY_Pos)
N
N#define UART_TOR_TOIC_Pos         0
N#define UART_TOR_TOIC_Msk         (0xFFul << UART_TOR_TOIC_Pos)
N
N/* UART BAUD Bit Field Definitions */
N#define UART_BAUD_DIV_X_EN_Pos    29
N#define UART_BAUD_DIV_X_EN_Msk    (1ul << UART_BAUD_DIV_X_EN_Pos)
N
N#define UART_BAUD_DIV_X_ONE_Pos   28
N#define UART_BAUD_DIV_X_ONE_Msk   (1ul << UART_BAUD_DIV_X_ONE_Pos)
N
N#define UART_BAUD_DIVIDER_X_Pos   24
N#define UART_BAUD_DIVIDER_X_Msk   (0xFul << UART_BAUD_DIVIDER_X_Pos)
N
N#define UART_BAUD_BRD_Pos         0
N#define UART_BAUD_BRD_Msk         (0xFFul << UART_BAUD_BRD_Pos)
N
N/* UART IRCR Bit Field Definitions */
N#define UART_IRCR_INV_RX_Pos      6
N#define UART_IRCR_INV_RX_Msk     (1ul << UART_IRCR_INV_RX_Pos)
N
N#define UART_IRCR_INV_TX_Pos      5
N#define UART_IRCR_INV_TX_Msk     (1ul << UART_IRCR_INV_TX_Pos)
N
N#define UART_IRCR_TX_SELECT_Pos   1
N#define UART_IRCR_TX_SELECT_Msk   (1ul << UART_IRCR_TX_SELECT_Pos)
N
N/* UART ALT_CSR Bit Field Definitions */
N#define UART_ALT_CSR_ADDR_MATCH_Pos      24
N#define UART_ALT_CSR_ADDR_MATCH_Msk     (0xFFul << UART_ALT_CSR_ADDR_MATCH_Pos)
N
N#define UART_ALT_CSR_RS485_ADD_EN_Pos   15
N#define UART_ALT_CSR_RS485_ADD_EN_Msk   (1ul << UART_ALT_CSR_RS485_ADD_EN_Pos)
N
N#define UART_ALT_CSR_RS485_AUD_Pos      10
N#define UART_ALT_CSR_RS485_AUD_Msk      (1ul << UART_ALT_CSR_RS485_AUD_Pos)
N
N#define UART_ALT_CSR_RS485_AAD_Pos      9
N#define UART_ALT_CSR_RS485_AAD_Msk      (1ul << UART_ALT_CSR_RS485_AAD_Pos)
N
N#define UART_ALT_CSR_RS485_NMM_Pos      8
N#define UART_ALT_CSR_RS485_NMM_Msk      (1ul << UART_ALT_CSR_RS485_NMM_Pos)
N
N#define UART_ALT_CSR_LIN_TX_EN_Pos      7
N#define UART_ALT_CSR_LIN_TX_EN_Msk      (1ul << UART_ALT_CSR_LIN_TX_EN_Pos)
N
N#define UART_ALT_CSR_LIN_RX_EN_Pos      6
N#define UART_ALT_CSR_LIN_RX_EN_Msk      (1ul << UART_ALT_CSR_LIN_RX_EN_Pos)
N
N#define UART_ALT_CSR_LIN_BKFL_Pos       0
N#define UART_ALT_CSR_LIN_BKFL_Msk       (0xFul << UART_ALT_CSR_LIN_BKFL_Pos)
N
N/* UART FUN_SEL Bit Field Definitions */
N#define UART_FUN_SEL_FUN_SEL_Pos        0
N#define UART_FUN_SEL_FUN_SEL_Msk       (0x3ul << UART_FUN_SEL_FUN_SEL_Pos)
N
N
N/*----------------------------- Timer Controller -----------------------------*/
Ntypedef struct
N{
N    __IO uint32_t  PRESCALE:8;
X    volatile uint32_t  PRESCALE:8;
N    __I  uint32_t  RESERVE0:8;
X    volatile const  uint32_t  RESERVE0:8;
N    __IO uint32_t  TDR_EN:1;
X    volatile uint32_t  TDR_EN:1;
N    __I  uint32_t  RESERVE1:7;
X    volatile const  uint32_t  RESERVE1:7;
N    __IO uint32_t  CTB:1;          
X    volatile uint32_t  CTB:1;          
N    __IO uint32_t  CACT:1;        
X    volatile uint32_t  CACT:1;        
N    __IO uint32_t  CRST:1;
X    volatile uint32_t  CRST:1;
N    __IO uint32_t  MODE:2;
X    volatile uint32_t  MODE:2;
N    __IO uint32_t  IE:1;
X    volatile uint32_t  IE:1;
N    __IO uint32_t  CEN:1;
X    volatile uint32_t  CEN:1;
N    __IO uint32_t  DBGACK_TMR:1;
X    volatile uint32_t  DBGACK_TMR:1;
N} TIMER_TCSR_T;
N
Ntypedef __IO uint32_t TIMER_TCMPR_T;
Xtypedef volatile uint32_t TIMER_TCMPR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  TIF:1;
X    volatile uint32_t  TIF:1;
N    __I  uint32_t  RESERVE:31;
X    volatile const  uint32_t  RESERVE:31;
N} TIMER_TISR_T;
N
Ntypedef __IO uint32_t TIMER_TDR_T;
Xtypedef volatile uint32_t TIMER_TDR_T;
N
Ntypedef __IO uint32_t TIMER_TCAP_T;
Xtypedef volatile uint32_t TIMER_TCAP_T;
N
Ntypedef struct
N{
N    __IO uint32_t  TX_PHASE:1;
X    volatile uint32_t  TX_PHASE:1;
N    __IO uint32_t  TEX_EDGE:2;
X    volatile uint32_t  TEX_EDGE:2;
N    __IO uint32_t  TEXEN:1;
X    volatile uint32_t  TEXEN:1;
N    __IO uint32_t  RSTCAPSEL:1;
X    volatile uint32_t  RSTCAPSEL:1;
N    __IO uint32_t  TEXIEN:1;
X    volatile uint32_t  TEXIEN:1;
N    __IO uint32_t  TEXDB:1;
X    volatile uint32_t  TEXDB:1;
N    __IO uint32_t  TCDB:1;
X    volatile uint32_t  TCDB:1;
N    __I  uint32_t  RESERVE:24;
X    volatile const  uint32_t  RESERVE:24;
N} TIMER_TEXCON_T;
N
Ntypedef struct
N{
N    __IO uint32_t  TEXIF:1;
X    volatile uint32_t  TEXIF:1;
N    __I  uint32_t  RESERVE:31;
X    volatile const  uint32_t  RESERVE:31;
N} TIMER_TEXISR;
N
Ntypedef struct
N{
N    union {
N        __IO uint32_t u32TCSR;
X        volatile uint32_t u32TCSR;
N        struct {
N            __IO uint32_t  PRESCALE:8;
X            volatile uint32_t  PRESCALE:8;
N            __I  uint32_t  RESERVE0:8;
X            volatile const  uint32_t  RESERVE0:8;
N            __IO uint32_t  TDR_EN:1;
X            volatile uint32_t  TDR_EN:1;
N            __I  uint32_t  RESERVE1:7;
X            volatile const  uint32_t  RESERVE1:7;
N            __IO uint32_t  CTB:1;          
X            volatile uint32_t  CTB:1;          
N            __IO uint32_t  CACT:1;        
X            volatile uint32_t  CACT:1;        
N            __IO uint32_t  CRST:1;
X            volatile uint32_t  CRST:1;
N            __IO uint32_t  MODE:2;
X            volatile uint32_t  MODE:2;
N            __IO uint32_t  IE:1;
X            volatile uint32_t  IE:1;
N            __IO uint32_t  CEN:1;
X            volatile uint32_t  CEN:1;
N            __IO uint32_t  DBGACK_TMR:1;
X            volatile uint32_t  DBGACK_TMR:1;
N        } TCSR;
N    };
N
N    union {
N        __IO uint32_t u32TCMPR;
X        volatile uint32_t u32TCMPR;
N        __IO uint32_t TCMPR;
X        volatile uint32_t TCMPR;
N    };
N
N    union {
N        __IO uint32_t u32TISR;
X        volatile uint32_t u32TISR;
N        struct {
N            __IO uint32_t  TIF:1;
X            volatile uint32_t  TIF:1;
N            __I  uint32_t  RESERVE:31;
X            volatile const  uint32_t  RESERVE:31;
N        } TISR;
N    };
N
N    union {
N        __IO uint32_t u32TDR;
X        volatile uint32_t u32TDR;
N        __IO uint32_t TDR;
X        volatile uint32_t TDR;
N    };
N
N    union {
N        __IO uint32_t u32TCAP;
X        volatile uint32_t u32TCAP;
N        __IO uint32_t TCAP;
X        volatile uint32_t TCAP;
N    };
N
N    union {
N        __IO uint32_t u32TEXCON;
X        volatile uint32_t u32TEXCON;
N        struct {
N            __IO uint32_t  TX_PHASE:1;
X            volatile uint32_t  TX_PHASE:1;
N            __IO uint32_t  TEX_EDGE:2;
X            volatile uint32_t  TEX_EDGE:2;
N            __IO uint32_t  TEXEN:1;
X            volatile uint32_t  TEXEN:1;
N            __IO uint32_t  RSTCAPSEL:1;
X            volatile uint32_t  RSTCAPSEL:1;
N            __IO uint32_t  TEXIEN:1;
X            volatile uint32_t  TEXIEN:1;
N            __IO uint32_t  TEXDB:1;
X            volatile uint32_t  TEXDB:1;
N            __IO uint32_t  TCDB:1;
X            volatile uint32_t  TCDB:1;
N            __I  uint32_t  RESERVE:24;
X            volatile const  uint32_t  RESERVE:24;
N        } TEXCON;
N    };
N
N    union {
N        __IO uint32_t u32TEXISR;
X        volatile uint32_t u32TEXISR;
N        struct {
N            __IO uint32_t  TEXIF:1;
X            volatile uint32_t  TEXIF:1;
N            __I  uint32_t  RESERVE:31;
X            volatile const  uint32_t  RESERVE:31;
N        } TEXISR;
N    };
N} TIMER_T;
N
N/* Timer TCSR Bit Field Definitions */
N#define TIMER_TCSR_DBGACK_TMR_Pos   31
N#define TIMER_TCSR_DBGACK_TMR_Msk   (1ul << TIMER_TCSR_DBGACK_TMR_Pos)
N
N#define TIMER_TCSR_CEN_Pos          30
N#define TIMER_TCSR_CEN_Msk          (1ul << TIMER_TCSR_CEN_Pos)
N
N#define TIMER_TCSR_IE_Pos           29
N#define TIMER_TCSR_IE_Msk           (1ul << TIMER_TCSR_IE_Pos)
N
N#define TIMER_TCSR_MODE_Pos         27
N#define TIMER_TCSR_MODE_Msk         (0x3ul << TIMER_TCSR_MODE_Pos)
N
N#define TIMER_TCSR_CRST_Pos         26
N#define TIMER_TCSR_CRST_Msk         (1ul << TIMER_TCSR_CRST_Pos)
N
N#define TIMER_TCSR_CACT_Pos         25
N#define TIMER_TCSR_CACT_Msk         (1ul << TIMER_TCSR_CACT_Pos)
N
N#define TIMER_TCSR_CTB_Pos          24
N#define TIMER_TCSR_CTB_Msk          (1ul << TIMER_TCSR_CTB_Pos)
N
N#define TIMER_TCSR_TDR_EN_Pos       16
N#define TIMER_TCSR_TDR_EN_Msk       (1ul << TIMER_TCSR_TDR_EN_Pos)
N
N#define TIMER_TCSR_PRESCALE_Pos     0
N#define TIMER_TCSR_PRESCALE_Msk     (0xFFul << TIMER_TCSR_PRESCALE_Pos)
N
N/* Timer TCMPR Bit Field Definitions */
N#define TIMER_TCMP_Pos              0
N#define TIMER_TCMP_Msk              (0xFFFFFFul << TIMER_TCMP_Pos)
N
N/* Timer TISR Bit Field Definitions */
N#define TIMER_TISR_TIF_Pos          0
N#define TIMER_TISR_TIF_Msk          (1ul << TIMER_TISR_TIF_Pos)
N
N/* Timer TDR Bit Field Definitions */
N#define TIMER_TDR_Pos               0
N#define TIMER_TDR_Msk               (0xFFFFFFul << TIMER_TDR_Pos)
N
N/* Timer TCAP Bit Field Definitions */
N#define TIMER_TCAP_Pos              0
N#define TIMER_TCAP_Msk              (0xFFFFFFul << TIMER_TCAP_Pos)
N
N/* Timer TEXCON Bit Field Definitions */
N#define TIMER_TEXCON_TCDB_Pos       7
N#define TIMER_TEXCON_TCDB_Msk       (1ul << TIMER_TEXCON_TCDB_Pos)
N
N#define TIMER_TEXCON_TEXDB_Pos      6
N#define TIMER_TEXCON_TEXDB_Msk      (1ul << TIMER_TEXCON_TEXDB_Pos)
N
N#define TIMER_TEXCON_TEXIEN_Pos     5
N#define TIMER_TEXCON_TEXIEN_Msk     (1ul << TIMER_TEXCON_TEXIEN_Pos)
N
N#define TIMER_TEXCON_RSTCAPSEL_Pos  4
N#define TIMER_TEXCON_RSTCAPSEL_Msk  (1ul << TIMER_TEXCON_RSTCAPSEL_Pos)
N
N#define TIMER_TEXCON_TEXEN_Pos      3
N#define TIMER_TEXCON_TEXEN_Msk      (1ul << TIMER_TEXCON_TEXEN_Pos)
N
N#define TIMER_TEXCON_TEX_EDGE_Pos   1
N#define TIMER_TEXCON_TEX_EDGE_Msk   (0x3ul << TIMER_TEXCON_TEX_EDGE_Pos)
N
N#define TIMER_TEXCON_TX_PHASE_Pos   0
N#define TIMER_TEXCON_TX_PHASE_Msk   (1ul << TIMER_TEXCON_TX_PHASE_Pos)
N
N/* Timer TEXISR Bit Field Definitions */
N#define TIMER_TEXISR_TEXIF_Pos      0
N#define TIMER_TEXISR_TEXIF_Msk      (1ul << TIMER_TEXISR_TEXIF_Pos)
N
N
N/*----------------------------- WDT Controller -----------------------------*/
Ntypedef struct
N{
N    __IO uint32_t  WTR:1;
X    volatile uint32_t  WTR:1;
N    __IO uint32_t  WTRE:1;
X    volatile uint32_t  WTRE:1;
N    __IO uint32_t  WTRF:1;
X    volatile uint32_t  WTRF:1;
N    __IO uint32_t  WTIF:1;
X    volatile uint32_t  WTIF:1;
N    __IO uint32_t  WTWKE:1;
X    volatile uint32_t  WTWKE:1;
N    __IO uint32_t  WTWKF:1;
X    volatile uint32_t  WTWKF:1;
N    __IO uint32_t  WTIE:1;
X    volatile uint32_t  WTIE:1;
N    __IO uint32_t  WTE:1;
X    volatile uint32_t  WTE:1;
N    __IO uint32_t  WTIS:3;
X    volatile uint32_t  WTIS:3;
N    __I  uint32_t  RESERVE1:20;
X    volatile const  uint32_t  RESERVE1:20;
N    __IO uint32_t  DBGACK_WDT:1;
X    volatile uint32_t  DBGACK_WDT:1;
N} WDT_WTCR_T;
N
Ntypedef struct
N{
N    union {
N        __IO uint32_t u32WTCR;
X        volatile uint32_t u32WTCR;
N        struct {
N            __IO uint32_t  WTR:1;
X            volatile uint32_t  WTR:1;
N            __IO uint32_t  WTRE:1;
X            volatile uint32_t  WTRE:1;
N            __IO uint32_t  WTRF:1;
X            volatile uint32_t  WTRF:1;
N            __IO uint32_t  WTIF:1;
X            volatile uint32_t  WTIF:1;
N            __IO uint32_t  WTWKE:1;
X            volatile uint32_t  WTWKE:1;
N            __IO uint32_t  WTWKF:1;
X            volatile uint32_t  WTWKF:1;
N            __IO uint32_t  WTIE:1;
X            volatile uint32_t  WTIE:1;
N            __IO uint32_t  WTE:1;
X            volatile uint32_t  WTE:1;
N            __IO uint32_t  WTIS:3;
X            volatile uint32_t  WTIS:3;
N            __I  uint32_t  RESERVE1:20;
X            volatile const  uint32_t  RESERVE1:20;
N            __IO uint32_t  DBGACK_WDT:1;
X            volatile uint32_t  DBGACK_WDT:1;
N        } WTCR;
N    };
N} WDT_T;
N
N/* WDT WTCR Bit Field Definitions */
N#define WDT_WTCR_DBGACK_WDT_Pos 31
N#define WDT_WTCR_DBGACK_WDT_Msk (1ul << WDT_WTCR_DBGACK_WDT_Pos)
N
N#define WDT_WTCR_WTIS_Pos       8  
N#define WDT_WTCR_WTIS_Msk       (0x3ul << WDT_WTCR_WTIS_Pos)
N
N#define WDT_WTCR_WTE_Pos        7  
N#define WDT_WTCR_WTE_Msk        (1ul << WDT_WTCR_WTE_Pos)
N
N#define WDT_WTCR_WTIE_Pos       6  
N#define WDT_WTCR_WTIE_Msk       (1ul << WDT_WTCR_WTIE_Pos)
N
N#define WDT_WTCR_WTWKF_Pos      5  
N#define WDT_WTCR_WTWKF_Msk      (1ul << WDT_WTCR_WTWKF_Pos)
N
N#define WDT_WTCR_WTWKE_Pos      4  
N#define WDT_WTCR_WTWKE_Msk      (1ul << WDT_WTCR_WTWKE_Pos)
N
N#define WDT_WTCR_WTIF_Pos       3  
N#define WDT_WTCR_WTIF_Msk       (1ul << WDT_WTCR_WTIF_Pos)
N
N#define WDT_WTCR_WTRF_Pos       2  
N#define WDT_WTCR_WTRF_Msk       (1ul << WDT_WTCR_WTRF_Pos)
N
N#define WDT_WTCR_WTRE_Pos       1  
N#define WDT_WTCR_WTRE_Msk       (1ul << WDT_WTCR_WTRE_Pos)
N
N#define WDT_WTCR_WTR_Pos        0  
N#define WDT_WTCR_WTR_Msk        (1ul << WDT_WTCR_WTR_Pos)
N
N
N/*------------------------- SPI Interface Controller -------------------------*/
Ntypedef struct
N{
N    __IO uint32_t  GO_BUSY:1;
X    volatile uint32_t  GO_BUSY:1;
N    __IO uint32_t  RX_NEG:1;
X    volatile uint32_t  RX_NEG:1;
N    __IO uint32_t  TX_NEG:1;
X    volatile uint32_t  TX_NEG:1;
N    __IO uint32_t  TX_BIT_LEN:5;
X    volatile uint32_t  TX_BIT_LEN:5;
N    __IO uint32_t  TX_NUM:2;
X    volatile uint32_t  TX_NUM:2;
N    __IO uint32_t  LSB:1;
X    volatile uint32_t  LSB:1;
N    __IO uint32_t  CLKP:1;
X    volatile uint32_t  CLKP:1;
N    __IO uint32_t  SP_CYCLE:4;
X    volatile uint32_t  SP_CYCLE:4;
N    __IO uint32_t  IF:1;
X    volatile uint32_t  IF:1;
N    __IO uint32_t  IE:1;
X    volatile uint32_t  IE:1;
N    __IO uint32_t  SLAVE:1;
X    volatile uint32_t  SLAVE:1;
N    __IO uint32_t  REORDER:2;
X    volatile uint32_t  REORDER:2;
N    __IO uint32_t  FIFO:1;
X    volatile uint32_t  FIFO:1;
N    __IO uint32_t  TWOB:1;
X    volatile uint32_t  TWOB:1;
N    __IO uint32_t  VARCLK_EN:1;
X    volatile uint32_t  VARCLK_EN:1;
N    __I  uint32_t  RX_EMPTY:1;
X    volatile const  uint32_t  RX_EMPTY:1;
N    __I  uint32_t  RX_FULL:1;
X    volatile const  uint32_t  RX_FULL:1;
N    __I  uint32_t  TX_EMPTY:1;
X    volatile const  uint32_t  TX_EMPTY:1;
N    __I  uint32_t  TX_FULL:1;
X    volatile const  uint32_t  TX_FULL:1;
N    __I  uint32_t  RESERVE:4;
X    volatile const  uint32_t  RESERVE:4;
N} SPI_CNTRL_T;
N
Ntypedef struct
N{
N    __IO uint32_t  DIVIDER:16;
X    volatile uint32_t  DIVIDER:16;
N    __IO uint32_t  DIVIDER2:16;
X    volatile uint32_t  DIVIDER2:16;
N} SPI_DIVIDER_T;
N
Ntypedef struct
N{
N    __IO uint32_t  SSR:2;
X    volatile uint32_t  SSR:2;
N    __IO uint32_t  SS_LVL:1;
X    volatile uint32_t  SS_LVL:1;
N    __IO uint32_t  AUTOSS:1;
X    volatile uint32_t  AUTOSS:1;
N    __IO uint32_t  SS_LTRIG:1;
X    volatile uint32_t  SS_LTRIG:1;
N    __I  uint32_t  LTRIG_FLAG:1;
X    volatile const  uint32_t  LTRIG_FLAG:1;
N    __I  uint32_t  RESERVE:26;
X    volatile const  uint32_t  RESERVE:26;
N} SPI_SSR_T;
N
N
Ntypedef __I  uint32_t   SPI_RX_T;
Xtypedef volatile const  uint32_t   SPI_RX_T;
Ntypedef __O  uint32_t   SPI_TX_T;
Xtypedef volatile  uint32_t   SPI_TX_T;
Ntypedef __IO uint32_t   SPI_VARCLK_T;
Xtypedef volatile uint32_t   SPI_VARCLK_T;
N
Ntypedef struct
N{
N    __IO uint32_t  TX_DMA_GO:1;
X    volatile uint32_t  TX_DMA_GO:1;
N    __IO uint32_t  RX_DMA_GO:1;
X    volatile uint32_t  RX_DMA_GO:1;
N    __I  uint32_t  RESERVE:30;
X    volatile const  uint32_t  RESERVE:30;
N} SPI_DMA_T;
N
Ntypedef struct
N{
N    __IO uint32_t  DIV_ONE:1;
X    volatile uint32_t  DIV_ONE:1;
N    __I  uint32_t  RESERVE0:7;
X    volatile const  uint32_t  RESERVE0:7;
N    __IO uint32_t  NOSLVSEL:1;
X    volatile uint32_t  NOSLVSEL:1;
N    __IO uint32_t  SLV_ABORT:1;
X    volatile uint32_t  SLV_ABORT:1;
N    __IO uint32_t  SSTA_INTEN:1;
X    volatile uint32_t  SSTA_INTEN:1;
N    __IO uint32_t  SLV_START_INTSTS:1;
X    volatile uint32_t  SLV_START_INTSTS:1;
N    __I  uint32_t  RESERVE1:20;
X    volatile const  uint32_t  RESERVE1:20;
N} SPI_CNTRL2_T;
N
Ntypedef struct
N{
N    __IO uint32_t  RX_CLR:1;
X    volatile uint32_t  RX_CLR:1;
N    __IO uint32_t  TX_CLR:1;
X    volatile uint32_t  TX_CLR:1;
N    __I  uint32_t  RESERVE0:30;
X    volatile const  uint32_t  RESERVE0:30;
N} SPI_FIFO_CTL_T;
N
Ntypedef struct
N{
N    union {
N        __IO uint32_t u32CNTRL;
X        volatile uint32_t u32CNTRL;
N        struct {
N            __IO uint32_t  GO_BUSY:1;
X            volatile uint32_t  GO_BUSY:1;
N            __IO uint32_t  RX_NEG:1;
X            volatile uint32_t  RX_NEG:1;
N            __IO uint32_t  TX_NEG:1;
X            volatile uint32_t  TX_NEG:1;
N            __IO uint32_t  TX_BIT_LEN:5;
X            volatile uint32_t  TX_BIT_LEN:5;
N            __IO uint32_t  TX_NUM:2;
X            volatile uint32_t  TX_NUM:2;
N            __IO uint32_t  LSB:1;
X            volatile uint32_t  LSB:1;
N            __IO uint32_t  CLKP:1;
X            volatile uint32_t  CLKP:1;
N            __IO uint32_t  SP_CYCLE:4;
X            volatile uint32_t  SP_CYCLE:4;
N            __IO uint32_t  IF:1;
X            volatile uint32_t  IF:1;
N            __IO uint32_t  IE:1;
X            volatile uint32_t  IE:1;
N            __IO uint32_t  SLAVE:1;
X            volatile uint32_t  SLAVE:1;
N            __IO uint32_t  REORDER:2;
X            volatile uint32_t  REORDER:2;
N            __IO uint32_t  FIFO:1;
X            volatile uint32_t  FIFO:1;
N            __IO uint32_t  TWOB:1;
X            volatile uint32_t  TWOB:1;
N            __IO uint32_t  VARCLK_EN:1;
X            volatile uint32_t  VARCLK_EN:1;
N            __I  uint32_t  RX_EMPTY:1;
X            volatile const  uint32_t  RX_EMPTY:1;
N            __I  uint32_t  RX_FULL:1;
X            volatile const  uint32_t  RX_FULL:1;
N            __I  uint32_t  TX_EMPTY:1;
X            volatile const  uint32_t  TX_EMPTY:1;
N            __I  uint32_t  TX_FULL:1;
X            volatile const  uint32_t  TX_FULL:1;
N            __I  uint32_t  RESERVE:4;
X            volatile const  uint32_t  RESERVE:4;
N        } CNTRL;
N    };
N
N    union {
N        __IO uint32_t u32DIVIDER;
X        volatile uint32_t u32DIVIDER;
N        struct {
N            __IO uint32_t  DIVIDER:16;
X            volatile uint32_t  DIVIDER:16;
N            __IO uint32_t  DIVIDER2:16;
X            volatile uint32_t  DIVIDER2:16;
N        } DIVIDER;
N    };
N
N    union {
N        __IO uint32_t u32SSR;
X        volatile uint32_t u32SSR;
N        struct {
N            __IO uint32_t  SSR:2;
X            volatile uint32_t  SSR:2;
N            __IO uint32_t  SS_LVL:1;
X            volatile uint32_t  SS_LVL:1;
N            __IO uint32_t  AUTOSS:1;
X            volatile uint32_t  AUTOSS:1;
N            __IO uint32_t  SS_LTRIG:1;
X            volatile uint32_t  SS_LTRIG:1;
N            __I  uint32_t  LTRIG_FLAG:1;
X            volatile const  uint32_t  LTRIG_FLAG:1;
N            __I  uint32_t  RESERVE:26;
X            volatile const  uint32_t  RESERVE:26;
N        } SSR;
N    };
N
N    __I uint32_t RESERVE0;
X    volatile const uint32_t RESERVE0;
N
N    union {
N        __I uint32_t u32RX[2];
X        volatile const uint32_t u32RX[2];
N        __I uint32_t RX[2];
X        volatile const uint32_t RX[2];
N    };
N
N    __I uint32_t RESERVE1;
X    volatile const uint32_t RESERVE1;
N    __I uint32_t RESERVE2;
X    volatile const uint32_t RESERVE2;
N
N    union {
N        __O uint32_t u32TX[2];
X        volatile uint32_t u32TX[2];
N        __O uint32_t TX[2];
X        volatile uint32_t TX[2];
N    };
N
N    __I uint32_t RESERVE3;
X    volatile const uint32_t RESERVE3;
N    __I uint32_t RESERVE4;
X    volatile const uint32_t RESERVE4;
N    __I uint32_t RESERVE5;
X    volatile const uint32_t RESERVE5;
N
N    union {
N        __IO uint32_t u32VARCLK;
X        volatile uint32_t u32VARCLK;
N        __IO uint32_t VARCLK;
X        volatile uint32_t VARCLK;
N    };
N
N    union {
N        __IO uint32_t u32DMA;
X        volatile uint32_t u32DMA;
N        struct {
N            __IO uint32_t  TX_DMA_GO:1;
X            volatile uint32_t  TX_DMA_GO:1;
N            __IO uint32_t  RX_DMA_GO:1;
X            volatile uint32_t  RX_DMA_GO:1;
N            __I  uint32_t  RESERVE:30;
X            volatile const  uint32_t  RESERVE:30;
N        } DMA;
N    };
N
N    union {
N        __IO uint32_t u32CNTRL2;
X        volatile uint32_t u32CNTRL2;
N        struct {
N            __IO uint32_t  DIV_ONE:1;
X            volatile uint32_t  DIV_ONE:1;
N            __I  uint32_t  RESERVE0:7;
X            volatile const  uint32_t  RESERVE0:7;
N            __IO uint32_t  NOSLVSEL:1;
X            volatile uint32_t  NOSLVSEL:1;
N            __IO uint32_t  SLV_ABORT:1;
X            volatile uint32_t  SLV_ABORT:1;
N            __IO uint32_t  SSTA_INTEN:1;
X            volatile uint32_t  SSTA_INTEN:1;
N            __IO uint32_t  SLV_START_INTSTS:1;
X            volatile uint32_t  SLV_START_INTSTS:1;
N            __I  uint32_t  RESERVE1:20;
X            volatile const  uint32_t  RESERVE1:20;
N        } CNTRL2;
N    };
N
N    union {
N        __IO uint32_t u32FIFO_CTL;
X        volatile uint32_t u32FIFO_CTL;
N        struct {
N            __IO uint32_t  RX_CLR:1;
X            volatile uint32_t  RX_CLR:1;
N            __IO uint32_t  TX_CLR:1;
X            volatile uint32_t  TX_CLR:1;
N            __I  uint32_t  RESERVE0:30;
X            volatile const  uint32_t  RESERVE0:30;
N        } FIFO_CTL;
N    };
N
N} SPI_T;
N
N
N/* SPI_CNTRL Bit Field Definitions */
N#define SPI_CNTRL_TX_FULL_Pos      27
N#define SPI_CNTRL_TX_FULL_Msk      (1ul << SPI_CNTRL_TX_FULL_Pos)
N
N#define SPI_CNTRL_TX_EMPTY_Pos     26
N#define SPI_CNTRL_TX_EMPTY_Msk     (1ul << SPI_CNTRL_TX_EMPTY_Pos)
N
N#define SPI_CNTRL_RX_FULL_Pos      25
N#define SPI_CNTRL_RX_FULL_Msk      (1ul << SPI_CNTRL_RX_FULL_Pos)
N
N#define SPI_CNTRL_RX_EMPTY_Pos     24
N#define SPI_CNTRL_RX_EMPTY_Msk     (1ul << SPI_CNTRL_RX_EMPTY_Pos)
N
N#define SPI_CNTRL_VARCLK_EN_Pos    23
N#define SPI_CNTRL_VARCLK_EN_Msk    (1ul << SPI_CNTRL_VARCLK_EN_Pos)
N
N#define SPI_CNTRL_TWOB_Pos         22
N#define SPI_CNTRL_TWOB_Msk         (1ul << SPI_CNTRL_TWOB_Pos)
N
N#define SPI_CNTRL_FIFO_Pos         21
N#define SPI_CNTRL_FIFO_Msk         (1ul << SPI_CNTRL_FIFO_Pos)
N
N#define SPI_CNTRL_REORDER_Pos      19
N#define SPI_CNTRL_REORDER_Msk      (3ul << SPI_CNTRL_REORDER_Pos)
N
N#define SPI_CNTRL_SLAVE_Pos        18
N#define SPI_CNTRL_SLAVE_Msk        (1ul << SPI_CNTRL_SLAVE_Pos)
N
N#define SPI_CNTRL_IE_Pos           17
N#define SPI_CNTRL_IE_Msk           (1ul << SPI_CNTRL_IE_Pos)
N
N#define SPI_CNTRL_IF_Pos           16
N#define SPI_CNTRL_IF_Msk           (1ul << SPI_CNTRL_IF_Pos)
N
N#define SPI_CNTRL_SP_CYCLE_Pos     12
N#define SPI_CNTRL_SP_CYCLE_Msk     (0xFul << SPI_CNTRL_SP_CYCLE_Pos)
N
N#define SPI_CNTRL_CLKP_Pos         11
N#define SPI_CNTRL_CLKP_Msk         (1ul << SPI_CNTRL_CLKP_Pos)
N
N#define SPI_CNTRL_LSB_Pos          10
N#define SPI_CNTRL_LSB_Msk          (1ul << SPI_CNTRL_LSB_Pos)
N
N#define SPI_CNTRL_TX_NUM_Pos       8
N#define SPI_CNTRL_TX_NUM_Msk       (3ul << SPI_CNTRL_TX_NUM_Pos)
N
N#define SPI_CNTRL_TX_BIT_LEN_Pos   3
N#define SPI_CNTRL_TX_BIT_LEN_Msk   (0x1Ful << SPI_CNTRL_TX_BIT_LEN_Pos)
N
N#define SPI_CNTRL_TX_NEG_Pos       2
N#define SPI_CNTRL_TX_NEG_Msk       (1ul << SPI_CNTRL_TX_NEG_Pos)
N
N#define SPI_CNTRL_RX_NEG_Pos       1
N#define SPI_CNTRL_RX_NEG_Msk       (1ul << SPI_CNTRL_RX_NEG_Pos)
N
N#define SPI_CNTRL_GO_BUSY_Pos      0
N#define SPI_CNTRL_GO_BUSY_Msk      (1ul << SPI_CNTRL_GO_BUSY_Pos)
N
N
N/* SPI_DIVIDER Bit Field Definitions */
N#define SPI_DIVIDER_DIVIDER2_Pos   16
N#define SPI_DIVIDER_DIVIDER2_Msk   (0xFFFFul << SPI_DIVIDER_DIVIDER2_Pos)
N
N#define SPI_DIVIDER_DIVIDER_Pos    0
N#define SPI_DIVIDER_DIVIDE2_Msk    (0xFFFFul << SPI_DIVIDER_DIVIDER_Pos)
N
N/* SPI_SSR Bit Field Definitions */
N#define SPI_SSR_LTRIG_FLAG_Pos     5
N#define SPI_SSR_LTRIG_FLAG_Msk     (1ul << SPI_SSR_LTRIG_FLAG_Pos)
N
N#define SPI_SSR_SS_LTRIG_Pos       4
N#define SPI_SSR_SS_LTRIG_Msk       (1ul << SPI_SSR_SS_LTRIG_Pos)
N
N#define SPI_SSR_AUTOSS_Pos         3
N#define SPI_SSR_AUTOSS_Msk         (1ul << SPI_SSR_AUTOSS_Pos)
N
N#define SPI_SSR_SS_LVL_Pos         2
N#define SPI_SSR_SS_LVL_Msk         (1ul << SPI_SSR_SS_LVL_Pos)
N
N#define SPI_SSR_SSR_Pos            0
N#define SPI_SSR_SSR_Msk            (3ul << SPI_SSR_SSR_Pos)
N
N/* SPI_DMA Bit Field Definitions */
N#define SPI_DMA_RX_DMA_GO_Pos   1
N#define SPI_DMA_RX_DMA_GO_Msk   (1ul << SPI_DMA_RX_DMA_GO_Pos)
N
N#define SPI_DMA_TX_DMA_GO_Pos   0
N#define SPI_DMA_TX_DMA_GO_Msk   (1ul << SPI_DMA_TX_DMA_GO_Pos)
N
N/* SPI_CNTRL2 Bit Field Definitions */
N#define SPI_CNTRL2_SLV_START_INTSTS_Pos   11
N#define SPI_CNTRL2_SLV_START_INTSTS_Msk   (1ul << SPI_CNTRL2_SLV_START_INTSTS_Pos)
N
N#define SPI_CNTRL2_SSTA_INTEN_Pos   10
N#define SPI_CNTRL2_SSTA_INTEN_Msk   (1ul << SPI_CNTRL2_SSTA_INTEN_Pos)
N
N#define SPI_CNTRL2_SLV_ABORT_Pos    9
N#define SPI_CNTRL2_SLV_ABORT_Msk    (1ul << SPI_CNTRL2_SLV_ABORT_Pos)
N
N#define SPI_CNTRL2_NOSLVSEL_Pos     8
N#define SPI_CNTRL2_NOSLVSEL_Msk     (1ul << SPI_CNTRL2_NOSLVSEL_Pos)
N
N#define SPI_CNTRL2_DIV_ONE_Pos      0
N#define SPI_CNTRL2_DIV_ONE_Msk      (1ul << SPI_CNTRL2_DIV_ONE_Pos)
N
N/* SPI_FIFO_CTL Bit Field Definitions */
N#define SPI_FIFO_CTL_TX_CLR_Pos   1
N#define SPI_FIFO_CTL_TX_CLR_Msk   (1ul << SPI_FIFO_CTL_TX_CLR_Pos)
N
N#define SPI_FIFO_CTL_RX_CLR_Pos   0
N#define SPI_FIFO_CTL_RX_CLR_Msk   (1ul << SPI_FIFO_CTL_RX_CLR_Pos)
N
N
N/*------------------------------ I2C Controller ------------------------------*/
Ntypedef struct
N{
N    __I  uint32_t  RESERVE0:2;
X    volatile const  uint32_t  RESERVE0:2;
N    __IO uint32_t  AA:1;
X    volatile uint32_t  AA:1;
N    __IO uint32_t  SI:1;
X    volatile uint32_t  SI:1;
N    __IO uint32_t  STO:1;
X    volatile uint32_t  STO:1;
N    __IO uint32_t  STA:1;
X    volatile uint32_t  STA:1;
N    __IO uint32_t  ENS1:1;
X    volatile uint32_t  ENS1:1;
N    __IO uint32_t  EI:1;
X    volatile uint32_t  EI:1;
N    __I  uint32_t  RESERVE1:24;
X    volatile const  uint32_t  RESERVE1:24;
N} I2C_I2CON_T;
N
Ntypedef struct
N{
N    __IO uint32_t  GC:1;
X    volatile uint32_t  GC:1;
N    __IO uint32_t  I2CADDR:7;
X    volatile uint32_t  I2CADDR:7;
N    __I  uint32_t  RESERVE:24;
X    volatile const  uint32_t  RESERVE:24;
N} I2C_I2CADDR_T;
N
Ntypedef __IO uint32_t I2C_I2CDAT_T;
Xtypedef volatile uint32_t I2C_I2CDAT_T;
N
Ntypedef __I  uint32_t I2C_I2CSTATUS_T;
Xtypedef volatile const  uint32_t I2C_I2CSTATUS_T;
N
Ntypedef __IO uint32_t I2C_I2CLK_T;
Xtypedef volatile uint32_t I2C_I2CLK_T;
N
Ntypedef struct
N{
N    __IO uint32_t  TIF:1;
X    volatile uint32_t  TIF:1;
N    __IO uint32_t  DIV4:1;
X    volatile uint32_t  DIV4:1;
N    __IO uint32_t  ENTI:1;
X    volatile uint32_t  ENTI:1;
N    __I  uint32_t  RESERVE:29;
X    volatile const  uint32_t  RESERVE:29;
N} I2C_I2CTOC_T;
N
Ntypedef struct
N{
N    __I  uint32_t  RESERVE0:1;
X    volatile const  uint32_t  RESERVE0:1;
N    __IO uint32_t  I2CADM:7;
X    volatile uint32_t  I2CADM:7;
N    __I  uint32_t  RESERVE1:24;
X    volatile const  uint32_t  RESERVE1:24;
N} I2C_I2CADM_T;
N
Ntypedef struct
N{
N    union 
N    {
N        __IO uint32_t u32I2CON;
X        volatile uint32_t u32I2CON;
N        
N        struct 
N        {
N            __I  uint32_t  RESERVE0:2;
X            volatile const  uint32_t  RESERVE0:2;
N            __IO uint32_t  AA:1;
X            volatile uint32_t  AA:1;
N            __IO uint32_t  SI:1;
X            volatile uint32_t  SI:1;
N            __IO uint32_t  STO:1;
X            volatile uint32_t  STO:1;
N            __IO uint32_t  STA:1;
X            volatile uint32_t  STA:1;
N            __IO uint32_t  ENS1:1;
X            volatile uint32_t  ENS1:1;
N            __IO uint32_t  EI:1;
X            volatile uint32_t  EI:1;
N            __I  uint32_t  RESERVE1:24;
X            volatile const  uint32_t  RESERVE1:24;
N        } I2CON;
N    };
N
N    union 
N    {
N        __IO uint32_t u32I2CADDR0;
X        volatile uint32_t u32I2CADDR0;
N        
N        struct 
N        {
N            __IO uint32_t  GC:1;
X            volatile uint32_t  GC:1;
N            __IO uint32_t  I2CADDR:7;
X            volatile uint32_t  I2CADDR:7;
N            __I  uint32_t  RESERVE:24;
X            volatile const  uint32_t  RESERVE:24;
N        } I2CADDR0;
N    };
N
N    union 
N    {
N        __IO uint32_t u32I2CDAT;
X        volatile uint32_t u32I2CDAT;
N        __IO uint32_t I2CDAT;
X        volatile uint32_t I2CDAT;
N    };
N
N    union 
N    {
N        __I uint32_t u32I2CSTATUS;
X        volatile const uint32_t u32I2CSTATUS;
N        __I uint32_t I2CSTATUS;
X        volatile const uint32_t I2CSTATUS;
N    };
N    
N    union 
N    {
N        __IO uint32_t u32I2CLK;
X        volatile uint32_t u32I2CLK;
N        __IO uint32_t I2CLK;
X        volatile uint32_t I2CLK;
N    };
N
N    union 
N    {
N        __IO uint32_t u32I2CTOC;
X        volatile uint32_t u32I2CTOC;
N        
N        struct 
N        {
N            __IO uint32_t  TIF:1;
X            volatile uint32_t  TIF:1;
N            __IO uint32_t  DIV4:1;
X            volatile uint32_t  DIV4:1;
N            __IO uint32_t  ENTI:1;
X            volatile uint32_t  ENTI:1;
N            __I  uint32_t  RESERVE:29;
X            volatile const  uint32_t  RESERVE:29;
N        } I2CTOC;
N    };
N
N    union 
N    {
N        __IO uint32_t u32I2CADDR1;
X        volatile uint32_t u32I2CADDR1;
N        
N        struct 
N        {
N            __IO uint32_t  GC:1;
X            volatile uint32_t  GC:1;
N            __IO uint32_t  I2CADDR:7;
X            volatile uint32_t  I2CADDR:7;
N            __I  uint32_t  RESERVE:24;
X            volatile const  uint32_t  RESERVE:24;
N        } I2CADDR1;
N    };
N    
N    union 
N    {
N        __IO uint32_t u32I2CADDR2;
X        volatile uint32_t u32I2CADDR2;
N        
N        struct 
N        {
N            __IO uint32_t  GC:1;
X            volatile uint32_t  GC:1;
N            __IO uint32_t  I2CADDR:7;
X            volatile uint32_t  I2CADDR:7;
N            __I  uint32_t  RESERVE:24;
X            volatile const  uint32_t  RESERVE:24;
N        } I2CADDR2;
N    };    
N    
N    union 
N    {
N        __IO uint32_t u32I2CADDR3;
X        volatile uint32_t u32I2CADDR3;
N        
N        struct 
N        {
N            __IO uint32_t  GC:1;
X            volatile uint32_t  GC:1;
N            __IO uint32_t  I2CADDR:7;
X            volatile uint32_t  I2CADDR:7;
N            __I  uint32_t  RESERVE:24;
X            volatile const  uint32_t  RESERVE:24;
N        } I2CADDR3;
N    }; 
N    
N    union 
N    {
N        __IO uint32_t u32I2CADM0;
X        volatile uint32_t u32I2CADM0;
N        
N        struct 
N        {
N            __I  uint32_t  RESERVE0:1;
X            volatile const  uint32_t  RESERVE0:1;
N            __IO uint32_t  I2CADM:7;
X            volatile uint32_t  I2CADM:7;
N            __I  uint32_t  RESERVE1:24;
X            volatile const  uint32_t  RESERVE1:24;
N        } I2CADM0;
N    };     
N    
N    union 
N    {
N        __IO uint32_t u32I2CADM1;
X        volatile uint32_t u32I2CADM1;
N        
N        struct 
N        {
N            __I  uint32_t  RESERVE0:1;
X            volatile const  uint32_t  RESERVE0:1;
N            __IO uint32_t  I2CADM:7;
X            volatile uint32_t  I2CADM:7;
N            __I  uint32_t  RESERVE1:24;
X            volatile const  uint32_t  RESERVE1:24;
N        } I2CADM1;
N    };
N
N    union 
N    {
N        __IO uint32_t u32I2CADM2;
X        volatile uint32_t u32I2CADM2;
N        
N        struct 
N        {
N            __I  uint32_t  RESERVE0:1;
X            volatile const  uint32_t  RESERVE0:1;
N            __IO uint32_t  I2CADM:7;
X            volatile uint32_t  I2CADM:7;
N            __I  uint32_t  RESERVE1:24;
X            volatile const  uint32_t  RESERVE1:24;
N        } I2CADM2;
N    };
N       
N    union 
N    {
N        __IO uint32_t u32I2CADM3;
X        volatile uint32_t u32I2CADM3;
N        
N        struct 
N        {
N            __I  uint32_t  RESERVE0:1;
X            volatile const  uint32_t  RESERVE0:1;
N            __IO uint32_t  I2CADM:7;
X            volatile uint32_t  I2CADM:7;
N            __I  uint32_t  RESERVE1:24;
X            volatile const  uint32_t  RESERVE1:24;
N        } I2CADM3;
N    };       
N} I2C_T;
N
N/* I2C I2CON Bit Field Definitions */
N#define I2C_I2CON_EI_Pos                        7
N#define I2C_I2CON_EI_Msk                        (1ul << I2C_I2CON_EI_Pos)
N
N#define I2C_I2CON_ENS1_Pos                      6
N#define I2C_I2CON_ENS1_Msk                      (1ul << I2C_I2CON_ENS1_Pos)
N
N#define I2C_I2CON_STA_Pos                       5
N#define I2C_I2CON_STA_Msk                       (1ul << I2C_I2CON_STA_Pos)
N
N#define I2C_I2CON_STO_Pos                       4
N#define I2C_I2CON_STO_Msk                       (1ul << I2C_I2CON_STO_Pos)
N
N#define I2C_I2CON_SI_Pos                        3
N#define I2C_I2CON_SI_Msk                        (1ul << I2C_I2CON_SI_Pos)
N
N#define I2C_I2CON_AA_Pos                        2
N#define I2C_I2CON_AA_Msk                        (1ul << I2C_I2CON_AA_Pos)
N
N/* I2C I2CADDR Bit Field Definitions */
N#define I2C_I2CADDR_I2CADDR_Pos                 1
N#define I2C_I2CADDR_I2CADDR_Msk                 (0x7Ful << I2C_I2CADDR_I2CADDR_Pos)
N
N#define I2C_I2CADDR_GC_Pos                      0
N#define I2C_I2CADDR_GC_Msk                      (1ul << I2C_I2CADDR_GC_Pos)
N
N/* I2C I2CDAT Bit Field Definitions */
N#define I2C_I2CDAT_I2CDAT_Pos                   0
N#define I2C_I2CDAT_I2CDAT_Msk                   (0xFFul << I2C_I2CDAT_I2CDAT_Pos)
N
N/* I2C I2CSTATUS Bit Field Definitions */
N#define I2C_I2CSTATUS_I2CSTATUS_Pos             0
N#define I2C_I2CSTATUS_I2CSTATUS_Msk             (0xFFul << I2C_I2CSTATUS_I2CSTATUS_Pos)
N
N/* I2C I2CLK Bit Field Definitions */
N#define I2C_I2CLK_I2CLK_Pos                     0
N#define I2C_I2CLK_I2CLK_Msk                     (0xFFul << I2C_I2CLK_I2CLK_Pos)
N
N/* I2C I2CTOC Bit Field Definitions */
N#define I2C_I2CTOC_ENTI_Pos                     2
N#define I2C_I2CTOC_ENTI_Msk                     (1ul << I2C_I2CTOC_ENTI_Pos)
N
N#define I2C_I2CTOC_DIV4_Pos                     1
N#define I2C_I2CTOC_DIV4_Msk                     (1ul << I2C_I2CTOC_DIV4_Pos)
N
N#define I2C_I2CTOC_TIF_Pos                      0
N#define I2C_I2CTOC_TIF_Msk                      (1ul << I2C_I2CTOC_TIF_Pos)
N
N/* I2C I2CADM Bit Field Definitions */
N#define I2C_I2CADM_I2CADM_Pos                   1
N#define I2C_I2CADM_I2CADM_Msk                   (0x7Ful << I2C_I2CADM_I2CADM_Pos)
N
N
N/*----------------------------- RTC Controller -------------------------------*/
Ntypedef __IO uint32_t RTC_INIR_T;
Xtypedef volatile uint32_t RTC_INIR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  AER:16;
X    volatile uint32_t  AER:16;
N    __I  uint32_t  ENF:1;
X    volatile const  uint32_t  ENF:1;
N    __I  uint32_t  RESERVE1:15;
X    volatile const  uint32_t  RESERVE1:15;
N} RTC_AER_T;
N
Ntypedef struct
N{
N    __IO uint32_t  FRACTION:6;
X    volatile uint32_t  FRACTION:6;
N    __I  uint32_t  RESERVE0:2;
X    volatile const  uint32_t  RESERVE0:2;
N    __IO uint32_t  INTEGER:4;
X    volatile uint32_t  INTEGER:4;
N    __I  uint32_t  RESERVE1:20;
X    volatile const  uint32_t  RESERVE1:20;
N} RTC_FCR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  SEC1:4;
X    volatile uint32_t  SEC1:4;
N    __IO uint32_t  SEC10:3;
X    volatile uint32_t  SEC10:3;
N    __I  uint32_t  RESERVE0:1;
X    volatile const  uint32_t  RESERVE0:1;
N    __IO uint32_t  MIN1:4;
X    volatile uint32_t  MIN1:4;
N    __IO uint32_t  MIN10:3;
X    volatile uint32_t  MIN10:3;
N    __I  uint32_t  RESERVE1:1;
X    volatile const  uint32_t  RESERVE1:1;
N    __IO uint32_t  HR1:4;
X    volatile uint32_t  HR1:4;
N    __IO uint32_t  HR10:2;
X    volatile uint32_t  HR10:2;
N    __I  uint32_t  RESERVE2:10;
X    volatile const  uint32_t  RESERVE2:10;
N} RTC_TLR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  DAY1:4;
X    volatile uint32_t  DAY1:4;
N    __IO uint32_t  DAY10:2;
X    volatile uint32_t  DAY10:2;
N    __I  uint32_t  RESERVE0:2;
X    volatile const  uint32_t  RESERVE0:2;
N    __IO uint32_t  MON1:4;
X    volatile uint32_t  MON1:4;
N    __IO uint32_t  MON10:1;
X    volatile uint32_t  MON10:1;
N    __I  uint32_t  RESERVE1:3;
X    volatile const  uint32_t  RESERVE1:3;
N    __IO uint32_t  YEAR1:4;
X    volatile uint32_t  YEAR1:4;
N    __IO uint32_t  YEAR10:4;
X    volatile uint32_t  YEAR10:4;
N    __I  uint32_t  RESERVE2:8;
X    volatile const  uint32_t  RESERVE2:8;
N} RTC_CLR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  HR24_HR12:1;
X    volatile uint32_t  HR24_HR12:1;
N    __I  uint32_t  RESERVE:31;
X    volatile const  uint32_t  RESERVE:31;
N} RTC_TSSR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  DWR:3;
X    volatile uint32_t  DWR:3;
N    __I  uint32_t  RESERVE:29;
X    volatile const  uint32_t  RESERVE:29;
N} RTC_DWR_T;
N
Ntypedef RTC_TLR_T   RTC_TAR_T;
N
Ntypedef RTC_CLR_T   RTC_CAR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  LIR:1;
X    volatile uint32_t  LIR:1;
N    __I  uint32_t  RESERVE:31;
X    volatile const  uint32_t  RESERVE:31;
N} RTC_LIR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  AIER:1;
X    volatile uint32_t  AIER:1;
N    __IO uint32_t  TIER:1;
X    volatile uint32_t  TIER:1;
N    __I  uint32_t  RESERVE:30;
X    volatile const  uint32_t  RESERVE:30;
N} RTC_RIER_T;
N
Ntypedef struct
N{
N    __IO uint32_t  AIF:1;
X    volatile uint32_t  AIF:1;
N    __IO uint32_t  TIF:1;
X    volatile uint32_t  TIF:1;
N    __I  uint32_t  RESERVE:30;
X    volatile const  uint32_t  RESERVE:30;
N} RTC_RIIR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  TTR:3;
X    volatile uint32_t  TTR:3;
N    __IO uint32_t  TWKE:1;
X    volatile uint32_t  TWKE:1;
N    __I  uint32_t  RESERVE:28;
X    volatile const  uint32_t  RESERVE:28;
N} RTC_TTR_T;
N
Ntypedef struct
N{
N    union {
N        __IO uint32_t u32INIR;
X        volatile uint32_t u32INIR;
N        __IO uint32_t INIR;
X        volatile uint32_t INIR;
N    };
N
N    union {
N        __IO uint32_t u32AER;
X        volatile uint32_t u32AER;
N        struct {
N            __IO uint32_t  AER:16;
X            volatile uint32_t  AER:16;
N            __I  uint32_t  ENF:1;
X            volatile const  uint32_t  ENF:1;
N            __I  uint32_t  RESERVE1:15;
X            volatile const  uint32_t  RESERVE1:15;
N        } AER;
N    };
N
N    union {
N        __IO uint32_t u32FCR;
X        volatile uint32_t u32FCR;
N        struct {
N            __IO uint32_t  FRACTION:6;
X            volatile uint32_t  FRACTION:6;
N            __I  uint32_t  RESERVE0:2;
X            volatile const  uint32_t  RESERVE0:2;
N            __IO uint32_t  INTEGER:4;
X            volatile uint32_t  INTEGER:4;
N            __I  uint32_t  RESERVE1:20;
X            volatile const  uint32_t  RESERVE1:20;
N        } FCR;
N    };
N
N    union {
N        __IO uint32_t u32TLR;
X        volatile uint32_t u32TLR;
N        struct {
N            __IO uint32_t  SEC1:4;
X            volatile uint32_t  SEC1:4;
N            __IO uint32_t  SEC10:3;
X            volatile uint32_t  SEC10:3;
N            __I  uint32_t  RESERVE0:1;
X            volatile const  uint32_t  RESERVE0:1;
N            __IO uint32_t  MIN1:4;
X            volatile uint32_t  MIN1:4;
N            __IO uint32_t  MIN10:3;
X            volatile uint32_t  MIN10:3;
N            __I  uint32_t  RESERVE1:1;
X            volatile const  uint32_t  RESERVE1:1;
N            __IO uint32_t  HR1:4;
X            volatile uint32_t  HR1:4;
N            __IO uint32_t  HR10:2;
X            volatile uint32_t  HR10:2;
N            __I  uint32_t  RESERVE2:10;
X            volatile const  uint32_t  RESERVE2:10;
N        } TLR;
N    };
N
N    union {
N        __IO uint32_t u32CLR;
X        volatile uint32_t u32CLR;
N        struct {
N            __IO uint32_t  DAY1:4;
X            volatile uint32_t  DAY1:4;
N            __IO uint32_t  DAY10:2;
X            volatile uint32_t  DAY10:2;
N            __I  uint32_t  RESERVE0:2;
X            volatile const  uint32_t  RESERVE0:2;
N            __IO uint32_t  MON1:4;
X            volatile uint32_t  MON1:4;
N            __IO uint32_t  MON10:1;
X            volatile uint32_t  MON10:1;
N            __I  uint32_t  RESERVE1:3;
X            volatile const  uint32_t  RESERVE1:3;
N            __IO uint32_t  YEAR1:4;
X            volatile uint32_t  YEAR1:4;
N            __IO uint32_t  YEAR10:4;
X            volatile uint32_t  YEAR10:4;
N            __I  uint32_t  RESERVE2:8;
X            volatile const  uint32_t  RESERVE2:8;
N        } CLR;
N    };
N
N    union {
N        __IO uint32_t u32TSSR;
X        volatile uint32_t u32TSSR;
N        struct {
N            __IO uint32_t  HR24_HR12:1;
X            volatile uint32_t  HR24_HR12:1;
N            __I  uint32_t  RESERVE:31;
X            volatile const  uint32_t  RESERVE:31;
N        } TSSR;
N    };
N
N    union {
N        __IO uint32_t u32DWR;
X        volatile uint32_t u32DWR;
N        struct {
N            __IO uint32_t  DWR:3;
X            volatile uint32_t  DWR:3;
N            __I  uint32_t  RESERVE:29;
X            volatile const  uint32_t  RESERVE:29;
N        } DWR;
N    };
N
N    union {
N        __IO uint32_t u32TAR;
X        volatile uint32_t u32TAR;
N        struct {
N            __IO uint32_t  SEC1:4;
X            volatile uint32_t  SEC1:4;
N            __IO uint32_t  SEC10:3;
X            volatile uint32_t  SEC10:3;
N            __I  uint32_t  RESERVE0:1;
X            volatile const  uint32_t  RESERVE0:1;
N            __IO uint32_t  MIN1:4;
X            volatile uint32_t  MIN1:4;
N            __IO uint32_t  MIN10:3;
X            volatile uint32_t  MIN10:3;
N            __I  uint32_t  RESERVE1:1;
X            volatile const  uint32_t  RESERVE1:1;
N            __IO uint32_t  HR1:4;
X            volatile uint32_t  HR1:4;
N            __IO uint32_t  HR10:2;
X            volatile uint32_t  HR10:2;
N            __I  uint32_t  RESERVE2:10;
X            volatile const  uint32_t  RESERVE2:10;
N        } TAR;
N    };
N
N    union {
N        __IO uint32_t u32CAR;
X        volatile uint32_t u32CAR;
N        struct {
N            __IO uint32_t  DAY1:4;
X            volatile uint32_t  DAY1:4;
N            __IO uint32_t  DAY10:2;
X            volatile uint32_t  DAY10:2;
N            __I  uint32_t  RESERVE0:2;
X            volatile const  uint32_t  RESERVE0:2;
N            __IO uint32_t  MON1:4;
X            volatile uint32_t  MON1:4;
N            __IO uint32_t  MON10:1;
X            volatile uint32_t  MON10:1;
N            __I  uint32_t  RESERVE1:3;
X            volatile const  uint32_t  RESERVE1:3;
N            __IO uint32_t  YEAR1:4;
X            volatile uint32_t  YEAR1:4;
N            __IO uint32_t  YEAR10:4;
X            volatile uint32_t  YEAR10:4;
N            __I  uint32_t  RESERVE2:8;
X            volatile const  uint32_t  RESERVE2:8;
N        } CAR;
N    };
N
N    union {
N        __IO uint32_t u32LIR;
X        volatile uint32_t u32LIR;
N        struct {
N            __IO uint32_t  LIR:1;
X            volatile uint32_t  LIR:1;
N            __I  uint32_t  RESERVE:31;
X            volatile const  uint32_t  RESERVE:31;
N        } LIR;
N    };
N
N    union {
N        __IO uint32_t u32RIER;
X        volatile uint32_t u32RIER;
N        struct {
N            __IO uint32_t  AIER:1;
X            volatile uint32_t  AIER:1;
N            __IO uint32_t  TIER:1;
X            volatile uint32_t  TIER:1;
N            __I  uint32_t  RESERVE:30;
X            volatile const  uint32_t  RESERVE:30;
N        } RIER;
N    };
N
N    union {
N        __IO uint32_t u32RIIR;
X        volatile uint32_t u32RIIR;
N        struct {
N            __IO uint32_t  AIF:1;
X            volatile uint32_t  AIF:1;
N            __IO uint32_t  TIF:1;
X            volatile uint32_t  TIF:1;
N            __I  uint32_t  RESERVE:30;
X            volatile const  uint32_t  RESERVE:30;
N        } RIIR;
N    };
N
N    union {
N        __IO uint32_t u32TTR;
X        volatile uint32_t u32TTR;
N        struct {
N            __IO uint32_t  TTR:3;
X            volatile uint32_t  TTR:3;
N            __IO uint32_t  TWKE:1;
X            volatile uint32_t  TWKE:1;
N            __I  uint32_t  RESERVE:28;
X            volatile const  uint32_t  RESERVE:28;
N        } TTR;
N    };
N} RTC_T;
N
N/* RTC INIR Bit Field Definitions */
N#define RTC_INIR_INIR_Pos       0  
N#define RTC_INIR_INIR_Msk       (0xFFFFFFFFul << RTC_INIR_INIR_Pos)
N
N#define RTC_INIR_ACTIVE_Pos     0  
N#define RTC_INIR_ACTIVE_Msk     (1ul << RTC_INIR_ACTIVE_Pos)
N
N/* RTC AER Bit Field Definitions */
N#define RTC_AER_ENF_Pos         16  
N#define RTC_AER_ENF_Msk         (1ul << RTC_AER_ENF_Pos)
N
N#define RTC_AER_AER_Pos         0  
N#define RTC_AER_AER_Msk         (0xFFFFul << RTC_AER_AER_Pos)
N
N/* RTC FCR Bit Field Definitions */
N#define RTC_FCR_INTEGER_Pos     8  
N#define RTC_FCR_INTEGER_Msk     (0xFul << RTC_FCR_INTEGER_Pos)
N
N#define RTC_FCR_FRACTION_Pos    0  
N#define RTC_FCR_FRACTION_Msk    (0x3Ful << RTC_FCR_FRACTION_Pos)
N
N/* RTC TLR Bit Field Definitions */
N#define RTC_TLR_10HR_Pos        20  
N#define RTC_TLR_10HR_Msk        (0x3ul << RTC_TLR_10HR_Pos)
N
N#define RTC_TLR_1HR_Pos         16  
N#define RTC_TLR_1HR_Msk         (0xFul << RTC_TLR_1HR_Pos)
N
N#define RTC_TLR_10MIN_Pos       12  
N#define RTC_TLR_10MIN_Msk       (0x7ul << RTC_TLR_10MIN_Pos)
N
N#define RTC_TLR_1MIN_Pos        8  
N#define RTC_TLR_1MIN_Msk        (0xFul << RTC_TLR_1MIN_Pos)
N
N#define RTC_TLR_10SEC_Pos       4  
N#define RTC_TLR_10SEC_Msk       (0x7ul << RTC_TLR_10SEC_Pos)
N
N#define RTC_TLR_1SEC_Pos        0  
N#define RTC_TLR_1SEC_Msk        (0xFul << RTC_TLR_1SEC_Pos)
N
N/* RTC CLR Bit Field Definitions */
N#define RTC_CLR_10YEAR_Pos      20  
N#define RTC_CLR_10YEAR_Msk      (0xFul << RTC_CLR_10YEAR_Pos)
N
N#define RTC_CLR_1YEAR_Pos       16  
N#define RTC_CLR_1YEAR_Msk       (0xFul << RTC_CLR_1YEAR_Pos)
N
N#define RTC_CLR_10MON_Pos       12  
N#define RTC_CLR_10MON_Msk       (1ul << RTC_CLR_10MON_Pos)
N
N#define RTC_CLR_1MON_Pos        8  
N#define RTC_CLR_1MON_Msk        (0xFul << RTC_CLR_1MON_Pos)
N
N#define RTC_CLR_10DAY_Pos       4  
N#define RTC_CLR_10DAY_Msk       (0x3ul << RTC_CLR_10DAY_Pos)
N
N#define RTC_CLR_1DAY_Pos        0  
N#define RTC_CLR_1DAY_Msk        (0xFul << RTC_CLR_1DAY_Pos)
N
N/* RTC TSSR Bit Field Definitions */
N#define RTC_TSSR_24H_12H_Pos    0  
N#define RTC_TSSR_24H_12H_Msk    (1ul << RTC_TSSR_24H_12H_Pos)
N
N/* RTC DWR Bit Field Definitions */
N#define RTC_DWR_DWR_Pos         0  
N#define RTC_DWR_DWR_Msk         (0x7ul << RTC_DWR_DWR_Pos)
N
N/* RTC TAR Bit Field Definitions */
N#define RTC_TAR_10HR_Pos        20  
N#define RTC_TAR_10HR_Msk        (0x3ul << RTC_TAR_10HR_Pos)
N
N#define RTC_TAR_1HR_Pos         16  
N#define RTC_TAR_1HR_Msk         (0xFul << RTC_TAR_1HR_Pos)
N
N#define RTC_TAR_10MIN_Pos       12  
N#define RTC_TAR_10MIN_Msk       (0x7ul << RTC_TAR_10MIN_Pos)
N
N#define RTC_TAR_1MIN_Pos        8  
N#define RTC_TAR_1MIN_Msk        (0xFul << RTC_TAR_1MIN_Pos)
N
N#define RTC_TAR_10SEC_Pos       4  
N#define RTC_TAR_10SEC_Msk       (0x7ul << RTC_TAR_10SEC_Pos)
N
N#define RTC_TAR_1SEC_Pos        0  
N#define RTC_TAR_1SEC_Msk        (0xFul << RTC_TAR_1SEC_Pos)
N
N/* RTC CAR Bit Field Definitions */
N#define RTC_CAR_10YEAR_Pos      20  
N#define RTC_CAR_10YEAR_Msk      (0xFul << RTC_CAR_10YEAR_Pos)
N
N#define RTC_CAR_1YEAR_Pos       16  
N#define RTC_CAR_1YEAR_Msk       (0xFul << RTC_CAR_1YEAR_Pos)
N
N#define RTC_CAR_10MON_Pos       12  
N#define RTC_CAR_10MON_Msk       (1ul << RTC_CAR_10MON_Pos)
N
N#define RTC_CAR_1MON_Pos        8  
N#define RTC_CAR_1MON_Msk        (0xFul << RTC_CAR_1MON_Pos)
N
N#define RTC_CAR_10DAY_Pos       4  
N#define RTC_CAR_10DAY_Msk       (0x3ul << RTC_CAR_10DAY_Pos)
N
N#define RTC_CAR_1DAY_Pos        0  
N#define RTC_CAR_1DAY_Msk        (0xFul << RTC_CAR_1DAY_Pos)
N
N/* RTC LIR Bit Field Definitions */
N#define RTC_LIR_LIR_Pos         0  
N#define RTC_LIR_LIR_Msk         (1ul << RTC_LIR_LIR_Pos)
N
N/* RTC RIER Bit Field Definitions */
N#define RTC_RIER_TIER_Pos       1  
N#define RTC_RIER_TIER_Msk       (1ul << RTC_RIER_TIER_Pos)
N
N#define RTC_RIER_AIER_Pos       0  
N#define RTC_RIER_AIER_Msk       (1ul << RTC_RIER_AIER_Pos)
N
N/* RTC RIIR Bit Field Definitions */
N#define RTC_RIIR_TIF_Pos        1  
N#define RTC_RIIR_TIF_Msk        (1ul << RTC_RIIR_TIF_Pos)
N
N#define RTC_RIIR_AIF_Pos        0  
N#define RTC_RIIR_AIF_Msk        (1ul << RTC_RIIR_AIF_Pos)
N
N/* RTC TTR Bit Field Definitions */
N#define RTC_TTR_TWKE_Pos        3  
N#define RTC_TTR_TWKE_Msk        (1ul << RTC_TTR_TWKE_Pos)
N
N#define RTC_TTR_TTR_Pos         0  
N#define RTC_TTR_TTR_Msk         (0x7ul << RTC_TTR_TTR_Pos)
N
N
N/*----------------------------- ADC Controller -------------------------------*/
Ntypedef struct
N{
N    __I  uint32_t  RSLT:16;
X    volatile const  uint32_t  RSLT:16;
N    __I  uint32_t  OVERRUN:1;
X    volatile const  uint32_t  OVERRUN:1;
N    __I  uint32_t  VALID:1;
X    volatile const  uint32_t  VALID:1;
N    __I  uint32_t  RESERVE1:14;
X    volatile const  uint32_t  RESERVE1:14;
N} ADC_ADDR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  ADEN:1;
X    volatile uint32_t  ADEN:1;
N    __IO uint32_t  ADIE:1;
X    volatile uint32_t  ADIE:1;
N    __IO uint32_t  ADMD:2;
X    volatile uint32_t  ADMD:2;
N    __IO uint32_t  TRGS:2;
X    volatile uint32_t  TRGS:2;
N    __IO uint32_t  TRGCOND:2;
X    volatile uint32_t  TRGCOND:2;
N    __IO uint32_t  TRGEN:1;
X    volatile uint32_t  TRGEN:1;
N    __IO uint32_t  PTEN:1;
X    volatile uint32_t  PTEN:1;
N    __IO uint32_t  DIFFEN:1;
X    volatile uint32_t  DIFFEN:1;
N    __IO uint32_t  ADST:1;
X    volatile uint32_t  ADST:1;
N    __I  uint32_t  RESERVE0:19;
X    volatile const  uint32_t  RESERVE0:19;
N    __IO uint32_t  DMOF:1;
X    volatile uint32_t  DMOF:1;
N} ADC_ADCR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  CHEN:8;
X    volatile uint32_t  CHEN:8;
N    __IO uint32_t  PRESEL:2;
X    volatile uint32_t  PRESEL:2;
N    __I  uint32_t  RESERVE:22;
X    volatile const  uint32_t  RESERVE:22;
N} ADC_ADCHER_T;
N
Ntypedef struct
N{
N    __IO uint32_t  CMPEN:1;
X    volatile uint32_t  CMPEN:1;
N    __IO uint32_t  CMPIE:1;
X    volatile uint32_t  CMPIE:1;
N    __IO uint32_t  CMPCOND:1;
X    volatile uint32_t  CMPCOND:1;
N    __IO uint32_t  CMPCH:3;
X    volatile uint32_t  CMPCH:3;
N    __I  uint32_t  RESERVE0:2;
X    volatile const  uint32_t  RESERVE0:2;
N    __IO uint32_t  CMPMATCNT:4;
X    volatile uint32_t  CMPMATCNT:4;
N    __I  uint32_t  RESERVE1:4;
X    volatile const  uint32_t  RESERVE1:4;
N    __IO uint32_t  CMPD:12;
X    volatile uint32_t  CMPD:12;
N    __I  uint32_t  RESERVE2:4;
X    volatile const  uint32_t  RESERVE2:4;
N} ADC_ADCMPR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  ADF:1;
X    volatile uint32_t  ADF:1;
N    __IO uint32_t  CMPF0:1;
X    volatile uint32_t  CMPF0:1;
N    __IO uint32_t  CMPF1:1;
X    volatile uint32_t  CMPF1:1;
N    __I  uint32_t  BUSY:1;
X    volatile const  uint32_t  BUSY:1;
N    __I  uint32_t  CHANNEL:3;
X    volatile const  uint32_t  CHANNEL:3;
N    __I  uint32_t  RESERVE0:1;
X    volatile const  uint32_t  RESERVE0:1;
N    __I  uint32_t  VALID:8;
X    volatile const  uint32_t  VALID:8;
N    __I  uint32_t  OVERRUN:8;
X    volatile const  uint32_t  OVERRUN:8;
N    __I  uint32_t  RESERVE1:8;
X    volatile const  uint32_t  RESERVE1:8;
N} ADC_ADSR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  CALEN:1;
X    volatile uint32_t  CALEN:1;
N    __I  uint32_t  CALDONE:1;
X    volatile const  uint32_t  CALDONE:1;
N    __I  uint32_t  RESERVE:30;
X    volatile const  uint32_t  RESERVE:30;
N} ADC_ADCALR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  AD_PDMA:12;
X    volatile uint32_t  AD_PDMA:12;
N    __I  uint32_t  RESERVE:20;
X    volatile const  uint32_t  RESERVE:20;
N} ADC_ADPDMA_T;
N
Ntypedef struct
N{
N    union {
N        __I uint32_t u32ADDR[8];
X        volatile const uint32_t u32ADDR[8];
N        struct {
N            __I  uint32_t  RSLT:16;
X            volatile const  uint32_t  RSLT:16;
N            __I  uint32_t  OVERRUN:1;
X            volatile const  uint32_t  OVERRUN:1;
N            __I  uint32_t  VALID:1;
X            volatile const  uint32_t  VALID:1;
N            __I  uint32_t  RESERVE1:14;
X            volatile const  uint32_t  RESERVE1:14;
N        } ADDR[8];
N    };
N    
N    union {
N        __IO uint32_t u32ADCR;
X        volatile uint32_t u32ADCR;
N        struct {
N            __IO uint32_t  ADEN:1;
X            volatile uint32_t  ADEN:1;
N            __IO uint32_t  ADIE:1;
X            volatile uint32_t  ADIE:1;
N            __IO uint32_t  ADMD:2;
X            volatile uint32_t  ADMD:2;
N            __IO uint32_t  TRGS:2;
X            volatile uint32_t  TRGS:2;
N            __IO uint32_t  TRGCOND:2;
X            volatile uint32_t  TRGCOND:2;
N            __IO uint32_t  TRGEN:1;
X            volatile uint32_t  TRGEN:1;
N            __IO uint32_t  PTEN:1;
X            volatile uint32_t  PTEN:1;
N            __IO uint32_t  DIFFEN:1;
X            volatile uint32_t  DIFFEN:1;
N            __IO uint32_t  ADST:1;
X            volatile uint32_t  ADST:1;
N            __I  uint32_t  RESERVE0:19;
X            volatile const  uint32_t  RESERVE0:19;
N            __IO uint32_t  DMOF:1;
X            volatile uint32_t  DMOF:1;
N        } ADCR;
N    };
N    
N    union {
N        __IO uint32_t u32ADCHER;
X        volatile uint32_t u32ADCHER;
N        struct {
N            __IO uint32_t  CHEN:8;
X            volatile uint32_t  CHEN:8;
N            __IO uint32_t  PRESEL:2;
X            volatile uint32_t  PRESEL:2;
N            __I  uint32_t  RESERVE:22;
X            volatile const  uint32_t  RESERVE:22;
N        } ADCHER;
N    };
N    
N    union {
N        __IO uint32_t u32ADCMPR[2];
X        volatile uint32_t u32ADCMPR[2];
N        struct {
N            __IO uint32_t  CMPEN:1;
X            volatile uint32_t  CMPEN:1;
N            __IO uint32_t  CMPIE:1;
X            volatile uint32_t  CMPIE:1;
N            __IO uint32_t  CMPCOND:1;
X            volatile uint32_t  CMPCOND:1;
N            __IO uint32_t  CMPCH:3;
X            volatile uint32_t  CMPCH:3;
N            __I  uint32_t  RESERVE0:2;
X            volatile const  uint32_t  RESERVE0:2;
N            __IO uint32_t  CMPMATCNT:4;
X            volatile uint32_t  CMPMATCNT:4;
N            __I  uint32_t  RESERVE1:4;
X            volatile const  uint32_t  RESERVE1:4;
N            __IO uint32_t  CMPD:12;
X            volatile uint32_t  CMPD:12;
N            __I  uint32_t  RESERVE2:4;
X            volatile const  uint32_t  RESERVE2:4;
N        } ADCMPR[2];
N    };
N    
N    union {
N        __IO uint32_t u32ADSR;
X        volatile uint32_t u32ADSR;
N        struct {
N            __IO uint32_t  ADF:1;
X            volatile uint32_t  ADF:1;
N            __IO uint32_t  CMPF0:1;
X            volatile uint32_t  CMPF0:1;
N            __IO uint32_t  CMPF1:1;
X            volatile uint32_t  CMPF1:1;
N            __I  uint32_t  BUSY:1;
X            volatile const  uint32_t  BUSY:1;
N            __I  uint32_t  CHANNEL:3;
X            volatile const  uint32_t  CHANNEL:3;
N            __I  uint32_t  RESERVE0:1;
X            volatile const  uint32_t  RESERVE0:1;
N            __I  uint32_t  VALID:8;
X            volatile const  uint32_t  VALID:8;
N            __I  uint32_t  OVERRUN:8;
X            volatile const  uint32_t  OVERRUN:8;
N            __I  uint32_t  RESERVE1:8;
X            volatile const  uint32_t  RESERVE1:8;
N        } ADSR;
N    };
N    
N    union {
N        __IO uint32_t u32ADCALR;
X        volatile uint32_t u32ADCALR;
N        struct {
N            __IO uint32_t  CALEN:1;
X            volatile uint32_t  CALEN:1;
N            __I  uint32_t  CALDONE:1;
X            volatile const  uint32_t  CALDONE:1;
N            __I  uint32_t  RESERVE:30;
X            volatile const  uint32_t  RESERVE:30;
N        } ADCALR;
N    };
N    
N    __I uint32_t RESERVE0;
X    volatile const uint32_t RESERVE0;
N    __I uint32_t RESERVE1;
X    volatile const uint32_t RESERVE1;
N    
N    union {
N        __IO uint32_t u32ADPDMA;
X        volatile uint32_t u32ADPDMA;
N        struct {
N            __IO uint32_t  AD_PDMA:12;
X            volatile uint32_t  AD_PDMA:12;
N            __I  uint32_t  RESERVE:20;
X            volatile const  uint32_t  RESERVE:20;
N        } ADPDMA;
N    };
N} ADC_T;
N
N/* ADDR Bit Field Definitions */
N#define ADC_ADDR_VALID_Pos      17
N#define ADC_ADDR_VALID_Msk      (1ul << ADC_ADDR_VALID_Pos)
N
N#define ADC_ADDR_OVERRUN_Pos    16
N#define ADC_ADDR_OVERRUN_Msk    (1ul << ADC_ADDR_OVERRUN_Pos)
N
N#define ADC_ADDR_RSLT_Pos       0
N#define ADC_ADDR_RSLT_Msk       (0xFFFFul << ADC_ADDR_RSLT_Pos)
N
N/* ADCR Bit Field Definitions */
N#define ADC_ADCR_DMOF_Pos       31
N#define ADC_ADCR_DMOF_Msk       (1ul << ADC_ADCR_DMOF_Pos)
N
N#define ADC_ADCR_ADST_Pos       11
N#define ADC_ADCR_ADST_Msk       (1ul << ADC_ADCR_ADST_Pos)
N
N#define ADC_ADCR_DIFFEN_Pos     10
N#define ADC_ADCR_DIFFEN_Msk     (1ul << ADC_ADCR_DIFFEN_Pos)
N
N#define ADC_ADCR_PTEN_Pos       9
N#define ADC_ADCR_PTEN_Msk       (1ul << ADC_ADCR_PTEN_Pos)
N
N#define ADC_ADCR_TRGEN_Pos      8
N#define ADC_ADCR_TRGEN_Msk      (1ul << ADC_ADCR_TRGEN_Pos)
N
N#define ADC_ADCR_TRGCOND_Pos    6
N#define ADC_ADCR_TRGCOND_Msk    (3ul << ADC_ADCR_TRGCOND_Pos)
N
N#define ADC_ADCR_TRGS_Pos       4
N#define ADC_ADCR_TRGS_Msk       (3ul << ADC_ADCR_TRGS_Pos)
N
N#define ADC_ADCR_ADMD_Pos       2
N#define ADC_ADCR_ADMD_Msk       (3ul << ADC_ADCR_ADMD_Pos)
N
N#define ADC_ADCR_ADIE_Pos       1
N#define ADC_ADCR_ADIE_Msk       (1ul << ADC_ADCR_ADIE_Pos)
N
N#define ADC_ADCR_ADEN_Pos       0
N#define ADC_ADCR_ADEN_Msk       (1ul << ADC_ADCR_ADEN_Pos)
N
N/* ADCHER Bit Field Definitions */
N#define ADC_ADCHER_PRESEL_Pos   8
N#define ADC_ADCHER_PRESEL_Msk   (3ul << ADC_ADCHER_PRESEL_Pos)
N
N#define ADC_ADCHER_CHEN_Pos     0
N#define ADC_ADCHER_CHEN_Msk     (0xFFul << ADC_ADCHER_CHEN_Pos)
N
N/* ADCMPR Bit Field Definitions */
N#define ADC_ADCMPR_CMPD_Pos        16
N#define ADC_ADCMPR_CMPD_Msk        (0xFFFul << ADC_ADCMPR_CMPD_Pos)
N
N#define ADC_ADCMPR_CMPMATCNT_Pos   8
N#define ADC_ADCMPR_CMPMATCNT_Msk   (0xFul << ADC_ADCMPR_CMPMATCNT_Pos)
N
N#define ADC_ADCMPR_CMPCH_Pos       3
N#define ADC_ADCMPR_CMPCH_Msk       (7ul << ADC_ADCMPR_CMPCH_Pos)
N
N#define ADC_ADCMPR_CMPCOND_Pos     2
N#define ADC_ADCMPR_CMPCOND_Msk     (1ul << ADC_ADCMPR_CMPCOND_Pos)
N
N#define ADC_ADCMPR_CMPIE_Pos       1
N#define ADC_ADCMPR_CMPIE_Msk       (1ul << ADC_ADCMPR_CMPIE_Pos)
N
N#define ADC_ADCMPR_CMPEN_Pos       0
N#define ADC_ADCMPR_CMPEN_Msk       (1ul << ADC_ADCMPR_CMPEN_Pos)
N
N/* ADSR Bit Field Definitions */
N#define ADC_ADSR_OVERRUN_Pos       16
N#define ADC_ADSR_OVERRUN_Msk       (0xFFul << ADC_ADSR_OVERRUN_Pos)
N
N#define ADC_ADSR_VALID_Pos         8
N#define ADC_ADSR_VALID_Msk         (0xFFul << ADC_ADSR_VALID_Pos)
N
N#define ADC_ADSR_CHANNEL_Pos       4
N#define ADC_ADSR_CHANNEL_Msk       (7ul << ADC_ADSR_CHANNEL_Pos)
N
N#define ADC_ADSR_BUSY_Pos          3
N#define ADC_ADSR_BUSY_Msk          (1ul << ADC_ADSR_BUSY_Pos)
N
N#define ADC_ADSR_CMPF1_Pos         2
N#define ADC_ADSR_CMPF1_Msk         (1ul << ADC_ADSR_CMPF1_Pos)
N
N#define ADC_ADSR_CMPF0_Pos         1
N#define ADC_ADSR_CMPF0_Msk         (1ul << ADC_ADSR_CMPF0_Pos)
N
N#define ADC_ADSR_ADF_Pos           0
N#define ADC_ADSR_ADF_Msk           (1ul << ADC_ADSR_ADF_Pos)
N
N/* ADCALR Bit Field Definitions */
N#define ADC_ADCALR_CALDONE_Pos     1
N#define ADC_ADCALR_CALDONE_Msk     (1ul << ADC_ADCALR_CALDONE_Pos)
N
N#define ADC_ADCALR_CALEN_Pos       0
N#define ADC_ADCALR_CALEN_Msk       (1ul << ADC_ADCALR_CALEN_Pos)
N
N/* ADPDMA Bit Field Definitions */
N#define ADC_ADPDMA_AD_PDMA_Pos     0
N#define ADC_ADPDMA_AD_PDMA_Msk     (1ul << ADC_ADPDMA_AD_PDMA_Pos)
N
N
N/*---------------------- Analog Comparator Controller -------------------------*/
Ntypedef struct
N{
N    __IO uint32_t  CMPEN:1;
X    volatile uint32_t  CMPEN:1;
N    __IO uint32_t  CMPIE:1;
X    volatile uint32_t  CMPIE:1;
N    __IO uint32_t  CMP_HYSEN:1;
X    volatile uint32_t  CMP_HYSEN:1;
N    __I  uint32_t  RESERVE0:1;
X    volatile const  uint32_t  RESERVE0:1;
N    __IO uint32_t  CMPCN:1;
X    volatile uint32_t  CMPCN:1;
N    __I  uint32_t  RESERVE1:27;
X    volatile const  uint32_t  RESERVE1:27;
N} ACMP_CMPCR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  CMPF0:1;
X    volatile uint32_t  CMPF0:1;
N    __IO uint32_t  CMPF1:1;
X    volatile uint32_t  CMPF1:1;
N    __I  uint32_t  CO0:1;
X    volatile const  uint32_t  CO0:1;
N    __I  uint32_t  CO1:1;
X    volatile const  uint32_t  CO1:1;
N    __I  uint32_t  RESERVE:28;
X    volatile const  uint32_t  RESERVE:28;
N} ACMP_CMPSR_T;
N
Ntypedef struct
N{
N    union {
N        __IO uint32_t u32CMPCR[2];
X        volatile uint32_t u32CMPCR[2];
N        struct {
N            __IO uint32_t  CMPEN:1;
X            volatile uint32_t  CMPEN:1;
N            __IO uint32_t  CMPIE:1;
X            volatile uint32_t  CMPIE:1;
N            __IO uint32_t  CMP_HYSEN:1;
X            volatile uint32_t  CMP_HYSEN:1;
N            __I  uint32_t  RESERVE0:1;
X            volatile const  uint32_t  RESERVE0:1;
N            __IO uint32_t  CMPCN:1;
X            volatile uint32_t  CMPCN:1;
N            __I  uint32_t  RESERVE1:27;
X            volatile const  uint32_t  RESERVE1:27;
N        } CMPCR[2];
N    };
N    
N    union {
N        __IO uint32_t u32CMPSR;
X        volatile uint32_t u32CMPSR;
N        struct {
N            __IO uint32_t  CMPF0:1;
X            volatile uint32_t  CMPF0:1;
N            __IO uint32_t  CMPF1:1;
X            volatile uint32_t  CMPF1:1;
N            __I  uint32_t  CO0:1;
X            volatile const  uint32_t  CO0:1;
N            __I  uint32_t  CO1:1;
X            volatile const  uint32_t  CO1:1;
N            __I  uint32_t  RESERVE:28;
X            volatile const  uint32_t  RESERVE:28;
N        } CMPSR;
N    };
N} ACMP_T;
N
N
N/* CMPCR Bit Field Definitions */
N#define ACMP_CMPCR_CMPCN_Pos       4
N#define ACMP_CMPCR_CMPCN_Msk       (1ul << ACMP_CMPCR_CMPCN_Pos)
N
N#define ACMP_CMPCR_CMP_HYSEN_Pos   2
N#define ACMP_CMPCR_CMP_HYSEN_Msk   (1ul << ACMP_CMPCR_CMP_HYSEN_Pos)
N
N#define ACMP_CMPCR_CMPIE_Pos       1
N#define ACMP_CMPCR_CMPIE_Msk       (1ul << ACMP_CMPCR_CMPIE_Pos)
N
N#define ACMP_CMPCR_CMPEN_Pos       0
N#define ACMP_CMPCR_CMPEN_Msk       (1ul << ACMP_CMPCR_CMPEN_Pos)
N
N/* CMPSR Bit Field Definitions */
N#define ACMP_CMPSR_CO1_Pos     3
N#define ACMP_CMPSR_CO1_Msk     (1ul << ACMP_CMPSR_CO1_Pos)
N
N#define ACMP_CMPSR_CO0_Pos     2
N#define ACMP_CMPSR_CO0_Msk     (1ul << ACMP_CMPSR_CO0_Pos)
N
N#define ACMP_CMPSR_CMPF1_Pos   1
N#define ACMP_CMPSR_CMPF1_Msk   (1ul << ACMP_CMPSR_CMPF1_Pos)
N
N#define ACMP_CMPSR_CMPF0_Pos   0
N#define ACMP_CMPSR_CMPF0_Msk   (1ul << ACMP_CMPSR_CMPF0_Pos)
N
N
N/*---------------------------- Clock Controller ------------------------------*/
Ntypedef struct
N{
N    __IO uint32_t  XTL12M_EN:1;
X    volatile uint32_t  XTL12M_EN:1;
N    __IO uint32_t  XTL32K_EN:1;
X    volatile uint32_t  XTL32K_EN:1;
N    __IO uint32_t  OSC22M_EN:1;
X    volatile uint32_t  OSC22M_EN:1;
N    __IO uint32_t  OSC10K_EN:1;
X    volatile uint32_t  OSC10K_EN:1;
N    __IO uint32_t  PD_WU_DLY:1;
X    volatile uint32_t  PD_WU_DLY:1;
N    __IO uint32_t  PD_WU_INT_EN:1;
X    volatile uint32_t  PD_WU_INT_EN:1;
N    __IO uint32_t  PD_WU_STS:1;
X    volatile uint32_t  PD_WU_STS:1;
N    __IO uint32_t  PWR_DOWN_EN:1;
X    volatile uint32_t  PWR_DOWN_EN:1;
N    __IO uint32_t  PD_WAIT_CPU:1;
X    volatile uint32_t  PD_WAIT_CPU:1;
N    __I  uint32_t  RESERVE:23;
X    volatile const  uint32_t  RESERVE:23;
N} SYSCLK_PWRCON_T;
N
Ntypedef struct
N{
N    __I  uint32_t  RESERVE0:1;
X    volatile const  uint32_t  RESERVE0:1;
N    __IO uint32_t  PDMA_EN:1;
X    volatile uint32_t  PDMA_EN:1;
N    __IO uint32_t  ISP_EN:1;
X    volatile uint32_t  ISP_EN:1;
N    __IO uint32_t  EBI_EN:1;
X    volatile uint32_t  EBI_EN:1;
N    __I  uint32_t  RESERVE1:28;
X    volatile const  uint32_t  RESERVE1:28;
N} SYSCLK_AHBCLK_T;
N
Ntypedef struct
N{
N    __IO uint32_t  WDT_EN:1;
X    volatile uint32_t  WDT_EN:1;
N    __IO uint32_t  RTC_EN:1;
X    volatile uint32_t  RTC_EN:1;
N    __IO uint32_t  TMR0_EN:1;
X    volatile uint32_t  TMR0_EN:1;
N    __IO uint32_t  TMR1_EN:1;
X    volatile uint32_t  TMR1_EN:1;
N    __IO uint32_t  TMR2_EN:1;
X    volatile uint32_t  TMR2_EN:1;
N    __IO uint32_t  TMR3_EN:1;
X    volatile uint32_t  TMR3_EN:1;
N    __IO uint32_t  FDIV_EN:1;
X    volatile uint32_t  FDIV_EN:1;
N    __I  uint32_t  RESERVE0:1;
X    volatile const  uint32_t  RESERVE0:1;
N    __IO uint32_t  I2C0_EN:1;
X    volatile uint32_t  I2C0_EN:1;
N    __IO uint32_t  I2C1_EN:1;
X    volatile uint32_t  I2C1_EN:1;
N    __I  uint32_t  RESERVE1:2;
X    volatile const  uint32_t  RESERVE1:2;
N    __IO uint32_t  SPI0_EN:1;
X    volatile uint32_t  SPI0_EN:1;
N    __IO uint32_t  SPI1_EN:1;
X    volatile uint32_t  SPI1_EN:1;
N    __IO uint32_t  SPI2_EN:1;
X    volatile uint32_t  SPI2_EN:1;
N    __IO uint32_t  SPI3_EN:1;
X    volatile uint32_t  SPI3_EN:1;
N    __IO uint32_t  UART0_EN:1;
X    volatile uint32_t  UART0_EN:1;
N    __IO uint32_t  UART1_EN:1;
X    volatile uint32_t  UART1_EN:1;
N    __IO uint32_t  UART2_EN:1;
X    volatile uint32_t  UART2_EN:1;
N    __I  uint32_t  RESERVE2:1;
X    volatile const  uint32_t  RESERVE2:1;
N    __IO uint32_t  PWM01_EN:1;
X    volatile uint32_t  PWM01_EN:1;
N    __IO uint32_t  PWM23_EN:1;
X    volatile uint32_t  PWM23_EN:1;
N    __IO uint32_t  PWM45_EN:1;
X    volatile uint32_t  PWM45_EN:1;
N    __IO uint32_t  PWM67_EN:1;
X    volatile uint32_t  PWM67_EN:1;
N    __IO uint32_t  CAN0_EN:1;
X    volatile uint32_t  CAN0_EN:1;
N    __I  uint32_t  RESERVE3:2;
X    volatile const  uint32_t  RESERVE3:2;
N    __IO uint32_t  USBD_EN:1;
X    volatile uint32_t  USBD_EN:1;
N    __IO uint32_t  ADC_EN:1;
X    volatile uint32_t  ADC_EN:1;
N    __IO uint32_t  I2S_EN:1;
X    volatile uint32_t  I2S_EN:1;
N    __IO uint32_t  ACMP_EN:1;
X    volatile uint32_t  ACMP_EN:1;
N    __IO uint32_t  PS2_EN:1;
X    volatile uint32_t  PS2_EN:1;
N} SYSCLK_APBCLK_T;
N
Ntypedef struct
N{
N    __I  uint32_t  XTL12M_STB:1;
X    volatile const  uint32_t  XTL12M_STB:1;
N    __I  uint32_t  XTL32K_STB:1;
X    volatile const  uint32_t  XTL32K_STB:1;
N    __I  uint32_t  PLL_STB:1;
X    volatile const  uint32_t  PLL_STB:1;
N    __I  uint32_t  OSC10K_STB:1;
X    volatile const  uint32_t  OSC10K_STB:1;
N    __I  uint32_t  OSC22M_STB:1;
X    volatile const  uint32_t  OSC22M_STB:1;
N    __I  uint32_t  RESERVE0:2;
X    volatile const  uint32_t  RESERVE0:2;
N    __IO uint32_t  CLK_SW_FAIL:1;
X    volatile uint32_t  CLK_SW_FAIL:1;
N    __I  uint32_t  RESERVE1:24;
X    volatile const  uint32_t  RESERVE1:24;
N} SYSCLK_CLKSTATUS_T;
N
Ntypedef struct
N{
N    __IO uint32_t  HCLK_S:3;
X    volatile uint32_t  HCLK_S:3;
N    __IO uint32_t  STCLK_S:3;
X    volatile uint32_t  STCLK_S:3;
N    __I  uint32_t  RESERVE:26;
X    volatile const  uint32_t  RESERVE:26;
N} SYSCLK_CLKSEL0_T;
N
N
Ntypedef struct
N{
N    __IO uint32_t  WDT_S:2;
X    volatile uint32_t  WDT_S:2;
N    __IO uint32_t  ADC_S:2;
X    volatile uint32_t  ADC_S:2;
N    __I  uint32_t  RESERVE1:4;
X    volatile const  uint32_t  RESERVE1:4;
N    __IO uint32_t  TMR0_S:3;
X    volatile uint32_t  TMR0_S:3;
N    __I  uint32_t  RESERVE2:1;
X    volatile const  uint32_t  RESERVE2:1;
N    __IO uint32_t  TMR1_S:3;
X    volatile uint32_t  TMR1_S:3;
N    __I  uint32_t  RESERVE3:1;
X    volatile const  uint32_t  RESERVE3:1;
N    __IO uint32_t  TMR2_S:3;
X    volatile uint32_t  TMR2_S:3;
N    __I  uint32_t  RESERVE4:1;
X    volatile const  uint32_t  RESERVE4:1;
N    __IO uint32_t  TMR3_S:3;
X    volatile uint32_t  TMR3_S:3;
N    __I  uint32_t  RESERVE5:1;
X    volatile const  uint32_t  RESERVE5:1;
N    __IO uint32_t  UART_S:2;
X    volatile uint32_t  UART_S:2;
N    __I  uint32_t  RESERVE6:2;
X    volatile const  uint32_t  RESERVE6:2;
N    __IO uint32_t  PWM01_S:2;
X    volatile uint32_t  PWM01_S:2;
N    __IO uint32_t  PWM23_S:2;
X    volatile uint32_t  PWM23_S:2;
N} SYSCLK_CLKSEL1_T;
N
Ntypedef struct
N{
N    __IO uint32_t  I2S_S:2;
X    volatile uint32_t  I2S_S:2;
N    __IO uint32_t  FRQDIV_S:2;
X    volatile uint32_t  FRQDIV_S:2;
N    __IO uint32_t  PWM45_S:2;
X    volatile uint32_t  PWM45_S:2;
N    __IO uint32_t  PWM67_S:2;
X    volatile uint32_t  PWM67_S:2;
N    __I  uint32_t  RESERVE:24;
X    volatile const  uint32_t  RESERVE:24;
N} SYSCLK_CLKSEL2_T;
N
Ntypedef struct
N{
N    __IO uint32_t  HCLK_N:4;
X    volatile uint32_t  HCLK_N:4;
N    __IO uint32_t  USB_N:4;
X    volatile uint32_t  USB_N:4;
N    __IO uint32_t  UART_N:4;
X    volatile uint32_t  UART_N:4;
N    __I  uint32_t  RESERVE0:4;
X    volatile const  uint32_t  RESERVE0:4;
N    __IO uint32_t  ADC_N:8;
X    volatile uint32_t  ADC_N:8;
N    __I  uint32_t  RESERVE1:8;
X    volatile const  uint32_t  RESERVE1:8;
N} SYSCLK_CLKDIV_T;
N
Ntypedef struct
N{
N    __IO uint32_t  FB_DV:9;
X    volatile uint32_t  FB_DV:9;
N    __IO uint32_t  IN_DV:5;
X    volatile uint32_t  IN_DV:5;
N    __IO uint32_t  OUT_DV:2;
X    volatile uint32_t  OUT_DV:2;
N    __IO uint32_t  PD:1;
X    volatile uint32_t  PD:1;
N    __IO uint32_t  BP:1;
X    volatile uint32_t  BP:1;
N    __IO uint32_t  OE:1;
X    volatile uint32_t  OE:1;
N    __IO uint32_t  PLL_SRC:1;
X    volatile uint32_t  PLL_SRC:1;
N    __I  uint32_t  RESERVE:12;
X    volatile const  uint32_t  RESERVE:12;
N} SYSCLK_PLLCON_T;
N
N
Ntypedef struct
N{    
N    __IO uint32_t  FSEL:4;
X    volatile uint32_t  FSEL:4;
N    __IO uint32_t  FDIV_EN:1;
X    volatile uint32_t  FDIV_EN:1;
N    __I  uint32_t  RESERVE:27;
X    volatile const  uint32_t  RESERVE:27;
N} SYSCLK_FRQDIV_T;
N
Ntypedef struct
N{
N    union 
N    {
N        __IO uint32_t u32PWRCON;
X        volatile uint32_t u32PWRCON;
N        
N        struct 
N        {
N            __IO uint32_t  XTL12M_EN:1;
X            volatile uint32_t  XTL12M_EN:1;
N            __IO uint32_t  XTL32K_EN:1;
X            volatile uint32_t  XTL32K_EN:1;
N            __IO uint32_t  OSC22M_EN:1;
X            volatile uint32_t  OSC22M_EN:1;
N            __IO uint32_t  OSC10K_EN:1;
X            volatile uint32_t  OSC10K_EN:1;
N            __IO uint32_t  PD_WU_DLY:1;
X            volatile uint32_t  PD_WU_DLY:1;
N            __IO uint32_t  PD_WU_INT_EN:1;
X            volatile uint32_t  PD_WU_INT_EN:1;
N            __IO uint32_t  PD_WU_STS:1;
X            volatile uint32_t  PD_WU_STS:1;
N            __IO uint32_t  PWR_DOWN_EN:1;
X            volatile uint32_t  PWR_DOWN_EN:1;
N            __IO uint32_t  PD_WAIT_CPU:1;
X            volatile uint32_t  PD_WAIT_CPU:1;
N            __I  uint32_t  RESERVE:23;
X            volatile const  uint32_t  RESERVE:23;
N        } PWRCON;
N    };    
N    
N    union 
N    {
N        __IO uint32_t u32AHBCLK;
X        volatile uint32_t u32AHBCLK;
N        
N        struct 
N        {
N            __I  uint32_t  RESERVE0:1;
X            volatile const  uint32_t  RESERVE0:1;
N            __IO uint32_t  PDMA_EN:1;
X            volatile uint32_t  PDMA_EN:1;
N            __IO uint32_t  ISP_EN:1;
X            volatile uint32_t  ISP_EN:1;
N            __IO uint32_t  EBI_EN:1;
X            volatile uint32_t  EBI_EN:1;
N            __I  uint32_t  RESERVE1:28;
X            volatile const  uint32_t  RESERVE1:28;
N        } AHBCLK;
N    };    
N
N    union 
N    {
N        __IO uint32_t u32APBCLK;
X        volatile uint32_t u32APBCLK;
N        
N        struct 
N        {
N            __IO uint32_t  WDT_EN:1;
X            volatile uint32_t  WDT_EN:1;
N            __IO uint32_t  RTC_EN:1;
X            volatile uint32_t  RTC_EN:1;
N            __IO uint32_t  TMR0_EN:1;
X            volatile uint32_t  TMR0_EN:1;
N            __IO uint32_t  TMR1_EN:1;
X            volatile uint32_t  TMR1_EN:1;
N            __IO uint32_t  TMR2_EN:1;
X            volatile uint32_t  TMR2_EN:1;
N            __IO uint32_t  TMR3_EN:1;
X            volatile uint32_t  TMR3_EN:1;
N            __IO uint32_t  FDIV_EN:1;
X            volatile uint32_t  FDIV_EN:1;
N            __I  uint32_t  RESERVE0:1;
X            volatile const  uint32_t  RESERVE0:1;
N            __IO uint32_t  I2C0_EN:1;
X            volatile uint32_t  I2C0_EN:1;
N            __IO uint32_t  I2C1_EN:1;
X            volatile uint32_t  I2C1_EN:1;
N            __I  uint32_t  RESERVE1:2;
X            volatile const  uint32_t  RESERVE1:2;
N            __IO uint32_t  SPI0_EN:1;
X            volatile uint32_t  SPI0_EN:1;
N            __IO uint32_t  SPI1_EN:1;
X            volatile uint32_t  SPI1_EN:1;
N            __IO uint32_t  SPI2_EN:1;
X            volatile uint32_t  SPI2_EN:1;
N            __IO uint32_t  SPI3_EN:1;
X            volatile uint32_t  SPI3_EN:1;
N            __IO uint32_t  UART0_EN:1;
X            volatile uint32_t  UART0_EN:1;
N            __IO uint32_t  UART1_EN:1;
X            volatile uint32_t  UART1_EN:1;
N            __IO uint32_t  UART2_EN:1;
X            volatile uint32_t  UART2_EN:1;
N            __I  uint32_t  RESERVE2:1;
X            volatile const  uint32_t  RESERVE2:1;
N            __IO uint32_t  PWM01_EN:1;
X            volatile uint32_t  PWM01_EN:1;
N            __IO uint32_t  PWM23_EN:1;
X            volatile uint32_t  PWM23_EN:1;
N            __IO uint32_t  PWM45_EN:1;
X            volatile uint32_t  PWM45_EN:1;
N            __IO uint32_t  PWM67_EN:1;
X            volatile uint32_t  PWM67_EN:1;
N            __IO uint32_t  CAN0_EN:1;
X            volatile uint32_t  CAN0_EN:1;
N            __I  uint32_t  RESERVE3:2;
X            volatile const  uint32_t  RESERVE3:2;
N            __IO uint32_t  USBD_EN:1;
X            volatile uint32_t  USBD_EN:1;
N            __IO uint32_t  ADC_EN:1;
X            volatile uint32_t  ADC_EN:1;
N            __IO uint32_t  I2S_EN:1;
X            volatile uint32_t  I2S_EN:1;
N            __IO uint32_t  ACMP_EN:1;
X            volatile uint32_t  ACMP_EN:1;
N            __IO uint32_t  PS2_EN:1;
X            volatile uint32_t  PS2_EN:1;
N        } APBCLK;
N    };          
N
N    union 
N    {
N        __IO uint32_t u32CLKSTATUS;
X        volatile uint32_t u32CLKSTATUS;
N        
N        struct 
N        {
N            __I  uint32_t  XTL12M_STB:1;
X            volatile const  uint32_t  XTL12M_STB:1;
N            __I  uint32_t  XTL32K_STB:1;
X            volatile const  uint32_t  XTL32K_STB:1;
N            __I  uint32_t  PLL_STB:1;
X            volatile const  uint32_t  PLL_STB:1;
N            __I  uint32_t  OSC10K_STB:1;
X            volatile const  uint32_t  OSC10K_STB:1;
N            __I  uint32_t  OSC22M_STB:1;
X            volatile const  uint32_t  OSC22M_STB:1;
N            __I  uint32_t  RESERVE0:2;
X            volatile const  uint32_t  RESERVE0:2;
N            __IO uint32_t  CLK_SW_FAIL:1;
X            volatile uint32_t  CLK_SW_FAIL:1;
N            __I  uint32_t  RESERVE1:24;
X            volatile const  uint32_t  RESERVE1:24;
N        } CLKSTATUS;
N    };  
N
N    union 
N    {
N        __IO uint32_t u32CLKSEL0;
X        volatile uint32_t u32CLKSEL0;
N        
N        struct 
N        {
N            __IO uint32_t  HCLK_S:3;
X            volatile uint32_t  HCLK_S:3;
N            __IO uint32_t  STCLK_S:3;
X            volatile uint32_t  STCLK_S:3;
N            __I  uint32_t  RESERVE:26;
X            volatile const  uint32_t  RESERVE:26;
N        } CLKSEL0;
N    };  
N
N    union 
N    {
N        __IO uint32_t u32CLKSEL1;
X        volatile uint32_t u32CLKSEL1;
N        
N        struct 
N        {
N            __IO uint32_t  WDT_S:2;
X            volatile uint32_t  WDT_S:2;
N            __IO uint32_t  ADC_S:2;
X            volatile uint32_t  ADC_S:2;
N            __I  uint32_t  RESERVE1:4;
X            volatile const  uint32_t  RESERVE1:4;
N            __IO uint32_t  TMR0_S:3;
X            volatile uint32_t  TMR0_S:3;
N            __I  uint32_t  RESERVE2:1;
X            volatile const  uint32_t  RESERVE2:1;
N            __IO uint32_t  TMR1_S:3;
X            volatile uint32_t  TMR1_S:3;
N            __I  uint32_t  RESERVE3:1;
X            volatile const  uint32_t  RESERVE3:1;
N            __IO uint32_t  TMR2_S:3;
X            volatile uint32_t  TMR2_S:3;
N            __I  uint32_t  RESERVE4:1;
X            volatile const  uint32_t  RESERVE4:1;
N            __IO uint32_t  TMR3_S:3;
X            volatile uint32_t  TMR3_S:3;
N            __I  uint32_t  RESERVE5:1;
X            volatile const  uint32_t  RESERVE5:1;
N            __IO uint32_t  UART_S:2;
X            volatile uint32_t  UART_S:2;
N            __I  uint32_t  RESERVE6:2;
X            volatile const  uint32_t  RESERVE6:2;
N            __IO uint32_t  PWM01_S:2;
X            volatile uint32_t  PWM01_S:2;
N            __IO uint32_t  PWM23_S:2;
X            volatile uint32_t  PWM23_S:2;
N        } CLKSEL1;
N    };  
N
N    union 
N    {
N        __IO uint32_t u32CLKDIV;
X        volatile uint32_t u32CLKDIV;
N        
N        struct 
N        {
N            __IO uint32_t  HCLK_N:4;
X            volatile uint32_t  HCLK_N:4;
N            __IO uint32_t  USB_N:4;
X            volatile uint32_t  USB_N:4;
N            __IO uint32_t  UART_N:4;
X            volatile uint32_t  UART_N:4;
N            __I  uint32_t  RESERVE0:4;
X            volatile const  uint32_t  RESERVE0:4;
N            __IO uint32_t  ADC_N:8;
X            volatile uint32_t  ADC_N:8;
N            __I  uint32_t  RESERVE1:8;
X            volatile const  uint32_t  RESERVE1:8;
N        } CLKDIV;
N    };  
N
N    union 
N    {
N        __IO uint32_t u32CLKSEL2;
X        volatile uint32_t u32CLKSEL2;
N        
N        struct 
N        {
N            __IO uint32_t  I2S_S:2;
X            volatile uint32_t  I2S_S:2;
N            __IO uint32_t  FRQDIV_S:2;
X            volatile uint32_t  FRQDIV_S:2;
N            __IO uint32_t  PWM45_S:2;
X            volatile uint32_t  PWM45_S:2;
N            __IO uint32_t  PWM67_S:2;
X            volatile uint32_t  PWM67_S:2;
N            __I  uint32_t  RESERVE:24;
X            volatile const  uint32_t  RESERVE:24;
N        } CLKSEL2;
N    };  
N    
N    union 
N    {
N        __IO uint32_t u32PLLCON;
X        volatile uint32_t u32PLLCON;
N        
N        struct 
N        {
N            __IO uint32_t  FB_DV:9;
X            volatile uint32_t  FB_DV:9;
N            __IO uint32_t  IN_DV:5;
X            volatile uint32_t  IN_DV:5;
N            __IO uint32_t  OUT_DV:2;
X            volatile uint32_t  OUT_DV:2;
N            __IO uint32_t  PD:1;
X            volatile uint32_t  PD:1;
N            __IO uint32_t  BP:1;
X            volatile uint32_t  BP:1;
N            __IO uint32_t  OE:1;
X            volatile uint32_t  OE:1;
N            __IO uint32_t  PLL_SRC:1;
X            volatile uint32_t  PLL_SRC:1;
N            __I  uint32_t  RESERVE:12;
X            volatile const  uint32_t  RESERVE:12;
N        } PLLCON;
N    };  
N    
N    union 
N    {
N        __IO uint32_t u32FRQDIV;
X        volatile uint32_t u32FRQDIV;
N        
N        struct 
N        {
N            __IO uint32_t  FSEL:4;
X            volatile uint32_t  FSEL:4;
N            __IO uint32_t  FDIV_EN:1;
X            volatile uint32_t  FDIV_EN:1;
N            __I  uint32_t  RESERVE:27;
X            volatile const  uint32_t  RESERVE:27;
N        } FRQDIV;
N    };      
N} SYSCLK_T;
N
N/* SYSCLK PWRCON Bit Field Definitions */
N#define SYSCLK_PWRCON_PD_WAIT_CPU_Pos           8
N#define SYSCLK_PWRCON_PD_WAIT_CPU_Msk           (1ul << SYSCLK_PWRCON_PD_WAIT_CPU_Pos)
N
N#define SYSCLK_PWRCON_PWR_DOWN_EN_Pos           7
N#define SYSCLK_PWRCON_PWR_DOWN_EN_Msk           (1ul << SYSCLK_PWRCON_PWR_DOWN_EN_Pos)
N
N#define SYSCLK_PWRCON_PD_WU_STS_Pos             6
N#define SYSCLK_PWRCON_PD_WU_STS_Msk             (1ul << SYSCLK_PWRCON_PD_WU_STS_Pos)
N
N#define SYSCLK_PWRCON_PD_WU_INT_EN_Pos          5
N#define SYSCLK_PWRCON_PD_WU_INT_EN_Msk          (1ul << SYSCLK_PWRCON_PD_WU_INT_EN_Pos)
N
N#define SYSCLK_PWRCON_PD_WU_DLY_Pos             4
N#define SYSCLK_PWRCON_PD_WU_DLY_Msk             (1ul << SYSCLK_PWRCON_PD_WU_DLY_Pos)
N
N#define SYSCLK_PWRCON_OSC10K_EN_Pos             3
N#define SYSCLK_PWRCON_OSC10K_EN_Msk             (1ul << SYSCLK_PWRCON_OSC10K_EN_Pos)
N
N#define SYSCLK_PWRCON_OSC22M_EN_Pos             2
N#define SYSCLK_PWRCON_OSC22M_EN_Msk             (1ul << SYSCLK_PWRCON_OSC22M_EN_Pos)
N
N#define SYSCLK_PWRCON_XTL32K_EN_Pos             1
N#define SYSCLK_PWRCON_XTL32K_EN_Msk             (1ul << SYSCLK_PWRCON_XTL32K_EN_Pos)
N
N#define SYSCLK_PWRCON_XTL12M_EN_Pos             0
N#define SYSCLK_PWRCON_XTL12M_EN_Msk             (1ul << SYSCLK_PWRCON_XTL12M_EN_Pos)
N
N/* SYSCLK AHBCLK Bit Field Definitions */
N#define SYSCLK_AHBCLK_EBI_EN_Pos                3
N#define SYSCLK_AHBCLK_EBI_EN_Msk                (1ul << SYSCLK_AHBCLK_EBI_EN_Pos)
N
N#define SYSCLK_AHBCLK_ISP_EN_Pos                2
N#define SYSCLK_AHBCLK_ISP_EN_Msk                (1ul << SYSCLK_AHBCLK_ISP_EN_Pos)
N
N#define SYSCLK_AHBCLK_PDMA_EN_Pos               1
N#define SYSCLK_AHBCLK_PDMA_EN_Msk               (1ul << SYSCLK_AHBCLK_PDMA_EN_Pos)
N
N
N/* SYSCLK APBCLK Bit Field Definitions */
N#define SYSCLK_APBCLK_PS2_EN_Pos                31
N#define SYSCLK_APBCLK_PS2_EN_Msk                (1ul << SYSCLK_APBCLK_PS2_EN_Pos)
N
N#define SYSCLK_APBCLK_ACMP_EN_Pos               30
N#define SYSCLK_APBCLK_ACMP_EN_Msk               (1ul << SYSCLK_APBCLK_ACMP_EN_Pos)
N
N#define SYSCLK_APBCLK_I2S_EN_Pos                29
N#define SYSCLK_APBCLK_I2S_EN_Msk                (1ul << SYSCLK_APBCLK_I2S_EN_Pos)
N
N#define SYSCLK_APBCLK_ADC_EN_Pos                28
N#define SYSCLK_APBCLK_ADC_EN_Msk                (1ul << SYSCLK_APBCLK_ADC_EN_Pos)
N
N#define SYSCLK_APBCLK_USBD_EN_Pos               27
N#define SYSCLK_APBCLK_USBD_EN_Msk               (1ul << SYSCLK_APBCLK_USBD_EN_Pos)
N
N#define SYSCLK_APBCLK_CAN0_EN_Pos               24
N#define SYSCLK_APBCLK_CAN0_EN_Msk               (1ul << SYSCLK_APBCLK_CAN0_EN_Pos)
N
N#define SYSCLK_APBCLK_PWM67_EN_Pos              23
N#define SYSCLK_APBCLK_PWM67_EN_Msk              (1ul << SYSCLK_APBCLK_PWM67_EN_Pos)
N
N#define SYSCLK_APBCLK_PWM45_EN_Pos              22
N#define SYSCLK_APBCLK_PWM45_EN_Msk              (1ul << SYSCLK_APBCLK_PWM45_EN_Pos)
N
N#define SYSCLK_APBCLK_PWM23_EN_Pos              21
N#define SYSCLK_APBCLK_PWM23_EN_Msk              (1ul << SYSCLK_APBCLK_PWM23_EN_Pos)
N
N#define SYSCLK_APBCLK_PWM01_EN_Pos              20
N#define SYSCLK_APBCLK_PWM01_EN_Msk              (1ul << SYSCLK_APBCLK_PWM01_EN_Pos)
N
N#define SYSCLK_APBCLK_UART2_EN_Pos              18
N#define SYSCLK_APBCLK_UART2_EN_Msk              (1ul << SYSCLK_APBCLK_UART2_EN_Pos)
N
N#define SYSCLK_APBCLK_UART1_EN_Pos              17
N#define SYSCLK_APBCLK_UART1_EN_Msk              (1ul << SYSCLK_APBCLK_UART1_EN_Pos)
N
N#define SYSCLK_APBCLK_UART0_EN_Pos              16
N#define SYSCLK_APBCLK_UART0_EN_Msk              (1ul << SYSCLK_APBCLK_UART0_EN_Pos)
N
N#define SYSCLK_APBCLK_SPI3_EN_Pos               15
N#define SYSCLK_APBCLK_SPI3_EN_Msk               (1ul << SYSCLK_APBCLK_SPI3_EN_Pos)
N
N#define SYSCLK_APBCLK_SPI2_EN_Pos               14
N#define SYSCLK_APBCLK_SPI2_EN_Msk               (1ul << SYSCLK_APBCLK_SPI2_EN_Pos)
N
N#define SYSCLK_APBCLK_SPI1_EN_Pos               13
N#define SYSCLK_APBCLK_SPI1_EN_Msk               (1ul << SYSCLK_APBCLK_SPI1_EN_Pos)
N
N#define SYSCLK_APBCLK_SPI0_EN_Pos               12
N#define SYSCLK_APBCLK_SPI0_EN_Msk               (1ul << SYSCLK_APBCLK_SPI0_EN_Pos)
N
N#define SYSCLK_APBCLK_I2C1_EN_Pos               9
N#define SYSCLK_APBCLK_I2C1_EN_Msk               (1ul << SYSCLK_APBCLK_I2C1_EN_Pos)
N
N#define SYSCLK_APBCLK_I2C0_EN_Pos               8
N#define SYSCLK_APBCLK_I2C0_EN_Msk               (1ul << SYSCLK_APBCLK_I2C0_EN_Pos)
N
N#define SYSCLK_APBCLK_FDIV_EN_Pos               6
N#define SYSCLK_APBCLK_FDIV_EN_Msk               (1ul << SYSCLK_APBCLK_FDIV_EN_Pos)
N
N#define SYSCLK_APBCLK_TMR3_EN_Pos               5
N#define SYSCLK_APBCLK_TMR3_EN_Msk               (1ul << SYSCLK_APBCLK_TMR3_EN_Pos)
N
N#define SYSCLK_APBCLK_TMR2_EN_Pos               4
N#define SYSCLK_APBCLK_TMR2_EN_Msk               (1ul << SYSCLK_APBCLK_TMR2_EN_Pos)
N
N#define SYSCLK_APBCLK_TMR1_EN_Pos               3
N#define SYSCLK_APBCLK_TMR1_EN_Msk               (1ul << SYSCLK_APBCLK_TMR1_EN_Pos)
N                                                
N#define SYSCLK_APBCLK_TMR0_EN_Pos               2
N#define SYSCLK_APBCLK_TMR0_EN_Msk               (1ul << SYSCLK_APBCLK_TMR0_EN_Pos)
N
N#define SYSCLK_APBCLK_RTC_EN_Pos                1
N#define SYSCLK_APBCLK_RTC_EN_Msk                (1ul << SYSCLK_APBCLK_RTC_EN_Pos)
N
N#define SYSCLK_APBCLK_WDT_EN_Pos                0
N#define SYSCLK_APBCLK_WDT_EN_Msk                (1ul << SYSCLK_APBCLK_WDT_EN_Pos)
N
N/* SYSCLK CLKSTATUS Bit Field Definitions */
N#define SYSCLK_CLKSTATUS_CLK_SW_FAIL_Pos        7
N#define SYSCLK_CLKSTATUS_CLK_SW_FAIL_Msk        (1ul << SYSCLK_CLKSTATUS_CLK_SW_FAIL_Pos)
N
N#define SYSCLK_CLKSTATUS_OSC22M_STB_Pos         4
N#define SYSCLK_CLKSTATUS_OSC22M_STB_Msk         (1ul << SYSCLK_CLKSTATUS_OSC22M_STB_Pos)
N
N#define SYSCLK_CLKSTATUS_OSC10K_STB_Pos         3
N#define SYSCLK_CLKSTATUS_OSC10K_STB_Msk         (1ul << SYSCLK_CLKSTATUS_OSC10K_STB_Pos)
N
N#define SYSCLK_CLKSTATUS_PLL_STB_Pos            2
N#define SYSCLK_CLKSTATUS_PLL_STB_Msk            (1ul << SYSCLK_CLKSTATUS_PLL_STB_Pos)
N
N#define SYSCLK_CLKSTATUS_XTL32K_STB_Pos         1
N#define SYSCLK_CLKSTATUS_XTL32K_STB_Msk         (1ul << SYSCLK_CLKSTATUS_XTL32K_STB_Pos)
N
N#define SYSCLK_CLKSTATUS_XTL12M_STB_Pos         0
N#define SYSCLK_CLKSTATUS_XTL12M_STB_Msk         (1ul << SYSCLK_CLKSTATUS_XTL12M_STB_Pos)
N
N/* SYSCLK CLKSEL0 Bit Field Definitions */
N#define SYSCLK_CLKSEL0_STCLK_S_Pos              3
N#define SYSCLK_CLKSEL0_STCLK_S_Msk              (7ul << SYSCLK_CLKSEL0_STCLK_S_Pos)
N
N#define SYSCLK_CLKSEL0_HCLK_S_Pos               0
N#define SYSCLK_CLKSEL0_HCLK_S_Msk               (7ul << SYSCLK_CLKSEL0_HCLK_S_Pos)
N
N/* SYSCLK CLKSEL1 Bit Field Definitions */
N#define SYSCLK_CLKSEL1_PWM23_S_Pos              30
N#define SYSCLK_CLKSEL1_PWM23_S_Msk              (3ul << SYSCLK_CLKSEL1_PWM23_S_Pos)
N
N#define SYSCLK_CLKSEL1_PWM01_S_Pos              28
N#define SYSCLK_CLKSEL1_PWM01_S_Msk              (3ul << SYSCLK_CLKSEL1_PWM01_S_Pos)
N
N#define SYSCLK_CLKSEL1_UART_S_Pos               24
N#define SYSCLK_CLKSEL1_UART_S_Msk               (7ul << SYSCLK_CLKSEL1_UART_S_Pos)
N
N#define SYSCLK_CLKSEL1_TMR3_S_Pos               20
N#define SYSCLK_CLKSEL1_TMR3_S_Msk               (7ul << SYSCLK_CLKSEL1_TMR3_S_Pos)
N
N#define SYSCLK_CLKSEL1_TMR2_S_Pos               16
N#define SYSCLK_CLKSEL1_TMR2_S_Msk               (7ul << SYSCLK_CLKSEL1_TMR2_S_Pos)
N
N#define SYSCLK_CLKSEL1_TMR1_S_Pos               12
N#define SYSCLK_CLKSEL1_TMR1_S_Msk               (7ul << SYSCLK_CLKSEL1_TMR1_S_Pos)
N
N#define SYSCLK_CLKSEL1_TMR0_S_Pos               8
N#define SYSCLK_CLKSEL1_TMR0_S_Msk               (7ul << SYSCLK_CLKSEL1_TMR0_S_Pos)
N
N#define SYSCLK_CLKSEL1_ADC_S_Pos                2
N#define SYSCLK_CLKSEL1_ADC_S_Msk                (3ul << SYSCLK_CLKSEL1_ADC_S_Pos)
N
N#define SYSCLK_CLKSEL1_WDT_S_Pos                0
N#define SYSCLK_CLKSEL1_WDT_S_Msk                (3ul << SYSCLK_CLKSEL1_WDT_S_Pos)
N
N/* SYSCLK CLKSEL2 Bit Field Definitions */
N#define SYSCLK_CLKSEL2_PWM67_S_Pos              6
N#define SYSCLK_CLKSEL2_PWM67_S_Msk              (3ul << SYSCLK_CLKSEL2_PWM67_S_Pos)
N
N#define SYSCLK_CLKSEL2_PWM45_S_Pos              4
N#define SYSCLK_CLKSEL2_PWM45_S_Msk              (3ul << SYSCLK_CLKSEL2_PWM45_S_Pos)
N
N#define SYSCLK_CLKSEL2_FRQDIV_S_Pos             2
N#define SYSCLK_CLKSEL2_FRQDIV_S_Msk             (3ul << SYSCLK_CLKSEL2_FRQDIV_S_Pos)
N
N#define SYSCLK_CLKSEL2_I2S_S_Pos                0
N#define SYSCLK_CLKSEL2_I2S_S_Msk                (3ul << SYSCLK_CLKSEL2_I2S_S_Pos)
N
N/* SYSCLK CLKDIV Bit Field Definitions */
N#define SYSCLK_CLKDIV_ADC_N_Pos                 16
N#define SYSCLK_CLKDIV_ADC_N_Msk                 (0xFFul << SYSCLK_CLKDIV_ADC_N_Pos)
N
N#define SYSCLK_CLKDIV_UART_N_Pos                8
N#define SYSCLK_CLKDIV_UART_N_Msk                (0xFul << SYSCLK_CLKDIV_UART_N_Pos)
N
N#define SYSCLK_CLKDIV_USB_N_Pos                 4
N#define SYSCLK_CLKDIV_USB_N_Msk                 (0xFul << SYSCLK_CLKDIV_USB_N_Pos)
N
N#define SYSCLK_CLKDIV_HCLK_N_Pos                0
N#define SYSCLK_CLKDIV_HCLK_N_Msk                (0xFul << SYSCLK_CLKDIV_HCLK_N_Pos)
N
N/* SYSCLK PLLCON Bit Field Definitions */
N#define SYSCLK_PLLCON_PLL_SRC_Pos               19
N#define SYSCLK_PLLCON_PLL_SRC_Msk               (1ul << SYSCLK_PLLCON_PLL_SRC_Pos)
N
N#define SYSCLK_PLLCON_OE_Pos                    18
N#define SYSCLK_PLLCON_OE_Msk                    (1ul << SYSCLK_PLLCON_OE_Pos)
N
N#define SYSCLK_PLLCON_BP_Pos                    17
N#define SYSCLK_PLLCON_BP_Msk                    (1ul << SYSCLK_PLLCON_BP_Pos)
N
N#define SYSCLK_PLLCON_PD_Pos                    16
N#define SYSCLK_PLLCON_PD_Msk                    (1ul << SYSCLK_PLLCON_PD_Pos)
N
N#define SYSCLK_PLLCON_OUT_DV_Pos                14
N#define SYSCLK_PLLCON_OUT_DV_Msk                (3ul << SYSCLK_PLLCON_OUT_DV_Pos)
N
N#define SYSCLK_PLLCON_IN_DV_Pos                 9
N#define SYSCLK_PLLCON_IN_DV_Msk                 (0x1Ful << SYSCLK_PLLCON_IN_DV_Pos)
N
N#define SYSCLK_PLLCON_FB_DV_Pos                 0
N#define SYSCLK_PLLCON_FB_DV_Msk                 (0x1FFul << SYSCLK_PLLCON_FB_DV_Pos)
N
N/* SYSCLK FRQDIV Bit Field Definitions */
N#define SYSCLK_FRQDIV_FDIV_EN_Pos               4
N#define SYSCLK_FRQDIV_FDIV_EN_Msk               (1ul << SYSCLK_FRQDIV_FDIV_EN_Pos)
N
N#define SYSCLK_FRQDIV_FSEL_Pos                  0
N#define SYSCLK_FRQDIV_FSEL_Msk                  (0xFul << SYSCLK_FRQDIV_FSEL_Pos)
N
N/*---------------------------- Global Controller -----------------------------*/
Ntypedef __I uint32_t GCR_PDID_T;  
Xtypedef volatile const uint32_t GCR_PDID_T;  
N
Ntypedef struct
N{
N    __IO uint32_t  RSTS_POR:1;
X    volatile uint32_t  RSTS_POR:1;
N    __IO uint32_t  RSTS_RESET:1;
X    volatile uint32_t  RSTS_RESET:1;
N    __IO uint32_t  RSTS_WDT:1;
X    volatile uint32_t  RSTS_WDT:1;
N    __IO uint32_t  RSTS_LVR:1;
X    volatile uint32_t  RSTS_LVR:1;
N    __IO uint32_t  RSTS_BOD:1;
X    volatile uint32_t  RSTS_BOD:1;
N    __IO uint32_t  RSTS_SYS:1;
X    volatile uint32_t  RSTS_SYS:1;
N    __I  uint32_t  RESERVE0:1;
X    volatile const  uint32_t  RESERVE0:1;
N    __IO uint32_t  RSTS_CPU:1;    
X    volatile uint32_t  RSTS_CPU:1;    
N    __I  uint32_t  RESERVE1:24;
X    volatile const  uint32_t  RESERVE1:24;
N} GCR_RSTSRC_T;
N
N
Ntypedef struct
N{
N    __IO uint32_t  CHIP_RST:1;
X    volatile uint32_t  CHIP_RST:1;
N    __IO uint32_t  CPU_RST:1;
X    volatile uint32_t  CPU_RST:1;
N    __IO uint32_t  PDMA_RST:1;
X    volatile uint32_t  PDMA_RST:1;
N    __IO uint32_t  EBI_RST:1;
X    volatile uint32_t  EBI_RST:1;
N    __I  uint32_t  RESERVE:28;
X    volatile const  uint32_t  RESERVE:28;
N} GCR_IPRSTC1_T;
N
Ntypedef struct
N{
N    __I  uint32_t  RESERVE0:1;
X    volatile const  uint32_t  RESERVE0:1;
N    __IO uint32_t  GPIO_RST:1;
X    volatile uint32_t  GPIO_RST:1;
N    __IO uint32_t  TMR0_RST:1;
X    volatile uint32_t  TMR0_RST:1;
N    __IO uint32_t  TMR1_RST:1;
X    volatile uint32_t  TMR1_RST:1;
N    __IO uint32_t  TMR2_RST:1;
X    volatile uint32_t  TMR2_RST:1;
N    __IO uint32_t  TMR3_RST:1;
X    volatile uint32_t  TMR3_RST:1;
N    __I  uint32_t  RESERVE1:2;
X    volatile const  uint32_t  RESERVE1:2;
N    __IO uint32_t  I2C0_RST:1;
X    volatile uint32_t  I2C0_RST:1;
N    __IO uint32_t  I2C1_RST:1;
X    volatile uint32_t  I2C1_RST:1;
N    __I  uint32_t  RESERVE2:2;
X    volatile const  uint32_t  RESERVE2:2;
N    __IO uint32_t  SPI0_RST:1;
X    volatile uint32_t  SPI0_RST:1;
N    __IO uint32_t  SPI1_RST:1;
X    volatile uint32_t  SPI1_RST:1;
N    __IO uint32_t  SPI2_RST:1;
X    volatile uint32_t  SPI2_RST:1;
N    __IO uint32_t  SPI3_RST:1;
X    volatile uint32_t  SPI3_RST:1;
N    __IO uint32_t  UART0_RST:1;
X    volatile uint32_t  UART0_RST:1;
N    __IO uint32_t  UART1_RST:1;
X    volatile uint32_t  UART1_RST:1;
N    __IO uint32_t  UART2_RST:1;
X    volatile uint32_t  UART2_RST:1;
N    __I  uint32_t  RESERVE3:1;
X    volatile const  uint32_t  RESERVE3:1;
N    __IO uint32_t  PWM03_RST:1;
X    volatile uint32_t  PWM03_RST:1;
N    __IO uint32_t  PWM47_RST:1;
X    volatile uint32_t  PWM47_RST:1;
N    __IO uint32_t  ACMP_RST:1;
X    volatile uint32_t  ACMP_RST:1;
N    __IO uint32_t  PS2_RST:1;
X    volatile uint32_t  PS2_RST:1;
N    __IO uint32_t  CAN0_RST:1;
X    volatile uint32_t  CAN0_RST:1;
N    __I  uint32_t  RESERVE4:2;
X    volatile const  uint32_t  RESERVE4:2;
N    __IO uint32_t  USBD_RST:1;
X    volatile uint32_t  USBD_RST:1;
N    __IO uint32_t  ADC_RST:1;
X    volatile uint32_t  ADC_RST:1;
N    __IO uint32_t  I2S_RST:1;
X    volatile uint32_t  I2S_RST:1;
N    __I  uint32_t  RESERVE5:2;
X    volatile const  uint32_t  RESERVE5:2;
N} GCR_IPRSTC2_T;
N
Ntypedef struct
N{
N    __IO uint32_t  HPE:1;
X    volatile uint32_t  HPE:1;
N    __I  uint32_t  RESERVE:31;
X    volatile const  uint32_t  RESERVE:31;
N} GCR_CPR_T;
N
N
Ntypedef struct
N{
N    __IO uint32_t  BOD_EN:1;
X    volatile uint32_t  BOD_EN:1;
N    __IO uint32_t  BOD_VL:2;
X    volatile uint32_t  BOD_VL:2;
N    __IO uint32_t  BOD_RSTEN:1;
X    volatile uint32_t  BOD_RSTEN:1;
N    __IO uint32_t  BOD_INTF:1;
X    volatile uint32_t  BOD_INTF:1;
N    __IO uint32_t  BOD_LPM:1;
X    volatile uint32_t  BOD_LPM:1;
N    __IO uint32_t  BOD_OUT:1;
X    volatile uint32_t  BOD_OUT:1;
N    __IO uint32_t  LVR_EN:1;
X    volatile uint32_t  LVR_EN:1;
N    __I  uint32_t  RESERVE1:24;
X    volatile const  uint32_t  RESERVE1:24;
N} GCR_BODCR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  VTEMP_EN:1;
X    volatile uint32_t  VTEMP_EN:1;
N    __I  uint32_t  RESERVE:31;
X    volatile const  uint32_t  RESERVE:31;
N} GCR_TEMPCR_T;
N
Ntypedef __IO uint32_t GCR_PORCR_T;  
Xtypedef volatile uint32_t GCR_PORCR_T;  
N
Ntypedef struct
N{
N    __IO uint32_t ADC0:1;
X    volatile uint32_t ADC0:1;
N    __IO uint32_t ADC1_AD12:1;
X    volatile uint32_t ADC1_AD12:1;
N    __IO uint32_t ADC2_AD11:1;
X    volatile uint32_t ADC2_AD11:1;
N    __IO uint32_t ADC3_AD10:1;
X    volatile uint32_t ADC3_AD10:1;
N    __IO uint32_t ADC4_AD9:1;
X    volatile uint32_t ADC4_AD9:1;
N    __IO uint32_t ADC5_AD8:1;
X    volatile uint32_t ADC5_AD8:1;
N    __IO uint32_t ADC6_AD7:1;
X    volatile uint32_t ADC6_AD7:1;
N    __IO uint32_t ADC7_SS21_AD6:1;
X    volatile uint32_t ADC7_SS21_AD6:1;
N    __IO uint32_t I2C0_SDA:1;
X    volatile uint32_t I2C0_SDA:1;
N    __IO uint32_t I2C0_SCL:1;
X    volatile uint32_t I2C0_SCL:1;
N    __IO uint32_t I2C1_SDA_nWR:1;
X    volatile uint32_t I2C1_SDA_nWR:1;
N    __IO uint32_t I2C1_SCL_nRD:1;
X    volatile uint32_t I2C1_SCL_nRD:1;
N    __IO uint32_t PWM0_AD13:1;
X    volatile uint32_t PWM0_AD13:1;
N    __IO uint32_t PWM1_AD14:1;
X    volatile uint32_t PWM1_AD14:1;
N    __IO uint32_t PWM2_AD15:1;
X    volatile uint32_t PWM2_AD15:1;
N    __IO uint32_t PWM3_I2SMCLK:1;
X    volatile uint32_t PWM3_I2SMCLK:1;
N    __IO uint32_t SCHMITT:16;    
X    volatile uint32_t SCHMITT:16;    
N} GCR_GPAMFP_T;
N
Ntypedef struct
N{
N    __IO uint32_t UART0_RX:1;
X    volatile uint32_t UART0_RX:1;
N    __IO uint32_t UART0_TX:1;
X    volatile uint32_t UART0_TX:1;
N    __IO uint32_t UART0_nRTS_nWRL:1;
X    volatile uint32_t UART0_nRTS_nWRL:1;
N    __IO uint32_t UART0_nCTS_nWRH:1;
X    volatile uint32_t UART0_nCTS_nWRH:1;
N    __IO uint32_t UART1_RX:1;
X    volatile uint32_t UART1_RX:1;
N    __IO uint32_t UART1_TX:1;
X    volatile uint32_t UART1_TX:1;
N    __IO uint32_t UART1_nRTS_ALE:1;
X    volatile uint32_t UART1_nRTS_ALE:1;
N    __IO uint32_t UART1_nCTS_nCS:1;
X    volatile uint32_t UART1_nCTS_nCS:1;
N    __IO uint32_t TM0:1;
X    volatile uint32_t TM0:1;
N    __IO uint32_t TM1_SS11:1;                              
X    volatile uint32_t TM1_SS11:1;                              
N    __IO uint32_t TM2_SS01:1;
X    volatile uint32_t TM2_SS01:1;
N    __IO uint32_t TM3_PWM4:1;                     
X    volatile uint32_t TM3_PWM4:1;                     
N    __IO uint32_t CPO0_CLKO_AD0:1;
X    volatile uint32_t CPO0_CLKO_AD0:1;
N    __IO uint32_t CPO1_AD1:1;
X    volatile uint32_t CPO1_AD1:1;
N    __IO uint32_t INT0_SS31:1;
X    volatile uint32_t INT0_SS31:1;
N    __IO uint32_t INT1:1;
X    volatile uint32_t INT1:1;
N    __IO uint32_t SCHMITT:16;    
X    volatile uint32_t SCHMITT:16;    
N} GCR_GPBMFP_T;
N
Ntypedef struct
N{
N    __IO uint32_t SPI0_SS0_I2SLRCLK:1;
X    volatile uint32_t SPI0_SS0_I2SLRCLK:1;
N    __IO uint32_t SPI0_CLK_I2SBCLK:1;
X    volatile uint32_t SPI0_CLK_I2SBCLK:1;
N    __IO uint32_t SPI0_MISO0_I2SDI:1;
X    volatile uint32_t SPI0_MISO0_I2SDI:1;
N    __IO uint32_t SPI0_MOSI0_I2SDO:1;
X    volatile uint32_t SPI0_MOSI0_I2SDO:1;
N    __IO uint32_t SPI0_MISO1:1;
X    volatile uint32_t SPI0_MISO1:1;
N    __IO uint32_t SPI0_MOSI1:1;
X    volatile uint32_t SPI0_MOSI1:1;
N    __IO uint32_t CPP0_AD4:1;
X    volatile uint32_t CPP0_AD4:1;
N    __IO uint32_t CPN0_AD5:1;
X    volatile uint32_t CPN0_AD5:1;
N    __IO uint32_t SPI1_SS0_MCLK:1;
X    volatile uint32_t SPI1_SS0_MCLK:1;
N    __IO uint32_t SPI1_CLK:1;
X    volatile uint32_t SPI1_CLK:1;
N    __IO uint32_t SPI1_MISO0:1;
X    volatile uint32_t SPI1_MISO0:1;
N    __IO uint32_t SPI1_MOSI0:1;
X    volatile uint32_t SPI1_MOSI0:1;
N    __IO uint32_t SPI1_MISO1:1;
X    volatile uint32_t SPI1_MISO1:1;
N    __IO uint32_t SPI1_MOSI1:1;
X    volatile uint32_t SPI1_MOSI1:1;
N    __IO uint32_t CPP1_AD2:1;
X    volatile uint32_t CPP1_AD2:1;
N    __IO uint32_t CPN1_AD3:1;
X    volatile uint32_t CPN1_AD3:1;
N    __IO uint32_t SCHMITT:16;    
X    volatile uint32_t SCHMITT:16;    
N} GCR_GPCMFP_T;
N
Ntypedef struct
N{
N    __IO uint32_t SPI2_SS0:1;
X    volatile uint32_t SPI2_SS0:1;
N    __IO uint32_t SPI2_CLK_SPI0_SS1:1;
X    volatile uint32_t SPI2_CLK_SPI0_SS1:1;
N    __IO uint32_t SPI2_MISO0_SPI0_MISO1:1;
X    volatile uint32_t SPI2_MISO0_SPI0_MISO1:1;
N    __IO uint32_t SPI2_MOSI0_SPI0_MOSI1:1;
X    volatile uint32_t SPI2_MOSI0_SPI0_MOSI1:1;
N    __IO uint32_t SPI2_MISO1:1;
X    volatile uint32_t SPI2_MISO1:1;
N    __IO uint32_t SPI2_MOSI1:1;
X    volatile uint32_t SPI2_MOSI1:1;
N    __IO uint32_t CAN0_RX:1;
X    volatile uint32_t CAN0_RX:1;
N    __IO uint32_t CAN0_TX:1;
X    volatile uint32_t CAN0_TX:1;
N    __IO uint32_t SPI3_SS0:1;
X    volatile uint32_t SPI3_SS0:1;
N    __IO uint32_t SPI3_CLK:1;
X    volatile uint32_t SPI3_CLK:1;
N    __IO uint32_t SPI3_MISO0:1;
X    volatile uint32_t SPI3_MISO0:1;
N    __IO uint32_t SPI3_MOSI0:1;
X    volatile uint32_t SPI3_MOSI0:1;
N    __IO uint32_t SPI3_MISO1:1;
X    volatile uint32_t SPI3_MISO1:1;
N    __IO uint32_t SPI3_MOSI1:1;
X    volatile uint32_t SPI3_MOSI1:1;
N    __IO uint32_t UART2_RX:1;
X    volatile uint32_t UART2_RX:1;
N    __IO uint32_t UART2_TX:1;
X    volatile uint32_t UART2_TX:1;
N    __IO uint32_t SCHMITT:16;    
X    volatile uint32_t SCHMITT:16;    
N} GCR_GPDMFP_T;
N
N
Ntypedef struct
N{
N    __IO uint32_t  PWM6:1;
X    volatile uint32_t  PWM6:1;
N    __IO uint32_t  PWM7:1;
X    volatile uint32_t  PWM7:1;
N    __I  uint32_t  RESERVE1:3;
X    volatile const  uint32_t  RESERVE1:3;
N    __IO uint32_t  PWM5:1;
X    volatile uint32_t  PWM5:1;
N    __I  uint32_t  RESERVE2:10;
X    volatile const  uint32_t  RESERVE2:10;
N    __IO uint32_t  SCHMITT:16;
X    volatile uint32_t  SCHMITT:16;
N} GCR_GPEMFP_T;
N
Ntypedef struct
N{
N    __IO uint32_t  PB10_S01:1;      /* GPB10 */
X    volatile uint32_t  PB10_S01:1;       
N    __IO uint32_t  PB9_S11:1;       /* GPB9  */
X    volatile uint32_t  PB9_S11:1;        
N    __IO uint32_t  PA7_S21:1;       /* GPA7  */
X    volatile uint32_t  PA7_S21:1;        
N    __IO uint32_t  PB14_S31:1;      /* GPB14 */
X    volatile uint32_t  PB14_S31:1;       
N    __IO uint32_t  PB11_PWM4:1;     /* GPB11 */
X    volatile uint32_t  PB11_PWM4:1;      
N    __IO uint32_t  PC0_I2SLRCLK:1;  /* GPC0  */
X    volatile uint32_t  PC0_I2SLRCLK:1;   
N    __IO uint32_t  PC1_I2SBCLK:1;   /* GPC1  */
X    volatile uint32_t  PC1_I2SBCLK:1;    
N    __IO uint32_t  PC2_I2SDI:1;     /* GPC2  */
X    volatile uint32_t  PC2_I2SDI:1;      
N    __IO uint32_t  PC3_I2SDO:1;     /* GPC3  */
X    volatile uint32_t  PC3_I2SDO:1;      
N    __IO uint32_t  PA15_I2SMCLK:1;  /* GPA15 */
X    volatile uint32_t  PA15_I2SMCLK:1;   
N    __IO uint32_t  PB12_CLKO:1;     /* GPB12 */
X    volatile uint32_t  PB12_CLKO:1;      
N    __IO uint32_t  EBI_EN:1;            
X    volatile uint32_t  EBI_EN:1;            
N    __IO uint32_t  EBI_MCLK_EN:1;   /* GPC8  */
X    volatile uint32_t  EBI_MCLK_EN:1;    
N    __IO uint32_t  EBI_WRL_EN:1;    /* GPB2  */
X    volatile uint32_t  EBI_WRL_EN:1;     
N    __IO uint32_t  EBI_WRH_EN:1;    /* GPB3  */
X    volatile uint32_t  EBI_WRH_EN:1;     
N    __I  uint32_t  RESERVE0:1;  
X    volatile const  uint32_t  RESERVE0:1;  
N    __IO uint32_t  EBI_HB_EN:8;     
X    volatile uint32_t  EBI_HB_EN:8;     
N    __IO uint32_t  PB15_T0EX:1;
X    volatile uint32_t  PB15_T0EX:1;
N    __IO uint32_t  PE5_T1EX:1;
X    volatile uint32_t  PE5_T1EX:1;
N    __IO uint32_t  PB2_T2EX:1;
X    volatile uint32_t  PB2_T2EX:1;
N    __IO uint32_t  PB3_T3EX:1;
X    volatile uint32_t  PB3_T3EX:1;
N    __I  uint32_t  RESERVE1:4;
X    volatile const  uint32_t  RESERVE1:4;
N} GCR_ALTMFP_T;
N
Ntypedef __IO uint32_t GCR_REGWRPROT_T;
Xtypedef volatile uint32_t GCR_REGWRPROT_T;
N
Ntypedef struct
N{
N    union 
N    {
N        __I uint32_t u32PDID;
X        volatile const uint32_t u32PDID;
N        __I uint32_t PDID;
X        volatile const uint32_t PDID;
N    };
N
N    union 
N    {
N        __IO uint32_t u32RSTSRC;
X        volatile uint32_t u32RSTSRC;
N        
N        struct 
N        {
N            __IO uint32_t  RSTS_POR:1;
X            volatile uint32_t  RSTS_POR:1;
N            __IO uint32_t  RSTS_RESET:1;
X            volatile uint32_t  RSTS_RESET:1;
N            __IO uint32_t  RSTS_WDT:1;
X            volatile uint32_t  RSTS_WDT:1;
N            __IO uint32_t  RSTS_LVR:1;
X            volatile uint32_t  RSTS_LVR:1;
N            __IO uint32_t  RSTS_BOD:1;
X            volatile uint32_t  RSTS_BOD:1;
N            __IO uint32_t  RSTS_SYS:1;
X            volatile uint32_t  RSTS_SYS:1;
N            __I  uint32_t  RESERVE0:1;
X            volatile const  uint32_t  RESERVE0:1;
N            __IO uint32_t  RSTS_CPU:1;    
X            volatile uint32_t  RSTS_CPU:1;    
N            __I  uint32_t  RESERVE1:24;
X            volatile const  uint32_t  RESERVE1:24;
N        } RSTSRC;
N    };
N
N    union 
N    {
N        __IO uint32_t u32IPRSTC1;
X        volatile uint32_t u32IPRSTC1;
N        
N        struct 
N        {
N            __IO uint32_t  CHIP_RST:1;
X            volatile uint32_t  CHIP_RST:1;
N            __IO uint32_t  CPU_RST:1;
X            volatile uint32_t  CPU_RST:1;
N            __IO uint32_t  PDMA_RST:1;
X            volatile uint32_t  PDMA_RST:1;
N            __IO uint32_t  EBI_RST:1;
X            volatile uint32_t  EBI_RST:1;
N            __I  uint32_t  RESERVE:28;
X            volatile const  uint32_t  RESERVE:28;
N        } IPRSTC1;
N    };    
N    
N    union 
N    {
N        __IO uint32_t u32IPRSTC2;
X        volatile uint32_t u32IPRSTC2;
N        
N        struct 
N        {
N            __I  uint32_t  RESERVE0:1;
X            volatile const  uint32_t  RESERVE0:1;
N            __IO uint32_t  GPIO_RST:1;
X            volatile uint32_t  GPIO_RST:1;
N            __IO uint32_t  TMR0_RST:1;
X            volatile uint32_t  TMR0_RST:1;
N            __IO uint32_t  TMR1_RST:1;
X            volatile uint32_t  TMR1_RST:1;
N            __IO uint32_t  TMR2_RST:1;
X            volatile uint32_t  TMR2_RST:1;
N            __IO uint32_t  TMR3_RST:1;
X            volatile uint32_t  TMR3_RST:1;
N            __I  uint32_t  RESERVE1:2;
X            volatile const  uint32_t  RESERVE1:2;
N            __IO uint32_t  I2C0_RST:1;
X            volatile uint32_t  I2C0_RST:1;
N            __IO uint32_t  I2C1_RST:1;
X            volatile uint32_t  I2C1_RST:1;
N            __I  uint32_t  RESERVE2:2;
X            volatile const  uint32_t  RESERVE2:2;
N            __IO uint32_t  SPI0_RST:1;
X            volatile uint32_t  SPI0_RST:1;
N            __IO uint32_t  SPI1_RST:1;
X            volatile uint32_t  SPI1_RST:1;
N            __IO uint32_t  SPI2_RST:1;
X            volatile uint32_t  SPI2_RST:1;
N            __IO uint32_t  SPI3_RST:1;
X            volatile uint32_t  SPI3_RST:1;
N            __IO uint32_t  UART0_RST:1;
X            volatile uint32_t  UART0_RST:1;
N            __IO uint32_t  UART1_RST:1;
X            volatile uint32_t  UART1_RST:1;
N            __IO uint32_t  UART2_RST:1;
X            volatile uint32_t  UART2_RST:1;
N            __I  uint32_t  RESERVE3:1;
X            volatile const  uint32_t  RESERVE3:1;
N            __IO uint32_t  PWM03_RST:1;
X            volatile uint32_t  PWM03_RST:1;
N            __IO uint32_t  PWM47_RST:1;
X            volatile uint32_t  PWM47_RST:1;
N            __IO uint32_t  ACMP_RST:1;
X            volatile uint32_t  ACMP_RST:1;
N            __IO uint32_t  PS2_RST:1;
X            volatile uint32_t  PS2_RST:1;
N            __IO uint32_t  CAN0_RST:1;
X            volatile uint32_t  CAN0_RST:1;
N            __I  uint32_t  RESERVE4:2;
X            volatile const  uint32_t  RESERVE4:2;
N            __IO uint32_t  USBD_RST:1;
X            volatile uint32_t  USBD_RST:1;
N            __IO uint32_t  ADC_RST:1;
X            volatile uint32_t  ADC_RST:1;
N            __IO uint32_t  I2S_RST:1;
X            volatile uint32_t  I2S_RST:1;
N            __I  uint32_t  RESERVE5:2;
X            volatile const  uint32_t  RESERVE5:2;
N        } IPRSTC2;
N    };    
N
N    union 
N    {
N        __IO uint32_t u32CPR;
X        volatile uint32_t u32CPR;
N        
N        struct 
N        {
N            __IO uint32_t  HPE:1;
X            volatile uint32_t  HPE:1;
N            __I  uint32_t  RESERVE:31;
X            volatile const  uint32_t  RESERVE:31;
N        } CPR;
N    };    
N
N    uint32_t RESERVE0;
N    
N    union 
N    {
N        __IO uint32_t u32BODCR;
X        volatile uint32_t u32BODCR;
N        
N        struct 
N        {
N            __IO uint32_t  BOD_EN:1;
X            volatile uint32_t  BOD_EN:1;
N            __IO uint32_t  BOD_VL:2;
X            volatile uint32_t  BOD_VL:2;
N            __IO uint32_t  BOD_RSTEN:1;
X            volatile uint32_t  BOD_RSTEN:1;
N            __IO uint32_t  BOD_INTF:1;
X            volatile uint32_t  BOD_INTF:1;
N            __IO uint32_t  BOD_LPM:1;
X            volatile uint32_t  BOD_LPM:1;
N            __IO uint32_t  BOD_OUT:1;
X            volatile uint32_t  BOD_OUT:1;
N            __IO uint32_t  LVR_EN:1;
X            volatile uint32_t  LVR_EN:1;
N            __I  uint32_t  RESERVE1:24;
X            volatile const  uint32_t  RESERVE1:24;
N        } BODCR;
N    };
N
N    union 
N    {
N        __IO uint32_t u32TEMPCR;
X        volatile uint32_t u32TEMPCR;
N        
N        struct 
N        {
N            __IO uint32_t  VTEMP_EN:1;
X            volatile uint32_t  VTEMP_EN:1;
N            __I  uint32_t  RESERVE:31;
X            volatile const  uint32_t  RESERVE:31;
N        } TEMPCR;
N    };   
N    
N    uint32_t RESERVE1;
N    
N    union 
N    {
N        __IO uint32_t u32PORCR;
X        volatile uint32_t u32PORCR;
N        __IO uint32_t PORCR;
X        volatile uint32_t PORCR;
N    };   
N
N    uint32_t RESERVE2[2];
N
N    union 
N    {
N        __IO uint32_t u32GPAMFP;
X        volatile uint32_t u32GPAMFP;
N        
N        struct 
N        {
N            __IO uint32_t ADC0:1;
X            volatile uint32_t ADC0:1;
N            __IO uint32_t ADC1_AD12:1;
X            volatile uint32_t ADC1_AD12:1;
N            __IO uint32_t ADC2_AD11:1;
X            volatile uint32_t ADC2_AD11:1;
N            __IO uint32_t ADC3_AD10:1;
X            volatile uint32_t ADC3_AD10:1;
N            __IO uint32_t ADC4_AD9:1;
X            volatile uint32_t ADC4_AD9:1;
N            __IO uint32_t ADC5_AD8:1;
X            volatile uint32_t ADC5_AD8:1;
N            __IO uint32_t ADC6_AD7:1;
X            volatile uint32_t ADC6_AD7:1;
N            __IO uint32_t ADC7_SS21_AD6:1;
X            volatile uint32_t ADC7_SS21_AD6:1;
N            __IO uint32_t I2C0_SDA:1;
X            volatile uint32_t I2C0_SDA:1;
N            __IO uint32_t I2C0_SCL:1;
X            volatile uint32_t I2C0_SCL:1;
N            __IO uint32_t I2C1_SDA_nWR:1;
X            volatile uint32_t I2C1_SDA_nWR:1;
N            __IO uint32_t I2C1_SCL_nRD:1;
X            volatile uint32_t I2C1_SCL_nRD:1;
N            __IO uint32_t PWM0_AD13:1;
X            volatile uint32_t PWM0_AD13:1;
N            __IO uint32_t PWM1_AD14:1;
X            volatile uint32_t PWM1_AD14:1;
N            __IO uint32_t PWM2_AD15:1;
X            volatile uint32_t PWM2_AD15:1;
N            __IO uint32_t PWM3_I2SMCLK:1;
X            volatile uint32_t PWM3_I2SMCLK:1;
N            __IO uint32_t SCHMITT:16;   
X            volatile uint32_t SCHMITT:16;   
N        } GPAMFP;
N    };   
N    
N    union 
N    {
N        __IO uint32_t u32GPBMFP;
X        volatile uint32_t u32GPBMFP;
N        
N        struct 
N        {
N            __IO uint32_t UART0_RX:1;
X            volatile uint32_t UART0_RX:1;
N            __IO uint32_t UART0_TX:1;
X            volatile uint32_t UART0_TX:1;
N            __IO uint32_t UART0_nRTS_nWRL:1;
X            volatile uint32_t UART0_nRTS_nWRL:1;
N            __IO uint32_t UART0_nCTS_nWRH:1;
X            volatile uint32_t UART0_nCTS_nWRH:1;
N            __IO uint32_t UART1_RX:1;
X            volatile uint32_t UART1_RX:1;
N            __IO uint32_t UART1_TX:1;
X            volatile uint32_t UART1_TX:1;
N            __IO uint32_t UART1_nRTS_ALE:1;
X            volatile uint32_t UART1_nRTS_ALE:1;
N            __IO uint32_t UART1_nCTS_nCS:1;
X            volatile uint32_t UART1_nCTS_nCS:1;
N            __IO uint32_t TM0:1;
X            volatile uint32_t TM0:1;
N            __IO uint32_t TM1_SS11:1;                              
X            volatile uint32_t TM1_SS11:1;                              
N            __IO uint32_t TM2_SS01:1;
X            volatile uint32_t TM2_SS01:1;
N            __IO uint32_t TM3_PWM4:1;                     
X            volatile uint32_t TM3_PWM4:1;                     
N            __IO uint32_t CPO0_CLKO_AD0:1;
X            volatile uint32_t CPO0_CLKO_AD0:1;
N            __IO uint32_t CPO1_AD1:1;
X            volatile uint32_t CPO1_AD1:1;
N            __IO uint32_t INT0_SS31:1;
X            volatile uint32_t INT0_SS31:1;
N            __IO uint32_t INT1:1;
X            volatile uint32_t INT1:1;
N            __IO uint32_t SCHMITT:16;    
X            volatile uint32_t SCHMITT:16;    
N        } GPBMFP;
N    };   
N    
N    union 
N    {
N        __IO uint32_t u32GPCMFP;
X        volatile uint32_t u32GPCMFP;
N        
N        struct 
N        {
N            __IO uint32_t SPI0_SS0_I2SLRCLK:1;
X            volatile uint32_t SPI0_SS0_I2SLRCLK:1;
N            __IO uint32_t SPI0_CLK_I2SBCLK:1;
X            volatile uint32_t SPI0_CLK_I2SBCLK:1;
N            __IO uint32_t SPI0_MISO0_I2SDI:1;
X            volatile uint32_t SPI0_MISO0_I2SDI:1;
N            __IO uint32_t SPI0_MOSI0_I2SDO:1;
X            volatile uint32_t SPI0_MOSI0_I2SDO:1;
N            __IO uint32_t SPI0_MISO1:1;
X            volatile uint32_t SPI0_MISO1:1;
N            __IO uint32_t SPI0_MOSI1:1;
X            volatile uint32_t SPI0_MOSI1:1;
N            __IO uint32_t CPP0_AD4:1;
X            volatile uint32_t CPP0_AD4:1;
N            __IO uint32_t CPN0_AD5:1;
X            volatile uint32_t CPN0_AD5:1;
N            __IO uint32_t SPI1_SS0_MCLK:1;
X            volatile uint32_t SPI1_SS0_MCLK:1;
N            __IO uint32_t SPI1_CLK:1;
X            volatile uint32_t SPI1_CLK:1;
N            __IO uint32_t SPI1_MISO0:1;
X            volatile uint32_t SPI1_MISO0:1;
N            __IO uint32_t SPI1_MOSI0:1;
X            volatile uint32_t SPI1_MOSI0:1;
N            __IO uint32_t SPI1_MISO1:1;
X            volatile uint32_t SPI1_MISO1:1;
N            __IO uint32_t SPI1_MOSI1:1;
X            volatile uint32_t SPI1_MOSI1:1;
N            __IO uint32_t CPP1_AD2:1;
X            volatile uint32_t CPP1_AD2:1;
N            __IO uint32_t CPN1_AD3:1;
X            volatile uint32_t CPN1_AD3:1;
N            __IO uint32_t SCHMITT:16; 
X            volatile uint32_t SCHMITT:16; 
N        } GPCMFP;
N    };   
N    
N    union 
N    {
N        __IO uint32_t u32GPDMFP;
X        volatile uint32_t u32GPDMFP;
N        
N        struct 
N        {
N            __IO uint32_t SPI2_SS0:1;
X            volatile uint32_t SPI2_SS0:1;
N            __IO uint32_t SPI2_CLK_SPI0_SS1:1;
X            volatile uint32_t SPI2_CLK_SPI0_SS1:1;
N            __IO uint32_t SPI2_MISO0_SPI0_MISO1:1;
X            volatile uint32_t SPI2_MISO0_SPI0_MISO1:1;
N            __IO uint32_t SPI2_MOSI0_SPI0_MOSI1:1;
X            volatile uint32_t SPI2_MOSI0_SPI0_MOSI1:1;
N            __IO uint32_t SPI2_MISO1:1;
X            volatile uint32_t SPI2_MISO1:1;
N            __IO uint32_t SPI2_MOSI1:1;
X            volatile uint32_t SPI2_MOSI1:1;
N            __IO uint32_t CAN0_RX:1;
X            volatile uint32_t CAN0_RX:1;
N            __IO uint32_t CAN0_TX:1;
X            volatile uint32_t CAN0_TX:1;
N            __IO uint32_t SPI3_SS0:1;
X            volatile uint32_t SPI3_SS0:1;
N            __IO uint32_t SPI3_CLK:1;
X            volatile uint32_t SPI3_CLK:1;
N            __IO uint32_t SPI3_MISO0:1;
X            volatile uint32_t SPI3_MISO0:1;
N            __IO uint32_t SPI3_MOSI0:1;
X            volatile uint32_t SPI3_MOSI0:1;
N            __IO uint32_t SPI3_MISO1:1;
X            volatile uint32_t SPI3_MISO1:1;
N            __IO uint32_t SPI3_MOSI1:1;
X            volatile uint32_t SPI3_MOSI1:1;
N            __IO uint32_t UART2_RX:1;
X            volatile uint32_t UART2_RX:1;
N            __IO uint32_t UART2_TX:1;
X            volatile uint32_t UART2_TX:1;
N            __IO uint32_t SCHMITT:16;
X            volatile uint32_t SCHMITT:16;
N        } GPDMFP;
N    };   
N    
N    union 
N    {
N        __IO uint32_t u32GPEMFP;
X        volatile uint32_t u32GPEMFP;
N        
N        struct 
N        {
N            __IO uint32_t  PWM6:1;
X            volatile uint32_t  PWM6:1;
N            __IO uint32_t  PWM7:1;
X            volatile uint32_t  PWM7:1;
N            __I  uint32_t  RESERVE1:3;
X            volatile const  uint32_t  RESERVE1:3;
N            __IO uint32_t  PWM5:1;
X            volatile uint32_t  PWM5:1;
N            __I  uint32_t  RESERVE2:10;
X            volatile const  uint32_t  RESERVE2:10;
N            __IO uint32_t  SCHMITT:16;
X            volatile uint32_t  SCHMITT:16;
N        } GPEMFP;
N    };                   
N    
N    uint32_t RESERVE3[3];
N     
N    union 
N    {
N        __IO uint32_t u32ALTMFP;
X        volatile uint32_t u32ALTMFP;
N        
N        struct 
N        {
N            __IO uint32_t  PB10_S01:1;      /* GPB10 */
X            volatile uint32_t  PB10_S01:1;       
N            __IO uint32_t  PB9_S11:1;       /* GPB9  */
X            volatile uint32_t  PB9_S11:1;        
N            __IO uint32_t  PA7_S21:1;       /* GPA7  */
X            volatile uint32_t  PA7_S21:1;        
N            __IO uint32_t  PB14_S31:1;      /* GPB14 */
X            volatile uint32_t  PB14_S31:1;       
N            __IO uint32_t  PB11_PWM4:1;     /* GPB11 */
X            volatile uint32_t  PB11_PWM4:1;      
N            __IO uint32_t  PC0_I2SLRCLK:1;  /* GPC0  */
X            volatile uint32_t  PC0_I2SLRCLK:1;   
N            __IO uint32_t  PC1_I2SBCLK:1;   /* GPC1  */
X            volatile uint32_t  PC1_I2SBCLK:1;    
N            __IO uint32_t  PC2_I2SDI:1;     /* GPC2  */
X            volatile uint32_t  PC2_I2SDI:1;      
N            __IO uint32_t  PC3_I2SDO:1;     /* GPC3  */
X            volatile uint32_t  PC3_I2SDO:1;      
N            __IO uint32_t  PA15_I2SMCLK:1;  /* GPA15 */
X            volatile uint32_t  PA15_I2SMCLK:1;   
N            __IO uint32_t  PB12_CLKO:1;     /* GPB12 */
X            volatile uint32_t  PB12_CLKO:1;      
N            __IO uint32_t  EBI_EN:1;            
X            volatile uint32_t  EBI_EN:1;            
N            __IO uint32_t  EBI_MCLK_EN:1;   /* GPC8  */
X            volatile uint32_t  EBI_MCLK_EN:1;    
N            __IO uint32_t  EBI_WRL_EN:1;    /* GPB2  */
X            volatile uint32_t  EBI_WRL_EN:1;     
N            __IO uint32_t  EBI_WRH_EN:1;    /* GPB3  */
X            volatile uint32_t  EBI_WRH_EN:1;     
N            __I  uint32_t  RESERVE0:1;  
X            volatile const  uint32_t  RESERVE0:1;  
N            __IO uint32_t  EBI_HB_EN:8;     
X            volatile uint32_t  EBI_HB_EN:8;     
N            __IO uint32_t  PB15_T0EX:1;
X            volatile uint32_t  PB15_T0EX:1;
N            __IO uint32_t  PE5_T1EX:1;
X            volatile uint32_t  PE5_T1EX:1;
N            __IO uint32_t  PB2_T2EX:1;
X            volatile uint32_t  PB2_T2EX:1;
N            __IO uint32_t  PB3_T3EX:1;
X            volatile uint32_t  PB3_T3EX:1;
N            __I  uint32_t  RESERVE1:4;  
X            volatile const  uint32_t  RESERVE1:4;  
N        } ALTMFP;
N    };   
N    
N    uint32_t RESERVE4[43];
N    
N    union 
N    {
N        __IO uint32_t u32REGWRPROT;
X        volatile uint32_t u32REGWRPROT;
N        __IO uint32_t REGWRPROT;
X        volatile uint32_t REGWRPROT;
N    };  
N} GCR_T;
N
N/* GCR RSTSRC Bit Field Definitions */
N#define GCR_RSTSRC_RSTS_CPU_Pos                 7
N#define GCR_RSTSRC_RSTS_CPU_Msk                 (1ul << GCR_RSTSRC_RSTS_CPU_Pos)
N
N#define GCR_RSTSRC_RSTS_SYS_Pos                 5
N#define GCR_RSTSRC_RSTS_SYS_Msk                 (1ul << GCR_RSTSRC_RSTS_SYS_Pos)
N
N#define GCR_RSTSRC_RSTS_BOD_Pos                 4
N#define GCR_RSTSRC_RSTS_BOD_Msk                 (1ul << GCR_RSTSRC_RSTS_BOD_Pos)
N
N#define GCR_RSTSRC_RSTS_LVR_Pos                 3
N#define GCR_RSTSRC_RSTS_LVR_Msk                 (1ul << GCR_RSTSRC_RSTS_LVR_Pos)
N
N#define GCR_RSTSRC_RSTS_WDT_Pos                 2
N#define GCR_RSTSRC_RSTS_WDT_Msk                 (1ul << GCR_RSTSRC_RSTS_WDT_Pos)
N
N#define GCR_RSTSRC_RSTS_RESET_Pos               1
N#define GCR_RSTSRC_RSTS_RESET_Msk               (1ul << GCR_RSTSRC_RSTS_RESET_Pos)
N
N#define GCR_RSTSRC_RSTS_POR_Pos                 0
N#define GCR_RSTSRC_RSTS_POR_Msk                 (1ul << GCR_RSTSRC_RSTS_POR_Pos)
N
N/* GCR IPRSTC1 Bit Field Definitions */
N#define GCR_IPRSTC1_EBI_RST_Pos                 3
N#define GCR_IPRSTC1_EBI_RST_Msk                 (1ul << GCR_IPRSTC1_EBI_RST_Pos)
N
N#define GCR_IPRSTC1_PDMA_RST_Pos                2
N#define GCR_IPRSTC1_PDMA_RST_Msk                (1ul << GCR_IPRSTC1_PDMA_RST_Pos)
N
N#define GCR_IPRSTC1_CPU_RST_Pos                 1
N#define GCR_IPRSTC1_CPU_RST_Msk                 (1ul << GCR_IPRSTC1_CPU_RST_Pos)
N
N#define GCR_IPRSTC1_CHIP_RST_Pos                0
N#define GCR_IPRSTC1_CHIP_RST_Msk                (1ul << GCR_IPRSTC1_CHIP_RST_Pos)
N
N/* GCR IPRSTC2 Bit Field Definitions */
N#define GCR_IPRSTC2_I2S_RST_Pos                 29
N#define GCR_IPRSTC2_I2S_RST_Msk                 (1ul << GCR_IPRSTC2_I2S_RST_Pos)
N
N#define GCR_IPRSTC2_ADC_RST_Pos                 28
N#define GCR_IPRSTC2_ADC_RST_Msk                 (1ul << GCR_IPRSTC2_ADC_RST_Pos)
N
N#define GCR_IPRSTC2_USBD_RST_Pos                27
N#define GCR_IPRSTC2_USBD_RST_Msk                (1ul << GCR_IPRSTC2_USBD_RST_Pos)
N
N#define GCR_IPRSTC2_CAN0_RST_Pos                24
N#define GCR_IPRSTC2_CAN0_RST_Msk                (1ul << GCR_IPRSTC2_CAN0_RST_Pos)
N
N#define GCR_IPRSTC2_PS2_RST_Pos                 23
N#define GCR_IPRSTC2_PS2_RST_Msk                 (1ul << GCR_IPRSTC2_PS2_RST_Pos)
N
N#define GCR_IPRSTC2_ACMP_RST_Pos                22
N#define GCR_IPRSTC2_ACMP_RST_Msk                (1ul << GCR_IPRSTC2_ACMP_RST_Pos)
N
N#define GCR_IPRSTC2_PWM47_RST_Pos               21
N#define GCR_IPRSTC2_PWM47_RST_Msk               (1ul << GCR_IPRSTC2_PWM47_RST_Pos)
N
N#define GCR_IPRSTC2_PWM03_RST_Pos               20
N#define GCR_IPRSTC2_PWM03_RST_Msk               (1ul << GCR_IPRSTC2_PWM03_RST_Pos)
N
N#define GCR_IPRSTC2_UART2_RST_Pos               18
N#define GCR_IPRSTC2_UART2_RST_Msk               (1ul << GCR_IPRSTC2_UART2_RST_Pos)
N
N#define GCR_IPRSTC2_UART1_RST_Pos               17
N#define GCR_IPRSTC2_UART1_RST_Msk               (1ul << GCR_IPRSTC2_UART1_RST_Pos)
N
N#define GCR_IPRSTC2_UART0_RST_Pos               16
N#define GCR_IPRSTC2_UART0_RST_Msk               (1ul << GCR_IPRSTC2_UART0_RST_Pos)
N
N#define GCR_IPRSTC2_SPI3_RST_Pos                15
N#define GCR_IPRSTC2_SPI3_RST_Msk                (1ul << GCR_IPRSTC2_SPI3_RST_Pos)
N
N#define GCR_IPRSTC2_SPI2_RST_Pos                14
N#define GCR_IPRSTC2_SPI2_RST_Msk                (1ul << GCR_IPRSTC2_SPI2_RST_Pos)
N
N#define GCR_IPRSTC2_SPI1_RST_Pos                13
N#define GCR_IPRSTC2_SPI1_RST_Msk                (1ul << GCR_IPRSTC2_SPI1_RST_Pos)
N
N#define GCR_IPRSTC2_SPI0_RST_Pos                12
N#define GCR_IPRSTC2_SPI0_RST_Msk                (1ul << GCR_IPRSTC2_SPI0_RST_Pos)
N
N#define GCR_IPRSTC2_I2C1_RST_Pos                9
N#define GCR_IPRSTC2_I2C1_RST_Msk                (1ul << GCR_IPRSTC2_I2C1_RST_Pos)
N
N#define GCR_IPRSTC2_I2C0_RST_Pos                8
N#define GCR_IPRSTC2_I2C0_RST_Msk                (1ul << GCR_IPRSTC2_I2C0_RST_Pos)
N
N#define GCR_IPRSTC2_TMR3_RST_Pos                5
N#define GCR_IPRSTC2_TMR3_RST_Msk                (1ul << GCR_IPRSTC2_TMR3_RST_Pos)
N
N#define GCR_IPRSTC2_TMR2_RST_Pos                4
N#define GCR_IPRSTC2_TMR2_RST_Msk                (1ul << GCR_IPRSTC2_TMR2_RST_Pos)
N
N#define GCR_IPRSTC2_TMR1_RST_Pos                3
N#define GCR_IPRSTC2_TMR1_RST_Msk                (1ul << GCR_IPRSTC2_TMR1_RST_Pos)
N
N#define GCR_IPRSTC2_TMR0_RST_Pos                2
N#define GCR_IPRSTC2_TMR0_RST_Msk                (1ul << GCR_IPRSTC2_TMR0_RST_Pos)
N
N#define GCR_IPRSTC2_GPIO_RST_Pos                1
N#define GCR_IPRSTC2_GPIO_RST_Msk                (1ul << GCR_IPRSTC2_GPIO_RST_Pos)
N
N/* GCR CPR Bit Field Definitions */
N#define GCR_CPR_HPE_Pos                         0
N#define GCR_CPR_HPE_Msk                         (1ul << GCR_CPR_HPE_Pos)
N
N/* GCR BODCR Bit Field Definitions */
N#define GCR_BODCR_LVR_EN_Pos                    7
N#define GCR_BODCR_LVR_EN_Msk                    (1ul << GCR_BODCR_LVR_EN_Pos)
N
N#define GCR_BODCR_BOD_OUT_Pos                   6
N#define GCR_BODCR_BOD_OUT_Msk                   (1ul << GCR_BODCR_BOD_OUT_Pos)
N
N#define GCR_BODCR_BOD_LPM_Pos                   5
N#define GCR_BODCR_BOD_LPM_Msk                   (1ul << GCR_BODCR_BOD_LPM_Pos)
N
N#define GCR_BODCR_BOD_INTF_Pos                  4
N#define GCR_BODCR_BOD_INTF_Msk                  (1ul << GCR_BODCR_BOD_INTF_Pos)
N
N#define GCR_BODCR_BOD_RSTEN_Pos                 3
N#define GCR_BODCR_BOD_RSTEN_Msk                 (1ul << GCR_BODCR_BOD_RSTEN_Pos)
N
N#define GCR_BODCR_BOD_VL_Pos                    1
N#define GCR_BODCR_BOD_VL_Msk                    (3ul << GCR_BODCR_BOD_VL_Pos)
N
N#define GCR_BODCR_BOD_EN_Pos                    0
N#define GCR_BODCR_BOD_EN_Msk                    (1ul << GCR_BODCR_BOD_EN_Pos)
N
N/* GCR TEMPCR Bit Field Definitions */
N#define GCR_TEMPCR_VTEMP_EN_Pos                 0
N#define GCR_TEMPCR_VTEMP_EN_Msk                 (1ul << GCR_TEMPCR_VTEMP_EN_Pos)
N
N/* GCR PORCR Bit Field Definitions */
N#define GCR_PORCR_POR_DIS_CODE_Pos              0
N#define GCR_PORCR_POR_DIS_CODE_Msk              (0xFFFFul << GCR_PORCR_POR_DIS_CODE_Pos)
N
N/* GCR GPAMFP Bit Field Definitions */
N#define GCR_GPAMFP_GPA_TYPE_Pos                 16
N#define GCR_GPAMFP_GPA_TYPE_Msk                 (0xFFFFul << GCR_GPAMFP_GPA_TYPE_Pos)
N
N#define GCR_GPAMFP_GPA_MFP_Pos                  0
N#define GCR_GPAMFP_GPA_MFP_Msk                  (0xFFFFul << GCR_GPAMFP_GPA_MFP_Pos)
N
N
N/* GCR GPBMFP Bit Field Definitions */
N#define GCR_GPBMFP_GPB_TYPE_Pos                 16
N#define GCR_GPBMFP_GPB_TYPE_Msk                 (0xFFFFul << GCR_GPBMFP_GPB_TYPE_Pos)
N
N#define GCR_GPBMFP_GPB_MFP_Pos                  0
N#define GCR_GPBMFP_GPB_MFP_Msk                  (0xFFFFul << GCR_GPBMFP_GPB_MFP_Pos)
N
N/* GCR GPCMFP Bit Field Definitions */
N#define GCR_GPCMFP_GPC_TYPE_Pos                 16
N#define GCR_GPCMFP_GPC_TYPE_Msk                 (0xFFFFul << GCR_GPCMFP_GPC_TYPE_Pos)
N
N#define GCR_GPCMFP_GPC_MFP_Pos                  0
N#define GCR_GPCMFP_GPC_MFP_Msk                  (0xFFFFul << GCR_GPCMFP_GPC_MFP_Pos)
N
N/* GCR GPDMFP Bit Field Definitions */
N#define GCR_GPDMFP_GPD_TYPE_Pos                 16
N#define GCR_GPDMFP_GPD_TYPE_Msk                 (0xFFFFul << GCR_GPDMFP_GPD_TYPE_Pos)
N
N#define GCR_GPDMFP_GPD_MFP_Pos                  0
N#define GCR_GPDMFP_GPD_MFP_Msk                  (0xFFFFul << GCR_GPDMFP_GPD_MFP_Pos)
N
N/* GCR GPEMFP Bit Field Definitions */
N#define GCR_GPEMFP_GPE_TYPE_Pos                 16
N#define GCR_GPEMFP_GPE_TYPE_Msk                 (0xFFFFul << GCR_GPEMFP_GPE_TYPE_Pos)
N
N#define GCR_GPEMFP_GPE_MFP5_Pos                 5
N#define GCR_GPEMFP_GPE_MFP5_Msk                 (1ul << GCR_GPEMFP_GPE_MFP5_Pos)
N
N#define GCR_GPEMFP_GPE_MFP1_Pos                 1
N#define GCR_GPEMFP_GPE_MFP1_Msk                 (1ul << GCR_GPEMFP_GPE_MFP1_Pos)
N
N#define GCR_GPEMFP_GPE_MFP0_Pos                 0
N#define GCR_GPEMFP_GPE_MFP0_Msk                 (1ul << GCR_GPEMFP_GPE_MFP0_Pos)
N
N/* GCR ALTMFP Bit Field Definitions */
N#define GCR_ALTMFP_PB3_T3EX_Pos                 27
N#define GCR_ALTMFP_PB3_T3EX_Msk                 (1ul << GCR_ALTMFP_PB3_T3EX_Pos)
N
N#define GCR_ALTMFP_PB2_T2EX_Pos                 26
N#define GCR_ALTMFP_PB2_T2EX_Msk                 (1ul << GCR_ALTMFP_PB2_T2EX_Pos)
N
N#define GCR_ALTMFP_PE5_T1EX_Pos                 25
N#define GCR_ALTMFP_PE5_T1EX_Msk                 (1ul << GCR_ALTMFP_PE5_T1EX_Pos)
N
N#define GCR_ALTMFP_PB15_T0EX_Pos                24
N#define GCR_ALTMFP_PB15_T0EX_Msk                (1ul << GCR_ALTMFP_PB15_T0EX_Pos)
N
N#define GCR_ALTMFP_EBI_HB_EN_Pos                16
N#define GCR_ALTMFP_EBI_HB_EN_Msk                (0xFFul << GCR_ALTMFP_EBI_HB_EN_Pos)
N
N#define GCR_ALTMFP_EBI_nWRH_EN_Pos              14
N#define GCR_ALTMFP_EBI_nWRH_EN_Msk              (1ul << GCR_ALTMFP_EBI_nWRH_EN_Pos)
N
N#define GCR_ALTMFP_EBI_nWRL_EN_Pos              13
N#define GCR_ALTMFP_EBI_nWRL_EN_Msk              (1ul << GCR_ALTMFPEBI_nWRL_EN_Pos)
N
N#define GCR_ALTMFP_EBI_MCLK_EN_Pos              12
N#define GCR_ALTMFP_EBI_MCLK_EN_Msk              (1ul << GCR_ALTMFP_EBI_MCLK_EN_Pos)
N
N#define GCR_ALTMFP_EBI_EN_Pos                   11
N#define GCR_ALTMFP_EBI_EN_Msk                   (1ul << GCR_ALTMFP_EBI_EN_Pos)
N
N#define GCR_ALTMFP_PB12_CLKO_Pos                10
N#define GCR_ALTMFP_PB12_CLKO_Msk                (1ul << GCR_ALTMFP_PB12_CLKO_Pos)
N
N#define GCR_ALTMFP_PA15_I2SMCLK_Pos             9
N#define GCR_ALTMFP_PA15_I2SMCLK_Msk             (1ul << GCR_ALTMFP_PA15_I2SMCLK_Pos)
N
N#define GCR_ALTMFP_PC3_I2SDO_Pos                8
N#define GCR_ALTMFP_PC3_I2SDO_Msk                (1ul << GCR_ALTMFP_PC3_I2SDO_Pos)
N
N#define GCR_ALTMFP_PC2_I2SDI_Pos                7
N#define GCR_ALTMFP_PC2_I2SDI_Msk                (1ul << GCR_ALTMFP_PC2_I2SDI_Pos)
N
N#define GCR_ALTMFP_PC1_I2SBCLK_Pos              6
N#define GCR_ALTMFP_PC1_I2SBCLK_Msk              (1ul << GCR_ALTMFP_PC1_I2SBCLK_Pos)
N
N#define GCR_ALTMFP_PC0_I2SLRCLK_Pos             5
N#define GCR_ALTMFP_PC0_I2SLRCLK_Msk             (1ul << GCR_ALTMFP_PC0_I2SLRCLK_Pos)
N
N#define GCR_ALTMFP_PB11_PWM4_Pos                4
N#define GCR_ALTMFP_PB11_PWM4_Msk                (1ul << GCR_ALTMFP_PB11_PWM4_Pos)
N
N#define GCR_ALTMFP_PB14_S31_Pos                 3
N#define GCR_ALTMFP_PB14_S31_Msk                 (1ul << GCR_ALTMFP_PB14_S31_Pos)
N
N#define GCR_ALTMFP_PA7_S21_Pos                  2
N#define GCR_ALTMFP_PA7_S21_Msk                  (1ul << GCR_ALTMFP_PA7_S21_Pos)
N
N#define GCR_ALTMFP_PB9_S11_Pos                  1
N#define GCR_ALTMFP_PB9_S11_Msk                  (1ul << GCR_ALTMFP_PB9_S11_Pos)
N
N#define GCR_ALTMFP_PB10_S01_Pos                 0
N#define GCR_ALTMFP_PB10_S01_Msk                 (1ul << GCR_ALTMFP_PB10_S01_Pos)
N
N/* GCR REGWRPROT Bit Field Definitions */
N#define GCR_REGWRPROT_REGWRPROT_Pos             0
N#define GCR_REGWRPROT_REGWRPROT_Msk             (0xFFul << GCR_REGWRPROT_REGWRPROT_Pos)
N
N
Ntypedef struct
N{
N    __IO uint32_t  INTSRC:4;
X    volatile uint32_t  INTSRC:4;
N    __I  uint32_t  RESERVE:28;
X    volatile const  uint32_t  RESERVE:28;
N} GCR_IRQSRC_T;
N
Ntypedef struct
N{
N    __IO uint32_t  NMISEL:5;
X    volatile uint32_t  NMISEL:5;
N    __I  uint32_t  RESERVE0:3;
X    volatile const  uint32_t  RESERVE0:3;
N    __IO uint32_t  NMI_EN:1;
X    volatile uint32_t  NMI_EN:1;
N    __I  uint32_t  RESERVE1:23;
X    volatile const  uint32_t  RESERVE1:23;
N} GCR_NMISEL_T;
N
N
Ntypedef __IO uint32_t GCR_MCUIRQ_T;
Xtypedef volatile uint32_t GCR_MCUIRQ_T;
N
Ntypedef struct
N{
N    union 
N    {
N        __I uint32_t u32IRQSRC[32];
X        volatile const uint32_t u32IRQSRC[32];
N        __I uint32_t IRQSRC[32];
X        volatile const uint32_t IRQSRC[32];
N    };
N
N    union 
N    {
N        __IO uint32_t u32NMISEL;
X        volatile uint32_t u32NMISEL;
N        
N        struct 
N        {
N            __IO uint32_t  NMISEL:5;
X            volatile uint32_t  NMISEL:5;
N            __I  uint32_t  RESERVE0:3;
X            volatile const  uint32_t  RESERVE0:3;
N            __IO uint32_t  NMI_EN:1;
X            volatile uint32_t  NMI_EN:1;
N            __I  uint32_t  RESERVE1:23;
X            volatile const  uint32_t  RESERVE1:23;
N        } NMISEL;
N    };
N
N    union 
N    {
N        __IO uint32_t u32MCUIRQ;
X        volatile uint32_t u32MCUIRQ;
N        __IO uint32_t MCUIRQ;
X        volatile uint32_t MCUIRQ;
N    };
N} GCR_INT_T;
N
N/* GCR IRQSRC Bit Field Definitions */
N#define GCR_IRQSRC_INT_SRC_Pos                  0
N#define GCR_IRQSRC_INT_SRC_Msk                  (0xFul << GCR_IRQSRC_INT_SRC_Pos)
N
N/* GCR NMISEL Bit Field Definitions */
N#define GCR_NMISEL_NMI_EN_Pos                   8
N#define GCR_NMISEL_NMI_EN_Msk                   (1ul << GCR_NMISEL_NMI_EN_Pos)
N
N#define GCR_NMISEL_NMISEL_Pos                   0
N#define GCR_NMISEL_NMISEL_Msk                   (0x1Ful << GCR_NMISEL_NMISEL_Pos)
N
N/*-------------------------- FLASH Memory Controller -------------------------*/
Ntypedef struct
N{
N    __IO uint32_t  ISPEN:1;
X    volatile uint32_t  ISPEN:1;
N    __IO uint32_t  BS:1;
X    volatile uint32_t  BS:1;
N    __I  uint32_t  RESERVE0:1;
X    volatile const  uint32_t  RESERVE0:1;
N    __IO uint32_t  APUEN:1;
X    volatile uint32_t  APUEN:1;
N    __IO uint32_t  CFGUEN:1;
X    volatile uint32_t  CFGUEN:1;
N    __IO uint32_t  LDUEN:1;
X    volatile uint32_t  LDUEN:1;
N    __IO uint32_t  ISPFF:1;
X    volatile uint32_t  ISPFF:1;
N    __I  uint32_t  RESERVE1:1;
X    volatile const  uint32_t  RESERVE1:1;
N    __IO uint32_t  PT:3;
X    volatile uint32_t  PT:3;
N    __I  uint32_t  RESERVE2:1;
X    volatile const  uint32_t  RESERVE2:1;
N    __IO uint32_t  ET:3;
X    volatile uint32_t  ET:3;
N    __I  uint32_t  RESERVE3:17;
X    volatile const  uint32_t  RESERVE3:17;
N
N} FMC_ISPCON_T;
N
Ntypedef __IO uint32_t FMC_ISPADR_T;
Xtypedef volatile uint32_t FMC_ISPADR_T;
Ntypedef __IO uint32_t FMC_ISPDAT_T;
Xtypedef volatile uint32_t FMC_ISPDAT_T;
N
Ntypedef struct
N{
N    __IO uint32_t  FCTRL:4;
X    volatile uint32_t  FCTRL:4;
N    __IO uint32_t  FCEN:1;
X    volatile uint32_t  FCEN:1;
N    __IO uint32_t  FOEN:1;
X    volatile uint32_t  FOEN:1;
N    __I  uint32_t  RESERVE:26;
X    volatile const  uint32_t  RESERVE:26;
N} FMC_ISPCMD_T;
N
Ntypedef struct
N{
N    __IO uint32_t  ISPGO:1;
X    volatile uint32_t  ISPGO:1;
N    __I  uint32_t  RESERVE:31;
X    volatile const  uint32_t  RESERVE:31;
N} FMC_ISPTRG_T;
N
Ntypedef __I uint32_t FMC_DFBADR_T;
Xtypedef volatile const uint32_t FMC_DFBADR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  FPSEN:1;
X    volatile uint32_t  FPSEN:1;
N    __IO uint32_t  FATS:3;
X    volatile uint32_t  FATS:3;
N    __IO uint32_t  LFOM:1;
X    volatile uint32_t  LFOM:1;
N    __I  uint32_t  RESERVE:27;
X    volatile const  uint32_t  RESERVE:27;
N} FMC_FATCON_T;
N
Ntypedef struct
N{
N    union 
N    {
N        __IO uint32_t u32ISPCON;
X        volatile uint32_t u32ISPCON;
N        
N        struct 
N        {
N            __IO uint32_t  ISPEN:1;
X            volatile uint32_t  ISPEN:1;
N            __IO uint32_t  BS:1;
X            volatile uint32_t  BS:1;
N            __I  uint32_t  RESERVE0:1;
X            volatile const  uint32_t  RESERVE0:1;
N            __IO uint32_t  APUEN:1;
X            volatile uint32_t  APUEN:1;
N            __IO uint32_t  CFGUEN:1;
X            volatile uint32_t  CFGUEN:1;
N            __IO uint32_t  LDUEN:1;
X            volatile uint32_t  LDUEN:1;
N            __IO uint32_t  ISPFF:1;
X            volatile uint32_t  ISPFF:1;
N            __I  uint32_t  RESERVE1:1;
X            volatile const  uint32_t  RESERVE1:1;
N            __IO uint32_t  PT:3;
X            volatile uint32_t  PT:3;
N            __I  uint32_t  RESERVE2:1;
X            volatile const  uint32_t  RESERVE2:1;
N            __IO uint32_t  ET:3;
X            volatile uint32_t  ET:3;
N            __I  uint32_t  RESERVE3:17;
X            volatile const  uint32_t  RESERVE3:17;
N        } ISPCON;
N    };
N
N    union 
N    {
N        __IO uint32_t u32ISPADR;
X        volatile uint32_t u32ISPADR;
N        __IO uint32_t ISPADR;
X        volatile uint32_t ISPADR;
N    };
N
N    union 
N    {
N        __IO uint32_t u32ISPDAT;
X        volatile uint32_t u32ISPDAT;
N        __IO uint32_t ISPDAT;
X        volatile uint32_t ISPDAT;
N    };
N    
N    union 
N    {
N        __IO uint32_t u32ISPCMD;
X        volatile uint32_t u32ISPCMD;
N        
N        struct 
N        {
N            __IO uint32_t  FCTRL:4;
X            volatile uint32_t  FCTRL:4;
N            __IO uint32_t  FCEN:1;
X            volatile uint32_t  FCEN:1;
N            __IO uint32_t  FOEN:1;
X            volatile uint32_t  FOEN:1;
N            __I  uint32_t  RESERVE:26;
X            volatile const  uint32_t  RESERVE:26;
N        } ISPCMD;
N    };
N
N    union 
N    {
N        __I uint32_t u32ISPTRG;
X        volatile const uint32_t u32ISPTRG;
N        
N        struct 
N        {
N            __IO uint32_t  ISPGO:1;
X            volatile uint32_t  ISPGO:1;
N            __I  uint32_t  RESERVE:31;
X            volatile const  uint32_t  RESERVE:31;
N        } ISPTRG;
N    };
N    
N    union 
N    {
N        __I uint32_t u32DFBADR;
X        volatile const uint32_t u32DFBADR;
N        __I uint32_t DFBADR;
X        volatile const uint32_t DFBADR;
N    };
N
N    union 
N    {
N        __IO uint32_t u32FATCON;
X        volatile uint32_t u32FATCON;
N        
N        struct 
N        {
N            __IO uint32_t  FPSEN:1;
X            volatile uint32_t  FPSEN:1;
N            __IO uint32_t  FATS:3;
X            volatile uint32_t  FATS:3;
N            __IO uint32_t  LFOM:1;
X            volatile uint32_t  LFOM:1;
N            __I  uint32_t  RESERVE:27;
X            volatile const  uint32_t  RESERVE:27;
N        } FATCON;
N    };
N} FMC_T;
N
N/* FMC ISPCON Bit Field Definitions */
N#define FMC_ISPCON_ET_Pos                       12
N#define FMC_ISPCON_ET_Msk                       (7ul << FMC_ISPCON_ET_Pos)
N
N#define FMC_ISPCON_PT_Pos                       8
N#define FMC_ISPCON_PT_Msk                       (7ul << FMC_ISPCON_PT_Pos)
N
N#define FMC_ISPCON_ISPFF_Pos                    6
N#define FMC_ISPCON_ISPFF_Msk                    (1ul << FMC_ISPCON_ISPFF_Pos)
N
N#define FMC_ISPCON_LDUEN_Pos                    5
N#define FMC_ISPCON_LDUEN_Msk                    (1ul << FMC_ISPCON_LDUEN_Pos)
N
N#define FMC_ISPCON_CFGUEN_Pos                   4
N#define FMC_ISPCON_CFGUEN_Msk                   (1ul << FMC_ISPCON_CFGUEN_Pos)
N
N#define FMC_ISPCON_APUEN_Pos                    3
N#define FMC_ISPCON_APUEN_Msk                    (1ul << FMC_ISPCON_APUEN_Pos)
N
N#define FMC_ISPCON_BS_Pos                       1
N#define FMC_ISPCON_BS_Msk                       (1ul << FMC_ISPCON_BS_Pos)
N
N#define FMC_ISPCON_ISPEN_Pos                    0
N#define FMC_ISPCON_ISPEN_Msk                    (1ul << FMC_ISPCON_ISPEN_Pos)
N
N/* FMC ISPADR Bit Field Definitions */
N#define FMC_ISPADR_ISPADR_Pos                   0
N#define FMC_ISPADR_ISPADR_Msk                   (0xFFFFFFFFul << FMC_ISPADR_ISPADR_Pos)
N
N/* FMC ISPADR Bit Field Definitions */
N#define FMC_ISPDAT_ISPDAT_Pos                   0
N#define FMC_ISPDAT_ISPDAT_Msk                   (0xFFFFFFFFul << FMC_ISPDAT_ISPDAT_Pos)
N
N/* FMC ISPCMD Bit Field Definitions */
N#define FMC_ISPCMD_FOEN_Pos                     5
N#define FMC_ISPCMD_FOEN_Msk                     (1ul << FMC_ISPCMD_FOEN_Pos)
N
N#define FMC_ISPCMD_FCEN_Pos                     4
N#define FMC_ISPCMD_FCEN_Msk                     (1ul << FMC_ISPCMD_FCEN_Pos)
N
N#define FMC_ISPCMD_FCTRL_Pos                    0
N#define FMC_ISPCMD_FCTRL_Msk                    (0xFul << FMC_ISPCMD_FCTRL_Pos)
N
N/* FMC ISPTRG Bit Field Definitions */
N#define FMC_ISPTRG_ISPGO_Pos                    0
N#define FMC_ISPTRG_ISPGO_Msk                    (1ul << FMC_ISPTRG_ISPGO_Pos)
N
N/* FMC DFBADR Bit Field Definitions */
N#define FMC_DFBADR_DFBA_Pos                     0
N#define FMC_DFBADR_DFBA_Msk                     (0xFFFFFFFFul << FMC_DFBADR_DFBA_Pos)
N
N/* FMC FATCON Bit Field Definitions */
N#define FMC_FATCON_LFOM_Pos                     4
N#define FMC_FATCON_LFOM_Msk                     (1ul << FMC_FATCON_LFOM_Pos)
N
N#define FMC_FATCON_FATS_Pos                     1
N#define FMC_FATCON_FATS_Msk                     (7ul << FMC_FATCON_FATS_Pos)
N
N#define FMC_FATCON_FPSEN_Pos                    0
N#define FMC_FATCON_FPSEN_Msk                    (1ul << FMC_FATCON_FPSEN_Pos)
N
N/*------------------------ PS2 Device Interface Controller -------------------*/
Ntypedef struct
N{
N    __IO uint32_t  PS2EN:1;
X    volatile uint32_t  PS2EN:1;
N    __IO uint32_t  TXINTEN:1;
X    volatile uint32_t  TXINTEN:1;
N    __IO uint32_t  RXINTEN:1;
X    volatile uint32_t  RXINTEN:1;
N    __IO uint32_t  TXFIFO_DEPTH:4;
X    volatile uint32_t  TXFIFO_DEPTH:4;
N    __IO uint32_t  ACK:1;
X    volatile uint32_t  ACK:1;
N    __IO uint32_t  CLRFIFO:1;
X    volatile uint32_t  CLRFIFO:1;
N    __IO uint32_t  OVERRIDE:1;
X    volatile uint32_t  OVERRIDE:1;
N    __IO uint32_t  FPS2CLK:1;
X    volatile uint32_t  FPS2CLK:1;
N    __IO uint32_t  FPS2DAT:1;
X    volatile uint32_t  FPS2DAT:1;
N    __I  uint32_t  RESERVE:20;
X    volatile const  uint32_t  RESERVE:20;
N} PS2_CON_T;
N
Ntypedef __IO uint32_t PS2_DATA_T;
Xtypedef volatile uint32_t PS2_DATA_T;
N
Ntypedef struct
N{
N    __IO uint32_t  PS2CLK:1;
X    volatile uint32_t  PS2CLK:1;
N    __IO uint32_t  PS2DATA:1;
X    volatile uint32_t  PS2DATA:1;
N    __IO uint32_t  FRAMERR:1;
X    volatile uint32_t  FRAMERR:1;
N    __IO uint32_t  RXPARTY:1;
X    volatile uint32_t  RXPARTY:1;
N    __IO uint32_t  RXBUSY:1;
X    volatile uint32_t  RXBUSY:1;
N    __IO uint32_t  TXBUSY:1;
X    volatile uint32_t  TXBUSY:1;
N    __IO uint32_t  RXOVF:1;
X    volatile uint32_t  RXOVF:1;
N    __IO uint32_t  TXEMPTY:1;
X    volatile uint32_t  TXEMPTY:1;
N    __IO uint32_t  BYTEIDX:4;
X    volatile uint32_t  BYTEIDX:4;
N    __I  uint32_t  RESERVE:20;
X    volatile const  uint32_t  RESERVE:20;
N} PS2_STATUS_T;
N
Ntypedef struct
N{
N    __IO uint32_t  RXINT:1;
X    volatile uint32_t  RXINT:1;
N    __IO uint32_t  TXINT:1;
X    volatile uint32_t  TXINT:1;
N    __I  uint32_t  RESERVE:30;
X    volatile const  uint32_t  RESERVE:30;
N} PS2_INTID_T;
N
Ntypedef struct
N{
N    union
N    {
N        __IO uint32_t u32PS2CON;
X        volatile uint32_t u32PS2CON;
N
N        struct
N        {
N            __IO uint32_t  PS2EN:1;
X            volatile uint32_t  PS2EN:1;
N            __IO uint32_t  TXINTEN:1;
X            volatile uint32_t  TXINTEN:1;
N            __IO uint32_t  RXINTEN:1;
X            volatile uint32_t  RXINTEN:1;
N            __IO uint32_t  TXFIFO_DEPTH:4;
X            volatile uint32_t  TXFIFO_DEPTH:4;
N            __IO uint32_t  ACK:1;
X            volatile uint32_t  ACK:1;
N            __IO uint32_t  CLRFIFO:1;
X            volatile uint32_t  CLRFIFO:1;
N            __IO uint32_t  OVERRIDE:1;
X            volatile uint32_t  OVERRIDE:1;
N            __IO uint32_t  FPS2CLK:1;
X            volatile uint32_t  FPS2CLK:1;
N            __IO uint32_t  FPS2DAT:1;
X            volatile uint32_t  FPS2DAT:1;
N            __I  uint32_t  RESERVE:20;      
X            volatile const  uint32_t  RESERVE:20;      
N        } PS2CON;
N    };
N
N    union
N    {
N        __IO uint32_t u32TXDATA[4];
X        volatile uint32_t u32TXDATA[4];
N        __IO uint32_t TXDATA[4];        
X        volatile uint32_t TXDATA[4];        
N    };
N
N    union
N    {
N        __I uint32_t u32RXDATA;
X        volatile const uint32_t u32RXDATA;
N        __I uint32_t RXDATA;
X        volatile const uint32_t RXDATA;
N    };
N
N    union
N    {
N        __IO uint32_t u32STATUS;
X        volatile uint32_t u32STATUS;
N
N        struct
N        {
N            __IO uint32_t  PS2CLK:1;
X            volatile uint32_t  PS2CLK:1;
N            __IO uint32_t  PS2DATA:1;
X            volatile uint32_t  PS2DATA:1;
N            __IO uint32_t  FRAMERR:1;
X            volatile uint32_t  FRAMERR:1;
N            __IO uint32_t  RXPARTY:1;
X            volatile uint32_t  RXPARTY:1;
N            __IO uint32_t  RXBUSY:1;
X            volatile uint32_t  RXBUSY:1;
N            __IO uint32_t  TXBUSY:1;
X            volatile uint32_t  TXBUSY:1;
N            __IO uint32_t  RXOVF:1;
X            volatile uint32_t  RXOVF:1;
N            __IO uint32_t  TXEMPTY:1;
X            volatile uint32_t  TXEMPTY:1;
N            __IO uint32_t  BYTEIDX:4;
X            volatile uint32_t  BYTEIDX:4;
N            __I  uint32_t  RESERVE:20;            
X            volatile const  uint32_t  RESERVE:20;            
N        } STATUS;
N    };
N
N    union
N    {
N        __IO uint32_t u32INTID;
X        volatile uint32_t u32INTID;
N
N        struct
N        {
N            __IO uint32_t  RXINT:1;
X            volatile uint32_t  RXINT:1;
N            __IO uint32_t  TXINT:1;
X            volatile uint32_t  TXINT:1;
N            __I  uint32_t  RESERVE:30;
X            volatile const  uint32_t  RESERVE:30;
N        } INTID;          
N    };
N} PS2_T;
N
N/* PS/2 PS2CON Bit Field Definitions */
N#define PS2_PS2CON_PS2EN_Pos                       0
N#define PS2_PS2CON_PS2EN_Msk                       (1ul << PS2_PS2CON_PS2EN_Pos)  
N
N#define PS2_PS2CON_TXINTEN_Pos                     1
N#define PS2_PS2CON_TXINTEN_Msk                     (1ul << PS2_PS2CON_TXINTEN_Pos) 
N
N#define PS2_PS2CON_RXINTEN_Pos                     2
N#define PS2_PS2CON_RXINTEN_Msk                     (1ul << PS2_PS2CON_RXINTEN_Pos)  
N
N#define PS2_PS2CON_TXFIFO_DEPTH_Pos                3
N#define PS2_PS2CON_TXFIFO_DEPTH_Msk                (0xFul << PS2_PS2CON_TXFIFO_DEPTH_Pos)
N
N#define PS2_PS2CON_ACK_Pos                         7
N#define PS2_PS2CON_ACK_Msk                         (1ul << PS2_PS2CON_ACK_Pos) 
N
N#define PS2_PS2CON_CLRFIFO_Pos                     8
N#define PS2_PS2CON_CLRFIFO_Msk                     (1ul << PS2_PS2CON_CLRFIFO_Pos)  
N
N#define PS2_PS2CON_OVERRIDE_Pos                    9
N#define PS2_PS2CON_OVERRIDE_Msk                    (1ul << PS2_PS2CON_OVERRIDE_Pos)  
N
N#define PS2_PS2CON_FPS2CLK_Pos                     10
N#define PS2_PS2CON_FPS2CLK_Msk                     (1ul << PS2_PS2CON_FPS2CLK_Pos) 
N
N#define PS2_PS2CON_FPS2DAT_Pos                     11
N#define PS2_PS2CON_FPS2DAT_Msk                     (1ul << PS2_PS2CON_FPS2DAT_Pos) 
N
N/* PS/2 PS2RXDATA Bit Field Definitions */
N#define PS2_PS2RXDATA_RXDATA_Pos                   0
N#define PS2_PS2RXDATA_RXDATA_Msk                   (0xFFul << PS2_PS2RXDATA_RXDATA_Pos)
N
N/* PS/2 PS2STATUS Bit Field Definitions */
N#define PS2_PS2STATUS_PS2CLK_Pos                   0
N#define PS2_PS2STATUS_PS2CLK_Msk                   (1ul << PS2_PS2STATUS_PS2CLK_Pos) 
N
N#define PS2_PS2STATUS_PS2DATA_Pos                  1
N#define PS2_PS2STATUS_PS2DATA_Msk                  (1ul << PS2_PS2STATUS_PS2DATA_Pos) 
N
N#define PS2_PS2STATUS_FRAMERR_Pos                  2
N#define PS2_PS2STATUS_FRAMERR_Msk                  (1ul << PS2_PS2STATUS_FRAMERR_Pos) 
N
N#define PS2_PS2STATUS_RXPARITY_Pos                 3
N#define PS2_PS2STATUS_RXPARITY_Msk                 (1ul << PS2_PS2STATUS_RXPARITY_Pos) 
N
N#define PS2_PS2STATUS_RXPARITY_Pos                 3
N#define PS2_PS2STATUS_RXPARITY_Msk                 (1ul << PS2_PS2STATUS_RXPARITY_Pos)
N
N#define PS2_PS2STATUS_RXBUSY_Pos                   4
N#define PS2_PS2STATUS_RXBUSY_Msk                   (1ul << PS2_PS2STATUS_RXBUSY_Pos)
N
N#define PS2_PS2STATUS_TXBUSY_Pos                   5
N#define PS2_PS2STATUS_TXBUSY_Msk                   (1ul << PS2_PS2STATUS_TXBUSY_Pos)
N
N#define PS2_PS2STATUS_RXOVF_Pos                    6
N#define PS2_PS2STATUS_RXOVF_Msk                    (1ul << PS2_PS2STATUS_RXOVF_Pos)
N
N#define PS2_PS2STATUS_TXEMPTY_Pos                  7
N#define PS2_PS2STATUS_TXEMPTY_Msk                  (1ul << PS2_PS2STATUS_TXEMPTY_Pos)
N
N#define PS2_PS2STATUS_BYTEIDX_Pos                  8
N#define PS2_PS2STATUS_BYTEIDX_Msk                  (0xFul << PS2_PS2STATUS_BYTEIDX_Pos)
N
N/* PS/2 PS2INTID Bit Field Definitions */
N#define PS2_PS2INTID_RXINT_Pos                     0
N#define PS2_PS2INTID_RXINT_Msk                     (1ul << PS2_PS2INTID_RXINT_Pos) 
N                     
N#define PS2_PS2INTID_TXINT_Pos                     1
N#define PS2_PS2INTID_TXINT_Msk                     (1ul << PS2_PS2INTID_TXINT_Pos) 
N
N/*---------------------------- CAN Bus Controller ----------------------------*/
N
N/*--------------- Controller Area Network Interface Register -----------------*/
N
N/* CAN_MsgObj_T :Message interface structure */
Ntypedef struct
N{
N    union 
N    {
N        __IO uint32_t u32CREQ;
X        volatile uint32_t u32CREQ;
N
N        struct {
N            __IO uint32_t  MSG_NUM:6;
X            volatile uint32_t  MSG_NUM:6;
N            __I  uint32_t  RESERVE0:9;
X            volatile const  uint32_t  RESERVE0:9;
N            __IO uint32_t  BUSY:1;	  
X            volatile uint32_t  BUSY:1;	  
N            __I  uint32_t  RESERVE1:16;
X            volatile const  uint32_t  RESERVE1:16;
N        } CREQ;
N    };
N 
N 
N    union {
N        __IO uint32_t  	u32CMASK;
X        volatile uint32_t  	u32CMASK;
N        		
N        struct {
N            __IO uint32_t  DAT_B:1;
X            volatile uint32_t  DAT_B:1;
N            __IO uint32_t  DAT_A:1;
X            volatile uint32_t  DAT_A:1;
N            __IO uint32_t  TXRQST_NEWDAT:1;
X            volatile uint32_t  TXRQST_NEWDAT:1;
N            __IO uint32_t  CLRINTPND:1;
X            volatile uint32_t  CLRINTPND:1;
N            __IO uint32_t  CONTROL:1;
X            volatile uint32_t  CONTROL:1;
N            __IO uint32_t  ARB:1;
X            volatile uint32_t  ARB:1;
N            __IO uint32_t  MASK:1;
X            volatile uint32_t  MASK:1;
N            __IO uint32_t  WRRD:1;
X            volatile uint32_t  WRRD:1;
N            __I  uint32_t  RESERVE0:24;
X            volatile const  uint32_t  RESERVE0:24;
N        } CMASK;
N    };
N 
N    
N    union {
N        __IO uint32_t  	u32MASK1;
X        volatile uint32_t  	u32MASK1;
N        		
N        struct {
N            __IO uint32_t  MASK15_0:16;
X            volatile uint32_t  MASK15_0:16;
N            __I  uint32_t  RESERVE0:16;
X            volatile const  uint32_t  RESERVE0:16;
N        } MASK1;
N    };
N
N
N    union {
N        __IO uint32_t  	u32MASK2;
X        volatile uint32_t  	u32MASK2;
N        		
N        struct {
N            __IO uint32_t  MASK28_16:13;
X            volatile uint32_t  MASK28_16:13;
N            __I  uint32_t  RESERVE0:1;
X            volatile const  uint32_t  RESERVE0:1;
N            __IO uint32_t  MDIR:1;
X            volatile uint32_t  MDIR:1;
N            __IO uint32_t  MXTD:1;
X            volatile uint32_t  MXTD:1;
N            __I  uint32_t  RESERVE1:16;
X            volatile const  uint32_t  RESERVE1:16;
N        } MASK2;
N    };
N    
N    union {
N        __IO uint32_t  	u32ARB1;
X        volatile uint32_t  	u32ARB1;
N
N        struct {
N            __IO uint32_t  ID15_0:16;
X            volatile uint32_t  ID15_0:16;
N            __I  uint32_t  RESERVE0:16;
X            volatile const  uint32_t  RESERVE0:16;
N        } ARB1;
N    };    
N 
N
N    union {
N        __IO uint32_t  	u32ARB2;	
X        volatile uint32_t  	u32ARB2;	
N
N        struct {
N            __IO uint32_t  ID28_16:13;
X            volatile uint32_t  ID28_16:13;
N            __IO uint32_t  DIR:1;
X            volatile uint32_t  DIR:1;
N            __IO uint32_t  XTD:1;
X            volatile uint32_t  XTD:1;
N            __IO uint32_t  MSGVAL:1;
X            volatile uint32_t  MSGVAL:1;
N            __I  uint32_t  RESERVE0:16;
X            volatile const  uint32_t  RESERVE0:16;
N        } ARB2;
N    };    
N
N    
N    union {
N        __IO uint32_t  	u32MCON;			
X        volatile uint32_t  	u32MCON;			
N
N        struct {
N            __IO uint32_t  DLC:4;
X            volatile uint32_t  DLC:4;
N            __I  uint32_t  RESERVE0:3;
X            volatile const  uint32_t  RESERVE0:3;
N            __IO uint32_t  EOB:1;
X            volatile uint32_t  EOB:1;
N            __IO uint32_t  TXRQST:1;
X            volatile uint32_t  TXRQST:1;
N            __IO uint32_t  RMTEN:1;
X            volatile uint32_t  RMTEN:1;
N            __IO uint32_t  RXIE:1;
X            volatile uint32_t  RXIE:1;
N            __IO uint32_t  TXIE:1;
X            volatile uint32_t  TXIE:1;
N            __IO uint32_t  UMASK:1;
X            volatile uint32_t  UMASK:1;
N            __IO uint32_t  INTPND:1;
X            volatile uint32_t  INTPND:1;
N            __IO uint32_t  MSGLST:1;
X            volatile uint32_t  MSGLST:1;
N            __IO uint32_t  NEWDAT:1;
X            volatile uint32_t  NEWDAT:1;
N            __I  uint32_t  RESERVE1:16;
X            volatile const  uint32_t  RESERVE1:16;
N         } MCON;
N    };    
N
N    union {
N        __IO uint32_t	u32DAT_A1;			
X        volatile uint32_t	u32DAT_A1;			
N
N        struct {
N            __IO uint32_t  DATA0:8;
X            volatile uint32_t  DATA0:8;
N            __IO uint32_t  DATA1:8;
X            volatile uint32_t  DATA1:8;
N            __I  uint32_t  RESERVE0:16;
X            volatile const  uint32_t  RESERVE0:16;
N        } DAT_A1;
N    };     
N    
N    union {
N        __IO uint32_t 	u32DAT_A2;		
X        volatile uint32_t 	u32DAT_A2;		
N
N        struct {
N            __IO uint32_t  DATA2:8;
X            volatile uint32_t  DATA2:8;
N            __IO uint32_t  DATA3:8;
X            volatile uint32_t  DATA3:8;
N            __I  uint32_t  RESERVE0:16;
X            volatile const  uint32_t  RESERVE0:16;
N        } DAT_A2;
N    };     
N    
N    union {
N        __IO uint32_t 	u32DAT_B1;
X        volatile uint32_t 	u32DAT_B1;
N
N        struct {
N            __IO uint32_t  DATA4:8;
X            volatile uint32_t  DATA4:8;
N            __IO uint32_t  DATA5:8;
X            volatile uint32_t  DATA5:8;
N            __I  uint32_t  RESERVE0:16;
X            volatile const  uint32_t  RESERVE0:16;
N        } DAT_B1;
N    };     
N
N    union {
N        __IO uint32_t	u32DAT_B2;		
X        volatile uint32_t	u32DAT_B2;		
N
N        struct {
N            __IO uint32_t  DATA6:8;
X            volatile uint32_t  DATA6:8;
N            __IO uint32_t  DATA7:8;
X            volatile uint32_t  DATA7:8;
N            __I  uint32_t  RESERVE0:16;
X            volatile const  uint32_t  RESERVE0:16;
N        } DAT_B2;
N    };     
N
N
N  __I uint32_t RESERVE0[13];        
X  volatile const uint32_t RESERVE0[13];        
N                                    
N} CAN_MsgObj_T;
N
N
Ntypedef struct
N{
N    union {
N        __IO uint32_t   u32CON;		 	
X        volatile uint32_t   u32CON;		 	
N        
N        struct {
N            __IO uint32_t  INIT:1;
X            volatile uint32_t  INIT:1;
N            __IO uint32_t  IE:1;
X            volatile uint32_t  IE:1;
N            __IO uint32_t  SIE:1;
X            volatile uint32_t  SIE:1;
N            __IO uint32_t  EIE:1;
X            volatile uint32_t  EIE:1;
N            __I  uint32_t  RESERVE0:1;
X            volatile const  uint32_t  RESERVE0:1;
N            __IO uint32_t  DAR:1;	  
X            volatile uint32_t  DAR:1;	  
N            __IO uint32_t  CCE:1;
X            volatile uint32_t  CCE:1;
N            __IO uint32_t  TEST:1;
X            volatile uint32_t  TEST:1;
N            __I  uint32_t  RESERVE1:24;
X            volatile const  uint32_t  RESERVE1:24;
N        } CON;
N    };
N
N    union {
N        __IO uint32_t   u32STATUS;	
X        volatile uint32_t   u32STATUS;	
N
N        struct {
N            __IO uint32_t  LEC:3;
X            volatile uint32_t  LEC:3;
N            __IO uint32_t  TXOK:1;
X            volatile uint32_t  TXOK:1;
N            __IO uint32_t  RXOK:1;
X            volatile uint32_t  RXOK:1;
N            __IO uint32_t  EPASS:1;
X            volatile uint32_t  EPASS:1;
N            __IO uint32_t  EWARN:1;	  
X            volatile uint32_t  EWARN:1;	  
N            __IO uint32_t  BOFF:1;
X            volatile uint32_t  BOFF:1;
N            __I  uint32_t  RESERVE0:24;
X            volatile const  uint32_t  RESERVE0:24;
N        } STATUS;
N    };
N
N    union {
N        __IO uint32_t   u32ERR;     		
X        volatile uint32_t   u32ERR;     		
N        
N        struct {
N            __IO uint32_t  TEC:8;
X            volatile uint32_t  TEC:8;
N            __IO uint32_t  REC:7;
X            volatile uint32_t  REC:7;
N            __IO uint32_t  RP:1;
X            volatile uint32_t  RP:1;
N            __I  uint32_t  RESERVE0:16;
X            volatile const  uint32_t  RESERVE0:16;
N        } ERR;
N    };  	
N
N    union {
N	    __IO uint32_t   u32BTIME;
X	    volatile uint32_t   u32BTIME;
N        
N        struct {
N            __IO uint32_t  BRP:6;
X            volatile uint32_t  BRP:6;
N            __IO uint32_t  SJW:2;
X            volatile uint32_t  SJW:2;
N            __IO uint32_t  TSEG1:4;
X            volatile uint32_t  TSEG1:4;
N            __IO uint32_t  TSEG2:3;
X            volatile uint32_t  TSEG2:3;
N            __I  uint32_t  RESERVE0:17;
X            volatile const  uint32_t  RESERVE0:17;
N        } BTIME;
N    };
N	
N    union {
N        __IO uint32_t   u32IIDR;
X        volatile uint32_t   u32IIDR;
N        
N        struct {
N            __IO uint32_t  INTID:16;
X            volatile uint32_t  INTID:16;
N            __I  uint32_t  RESERVE0:16;
X            volatile const  uint32_t  RESERVE0:16;
N        } IIDR;
N    };
N
N   union {
N        __IO uint32_t   u32TEST;
X        volatile uint32_t   u32TEST;
N                 
N        struct {
N            __I  uint32_t  RESERVE0:2;
X            volatile const  uint32_t  RESERVE0:2;
N            __IO uint32_t  BASIC:1;
X            volatile uint32_t  BASIC:1;
N            __IO uint32_t  SILENT:1;
X            volatile uint32_t  SILENT:1;
N            __IO uint32_t  LBACK:1;
X            volatile uint32_t  LBACK:1;
N            __IO uint32_t  TX:2;
X            volatile uint32_t  TX:2;
N            __IO uint32_t  RX:1;	  
X            volatile uint32_t  RX:1;	  
N            __I  uint32_t  RESERVE1:24;
X            volatile const  uint32_t  RESERVE1:24;
N        } TEST;
N   };
N    
N   union {
N        __IO uint32_t   u32BRPE;
X        volatile uint32_t   u32BRPE;
N        
N        struct {
N            __IO uint32_t  BPRE:4;
X            volatile uint32_t  BPRE:4;
N            __I  uint32_t  RESERVE0:28;
X            volatile const  uint32_t  RESERVE0:28;
N        } BRPE;
N   };
N    __I uint32_t   	RESERVE0[1];     
X    volatile const uint32_t   	RESERVE0[1];     
N	
N    CAN_MsgObj_T    sMsgObj[2];             
N                              
N	__I uint32_t   	RESERVE1[8];
X	volatile const uint32_t   	RESERVE1[8];
N
N   union {
N        __IO uint32_t   u32TXREQ1;
X        volatile uint32_t   u32TXREQ1;
N        
N        struct {
N            __IO uint32_t  TXRQST16_1:16;
X            volatile uint32_t  TXRQST16_1:16;
N            __I  uint32_t  RESERVE0:16;
X            volatile const  uint32_t  RESERVE0:16;
N        } TXREQ1;
N   };
N
N
N   union {
N        __IO uint32_t   u32TXREQ2;
X        volatile uint32_t   u32TXREQ2;
N        
N        struct {
N            __IO uint32_t  TXRQST32_17:16;
X            volatile uint32_t  TXRQST32_17:16;
N            __I  uint32_t  RESERVE0:16;
X            volatile const  uint32_t  RESERVE0:16;
N        } TXREQ2;
N   };
N
N    __I uint32_t   	RESERVE2[6];        
X    volatile const uint32_t   	RESERVE2[6];        
N
N   union {
N        __IO uint32_t   u32NDAT1;
X        volatile uint32_t   u32NDAT1;
N
N        struct {
N            __IO uint32_t  NEWDAT16_1:16;
X            volatile uint32_t  NEWDAT16_1:16;
N            __I  uint32_t  RESERVE0:16;
X            volatile const  uint32_t  RESERVE0:16;
N        } NDAT1;
N   };
N
N   union {
N        __IO uint32_t   u32NDAT2;
X        volatile uint32_t   u32NDAT2;
N
N        struct {
N            __IO uint32_t  NEWDAT32_17:16;
X            volatile uint32_t  NEWDAT32_17:16;
N            __I  uint32_t  RESERVE0:16;
X            volatile const  uint32_t  RESERVE0:16;
N        } NDAT2;
N   };
N
N    __I uint32_t   	RESERVE3[6];
X    volatile const uint32_t   	RESERVE3[6];
N
N   union {
N        __IO uint32_t   u32IPND1;
X        volatile uint32_t   u32IPND1;
N
N        struct {
N            __IO uint32_t  IPND16_1:16;
X            volatile uint32_t  IPND16_1:16;
N            __I  uint32_t  RESERVE0:16;
X            volatile const  uint32_t  RESERVE0:16;
N        } IPND1;
N   };
N
N   union {
N        __IO uint32_t   u32IPND2;
X        volatile uint32_t   u32IPND2;
N
N        struct {
N            __IO uint32_t  IPND32_17:16;
X            volatile uint32_t  IPND32_17:16;
N            __I  uint32_t  RESERVE0:16;
X            volatile const  uint32_t  RESERVE0:16;
N        } IPND2;
N   };
N
N    __I uint32_t   	RESERVE4[6];
X    volatile const uint32_t   	RESERVE4[6];
N
N   union {
N        __IO uint32_t   u32MVLD1;
X        volatile uint32_t   u32MVLD1;
N
N        struct {
N            __IO uint32_t  MSGVAL16_1:16;
X            volatile uint32_t  MSGVAL16_1:16;
N            __I  uint32_t  RESERVE0:16;
X            volatile const  uint32_t  RESERVE0:16;
N        } MVLD1;
N   };
N
N   union {
N        __IO uint32_t   u32MVLD2;
X        volatile uint32_t   u32MVLD2;
N
N        struct {
N            __IO uint32_t  MSGVAL32_17:16;
X            volatile uint32_t  MSGVAL32_17:16;
N            __I  uint32_t  RESERVE0:16;
X            volatile const  uint32_t  RESERVE0:16;
N        } MVLD2;
N   };
N    
N    union {
N        __IO uint32_t   u32WU_EN;            
X        volatile uint32_t   u32WU_EN;            
N        struct {
N            __IO uint32_t  WAKUP_EN:1;
X            volatile uint32_t  WAKUP_EN:1;
N            __I  uint32_t  RESERVE0:31;
X            volatile const  uint32_t  RESERVE0:31;
N        } WU_EN;
N    }; 
N
N    union {
N        __IO uint32_t   u32WU_STATUS;
X        volatile uint32_t   u32WU_STATUS;
N        struct {
N            __IO uint32_t  WAKUP_STS:1;
X            volatile uint32_t  WAKUP_STS:1;
N            __I  uint32_t  RESERVE0:31;
X            volatile const  uint32_t  RESERVE0:31;
N        } WU_STATUS;
N    }; 
N
N    
N} CAN_T;
N
N
N/* CAN CON Bit Field Definitions */
N#define CAN_CON_TEST_Pos           7
N#define CAN_CON_TEST_Msk           (1ul << CAN_CON_TEST_Pos)
N
N#define CAN_CON_CCE_Pos            6
N#define CAN_CON_CCE_Msk            (1ul << CAN_CON_CCE_Pos)
N
N#define CAN_CON_DAR_Pos            5
N#define CAN_CON_DAR_Msk            (1ul << CAN_CON_DAR_Pos)
N
N#define CAN_CON_EIE_Pos            3
N#define CAN_CON_EIE_Msk            (1ul << CAN_CON_EIE_Pos)
N
N#define CAN_CON_SIE_Pos            2
N#define CAN_CON_SIE_Msk            (1ul << CAN_CON_SIE_Pos)
N
N#define CAN_CON_IE_Pos             1
N#define CAN_CON_IE_Msk             (1ul << CAN_CON_IE_Pos)
N
N#define CAN_CON_INIT_Pos           0
N#define CAN_CON_INIT_Msk           (1ul << CAN_CON_INIT_Pos)
N
N/* CAN STATUS Bit Field Definitions */
N#define CAN_STATUS_BOFF_Pos        7
N#define CAN_STATUS_BOFF_Msk        (1ul << CAN_STATUS_BOFF_Pos)
N
N#define CAN_STATUS_EWARN_Pos       6
N#define CAN_STATUS_EWARN_Msk       (1ul << CAN_STATUS_EWARN_Pos)
N
N#define CAN_STATUS_EPASS_Pos       5
N#define CAN_STATUS_EPASS_Msk       (1ul << CAN_STATUS_EPASS_Pos)
N
N#define CAN_STATUS_RXOK_Pos        4
N#define CAN_STATUS_RXOK_Msk        (1ul << CAN_STATUS_RXOK_Pos)
N
N#define CAN_STATUS_TXOK_Pos        3
N#define CAN_STATUS_TXOK_Msk        (1ul << CAN_STATUS_RXOK_Pos)
N
N#define CAN_STATUS_LEC_Pos         0
N#define CAN_STATUS_LEC_Msk         (0x3ul << CAN_STATUS_LEC_Pos)
N
N/* CAN ERR Bit Field Definitions */
N#define CAN_ERR_RP_Pos             15
N#define CAN_ERR_RP_Msk             (1ul << CAN_ERR_RP_Pos)
N
N#define CAN_ERR_REC_Pos            8
N#define CAN_ERR_REC_Msk            (0x7Ful << CAN_ERR_REC_Pos)
N
N#define CAN_ERR_TEC_Pos            0
N#define CAN_ERR_TEC_Msk            (0xFFul << CAN_ERR_TEC_Pos)
N
N/* CAN BTIME Bit Field Definitions */
N#define CAN_BTIME_TSEG2_Pos        12
N#define CAN_BTIME_TSEG2_Msk        (0x7ul << CAN_BTIME_TSEG2_Pos)
N
N#define CAN_BTIME_TSEG1_Pos        8
N#define CAN_BTIME_TSEG1_Msk        (0xFul << CAN_BTIME_TSEG1_Pos)
N
N#define CAN_BTIME_SJW_Pos          6
N#define CAN_BTIME_SJW_Msk          (0x3ul << CAN_BTIME_SJW_Pos)
N
N#define CAN_BTIME_BRP_Pos          0
N#define CAN_BTIME_BRP_Msk          (0x3Ful << CAN_BTIME_BRP_Pos)
N
N/* CAN IIDR Bit Field Definitions */
N#define CAN_IIDR_INTID_Pos         0
N#define CAN_IIDR_INTID_Msk         (0xFFFFul << CAN_IIDR_INTID_Pos)
N
N/* CAN TEST Bit Field Definitions */
N#define CAN_TEST_RX_Pos            7
N#define CAN_TEST_RX_Msk            (1ul << CAN_TEST_RX_Pos)
N
N#define CAN_TEST_TX_Pos            5
N#define CAN_TEST_TX_Msk            (0x3ul << CAN_TEST_TX_Pos)
N
N#define CAN_TEST_LBACK_Pos         4
N#define CAN_TEST_LBACK_Msk         (1ul << CAN_TEST_LBACK_Pos)
N             
N#define CAN_TEST_SILENT_Pos        3
N#define CAN_TEST_SILENT_Msk        (1ul << CAN_TEST_SILENT_Pos)
N
N#define CAN_TEST_BASIC_Pos         2
N#define CAN_TEST_BASIC_Msk         (1ul << CAN_TEST_BASIC_Pos)
N
N#define CAN_TEST_BASIC_Pos         2
N#define CAN_TEST_BASIC_Msk         (1ul << CAN_TEST_BASIC_Pos)
N
N/* CAN BPRE Bit Field Definitions */
N#define CAN_BPRE_BPRE_Pos          0
N#define CAN_BPRE_BPRE_Msk          (0xFul << CAN_BPRE_BPRE_Pos)
N
N/* CAN IFn_CREQ Bit Field Definitions */
N#define CAN_IFnCREQ_BUSY_Pos       15
N#define CAN_IFnCREQ_BUSY_Msk       (1ul << CAN_IFnCREQ_BUSY_Pos)
N
N#define CAN_IFnCREQ_MSGNUM_Pos     0
N#define CAN_IFnCREQ_MSGNUM_Msk     (0x3Ful << CAN_IFnCREQ_MSGNUM_Pos)
N
N/* CAN IFn_CMASK Bit Field Definitions */
N#define CAN_IFnCMASK_WRRD_Pos      7
N#define CAN_IFnCMASK_WRRD_Msk      (1ul << CAN_IFnCMASK_WRRD_Pos)
N
N#define CAN_IFnCMASK_MASK_Pos      6
N#define CAN_IFnCMASK_MASK_Msk      (1ul << CAN_IFnCMASK_MASK_Pos)
N
N#define CAN_IFnCMASK_ARB_Pos       5
N#define CAN_IFnCMASK_ARB_Msk       (1ul << CAN_IFnCMASK_ARB_Pos)
N
N#define CAN_IFnCMASK_CONTROL_Pos   4
N#define CAN_IFnCMASK_CONTROL_Msk   (1ul << CAN_IFnCMASK_CONTROL_Pos)
N
N#define CAN_IFnCMASK_CLRINTPND_Pos 3
N#define CAN_IFnCMASK_CLRINTPND_Msk (1ul << CAN_IFnCMASK_CLRINTPND_Pos)
N  
N#define CAN_IFnCMASK_TXRQSTNEWDAT_Pos 2
N#define CAN_IFnCMASK_TXRQSTNEWDAT_Msk (1ul << CAN_IFnCMASK_TXRQSTNEWDAT_Pos)
N
N#define CAN_IFnCMASK_DATAA_Pos     1
N#define CAN_IFnCMASK_DATAA_Msk     (1ul << CAN_IFnCMASK_DATAA_Pos)
N
N#define CAN_IFnCMASK_DATAB_Pos     0
N#define CAN_IFnCMASK_DATAB_Msk     (1ul << CAN_IFnCMASK_DATAB_Pos)
N
N/* CAN IFn_MASK1 Bit Field Definitions */
N#define CAN_IFnMASK1_MSK_Pos       0
N#define CAN_IFnMASK1_MSK_Msk       (0xFFul << CAN_IFnMASK1_MSK_Pos)
N
N/* CAN IFn_MASK2 Bit Field Definitions */
N#define CAN_IFnMASK2_MXTD_Pos      15
N#define CAN_IFnMASK2_MXTD_Msk      (1ul << CAN_IFnMASK2_MXTD_Pos)
N
N#define CAN_IFnMASK2_MDIR_Pos      14
N#define CAN_IFnMASK2_MDIR_Msk      (1ul << CAN_IFnMASK2_MDIR_Pos)
N
N#define CAN_IFnMASK2_MSK_Pos       0
N#define CAN_IFnMASK2_MSK_Msk       (0x1FFul << CAN_IFnMASK2_MSK_Pos)
N
N/* CAN IFn_ARB1 Bit Field Definitions */
N#define CAN_IFnARB1_ID_Pos         0
N#define CAN_IFnARB1_ID_Msk         (0xFFFFul << CAN_IFnARB1_ID_Pos)
N
N/* CAN IFn_ARB2 Bit Field Definitions */
N#define CAN_IFnARB2_MSGVAL_Pos     15
N#define CAN_IFnARB2_MSGVAL_Msk     (1ul << CAN_IFnARB2_MSGVAL_Pos)
N
N#define CAN_IFnARB2_XTD_Pos        14
N#define CAN_IFnARB2_XTD_Msk        (1ul << CAN_IFnARB2_XTD_Pos)
N
N#define CAN_IFnARB2_DIR_Pos        13
N#define CAN_IFnARB2_DIR_Msk        (1ul << CAN_IFnARB2_DIR_Pos)
N
N#define CAN_IFnARB2_ID_Pos         0
N#define CAN_IFnARB2_ID_Msk         (0x1FFFul << CAN_IFnARB2_ID_Pos)
N
N/* CAN IFn_MCON Bit Field Definitions */
N#define CAN_IFnMCON_NEWDAT_Pos     15
N#define CAN_IFnMCON_NEWDAT_Msk     (1ul << CAN_IFnMCON_NEWDAT_Pos)
N
N#define CAN_IFnMCON_MSGLST_Pos     14
N#define CAN_IFnMCON_MSGLST_Msk     (1ul << CAN_IFnMCON_MSGLST_Pos)
N
N#define CAN_IFnMCON_INTPND_Pos     13
N#define CAN_IFnMCON_INTPND_Msk     (1ul << CAN_IFnMCON_INTPND_Pos)
N
N#define CAN_IFnMCON_UMASK_Pos      12
N#define CAN_IFnMCON_UMASK_Msk      (1ul << CAN_IFnMCON_UMASK_Pos)
N
N#define CAN_IFnMCON_TXIE_Pos       11
N#define CAN_IFnMCON_TXIE_Msk       (1ul << CAN_IFnMCON_TXIE_Pos)
N
N#define CAN_IFnMCON_RXIE_Pos       10
N#define CAN_IFnMCON_RXIE_Msk       (1ul << CAN_IFnMCON_RXIE_Pos)
N
N#define CAN_IFnMCON_RMTEN_Pos      9
N#define CAN_IFnMCON_RMTEN_Msk      (1ul << CAN_IFnMCON_RMTEN_Pos)
N
N#define CAN_IFnMCON_TXRQST_Pos     8
N#define CAN_IFnMCON_TXRQST_Msk     (1ul << CAN_IFnMCON_TXRQST_Pos)
N
N#define CAN_IFnMCON_EOB_Pos        7
N#define CAN_IFnMCON_EOB_Msk        (1ul << CAN_IFnMCON_EOB_Pos)
N
N#define CAN_IFnMCON_DLC_Pos        0
N#define CAN_IFnMCON_DLC_Msk        (0xFul << CAN_IFnMCON_DLC_Pos)
N
N/* CAN IFn_DATA_A1 Bit Field Definitions */
N#define CAN_IFnDATAA1_DATA1_Pos    8
N#define CAN_IFnDATAA1_DATA1_Msk    (0xFul << CAN_IFnDATAA1_DATA1_Pos)
N
N#define CAN_IFnDATAA1_DATA0_Pos    0
N#define CAN_IFnDATAA1_DATA0_Msk    (0xFul << CAN_IFnDATAA1_DATA0_Pos)
N
N/* CAN IFn_DATA_A2 Bit Field Definitions */
N#define CAN_IFnDATAA2_DATA3_Pos    8
N#define CAN_IFnDATAA2_DATA3_Msk    (0xFul << CAN_IFnDATAA2_DATA3_Pos)
N
N#define CAN_IFnDATAA2_DATA2_Pos    0
N#define CAN_IFnDATAA2_DATA2_Msk    (0xFul << CAN_IFnDATAA2_DATA2_Pos)
N
N/* CAN IFn_DATA_B1 Bit Field Definitions */
N#define CAN_IFnDATAB1_DATA5_Pos    8
N#define CAN_IFnDATAB1_DATA5_Msk    (0xFul << CAN_IFnDATAB1_DATA5_Pos)
N
N#define CAN_IFnDATAB1_DATA4_Pos    0
N#define CAN_IFnDATAB1_DATA4_Msk    (0xFul << CAN_IFnDATAB1_DATA4_Pos)
N
N/* CAN IFn_DATA_B2 Bit Field Definitions */
N#define CAN_IFnDATAB2_DATA7_Pos    8
N#define CAN_IFnDATAB2_DATA7_Msk    (0xFul << CAN_IFnDATAB2_DATA7_Pos)
N
N#define CAN_IFnDATAB2_DATA6_Pos    8
N#define CAN_IFnDATAB2_DATA6_Msk    (0xFul << CAN_IFnDATAB2_DATA6_Pos)
N
N/* CAN IFn_TXRQST1 Bit Field Definitions */
N#define CAN_IFnTXRQST1_TXRQST_Pos  0
N#define CAN_IFnTXRQST1_TXRQST_Msk  (0xFFFFul << CAN_IFnTXRQST1_TXRQST_Pos)
N
N/* CAN IFn_TXRQST2 Bit Field Definitions */
N#define CAN_IFnTXRQST2_TXRQST_Pos  0
N#define CAN_IFnTXRQST2_TXRQST_Msk  (0xFFFFul << CAN_IFnTXRQST2_TXRQST_Pos)
N
N/* CAN IFn_NDAT1 Bit Field Definitions */
N#define CAN_IFnNDAT1_NEWDATA_Pos   0
N#define CAN_IFnNDAT1_NEWDATA_Msk   (0xFFFFul << CAN_IFnNDAT1_NEWDATA_Pos)
N
N/* CAN IFn_NDAT2 Bit Field Definitions */
N#define CAN_IFnNDAT2_NEWDATA_Pos   0
N#define CAN_IFnNDAT2_NEWDATA_Msk   (0xFFFFul << CAN_IFnNDAT2_NEWDATA_Pos)
N
N/* CAN IFn_IPND1 Bit Field Definitions */
N#define CAN_IFnIPND1_INTPND_Pos   0
N#define CAN_IFnIPND1_INTPND_Msk   (0xFFFFul << CAN_IFnIPND1_INTPND_Pos)
N
N/* CAN IFn_IPND2 Bit Field Definitions */
N#define CAN_IFnIPND2_INTPND_Pos   0
N#define CAN_IFnIPND2_INTPND_Msk   (0xFFFFul << CAN_IFnIPND2_INTPND_Pos)
N
N/* CAN IFn_MVLD1 Bit Field Definitions */
N#define CAN_IFnMVLD1_MSGVAL_Pos   0
N#define CAN_IFnMVLD1_MSGVAL_Msk   (0xFFFFul << CAN_IFnMVLD1_MSGVAL_Pos)
N
N/* CAN IFn_MVLD2 Bit Field Definitions */
N#define CAN_IFnMVLD2_MSGVAL_Pos   0
N#define CAN_IFnMVLD2_MSGVAL_Msk   (0xFFFFul << CAN_IFnMVLD2_MSGVAL_Pos)
N
N/* CAN WUEN Bit Field Definitions */
N#define CAN_WUEN_WAKUP_EN_Pos     0
N#define CAN_WUEN_WAKUP_EN_Msk    (1ul << CAN_WUEN_WAKUP_EN_Pos)
N
N/* CAN WUSTATUS Bit Field Definitions */
N#define CAN_WUSTATUS_WAKUP_STS_Pos     0
N#define CAN_WUSTATUS_WAKUP_STS_Msk    (1ul << CAN_WUSTATUS_WAKUP_STS_Pos)
N                                  
N/*--------------------------- USB Device Controller --------------------------*/
Ntypedef struct
N{
N    __IO uint32_t  BUS_IE:1;
X    volatile uint32_t  BUS_IE:1;
N    __IO uint32_t  USB_IE:1;
X    volatile uint32_t  USB_IE:1;
N    __IO uint32_t  FLDET_IE:1;
X    volatile uint32_t  FLDET_IE:1;
N    __IO uint32_t  WAKEUP_IE:1;
X    volatile uint32_t  WAKEUP_IE:1;
N    __I  uint32_t  RESERVE0:4;
X    volatile const  uint32_t  RESERVE0:4;
N    __IO uint32_t  WAKEUP_EN:1;
X    volatile uint32_t  WAKEUP_EN:1;
N    __I  uint32_t  RESERVE1:6;
X    volatile const  uint32_t  RESERVE1:6;
N    __IO uint32_t  INNAK_EN:1;
X    volatile uint32_t  INNAK_EN:1;
N    __I  uint32_t  RESERVE2:16;
X    volatile const  uint32_t  RESERVE2:16;
N} USBD_INTEN_T;
N
Ntypedef struct
N{
N    __IO uint32_t  BUS_STS:1;
X    volatile uint32_t  BUS_STS:1;
N    __IO uint32_t  USB_STS:1;
X    volatile uint32_t  USB_STS:1;
N    __IO uint32_t  FLDET_STS:1;
X    volatile uint32_t  FLDET_STS:1;
N    __IO uint32_t  WAKEUP_STS:1;
X    volatile uint32_t  WAKEUP_STS:1;
N    __I  uint32_t  RESERVE0:12;
X    volatile const  uint32_t  RESERVE0:12;
N    __IO uint32_t  EPEVT:6;
X    volatile uint32_t  EPEVT:6;
N    __I  uint32_t  RESERVE1:9;
X    volatile const  uint32_t  RESERVE1:9;
N    __IO uint32_t  SETUP:1;
X    volatile uint32_t  SETUP:1;
N} USBD_INTSTS_T;
N
Ntypedef struct
N{
N    __IO uint32_t  FADDR:7;
X    volatile uint32_t  FADDR:7;
N    __I  uint32_t  RESERVE:25;
X    volatile const  uint32_t  RESERVE:25;
N} USBD_FADDR_T;
N
Ntypedef struct
N{
N    __I  uint32_t  RESERVE0:7;
X    volatile const  uint32_t  RESERVE0:7;
N    __I  uint32_t  OVERRUN:1;
X    volatile const  uint32_t  OVERRUN:1;
N    __I  uint32_t  EPSTS0:3;
X    volatile const  uint32_t  EPSTS0:3;
N    __I  uint32_t  EPSTS1:3;
X    volatile const  uint32_t  EPSTS1:3;
N    __I  uint32_t  EPSTS2:3;
X    volatile const  uint32_t  EPSTS2:3;
N    __I  uint32_t  EPSTS3:3;
X    volatile const  uint32_t  EPSTS3:3;
N    __I  uint32_t  EPSTS4:3;
X    volatile const  uint32_t  EPSTS4:3;
N    __I  uint32_t  EPSTS5:3;
X    volatile const  uint32_t  EPSTS5:3;
N    __I  uint32_t  RESERVE1:6;
X    volatile const  uint32_t  RESERVE1:6;
N} USBD_EPSTS_T;
N
N
N
Ntypedef struct
N{
N    __I  uint32_t  USBRST:1;
X    volatile const  uint32_t  USBRST:1;
N    __I  uint32_t  SUSPEND:1;
X    volatile const  uint32_t  SUSPEND:1;
N    __I  uint32_t  RESUME:1;
X    volatile const  uint32_t  RESUME:1;
N    __I  uint32_t  TIMEOUT:1;
X    volatile const  uint32_t  TIMEOUT:1;
N    __IO uint32_t  PHY_EN:1;
X    volatile uint32_t  PHY_EN:1;
N    __IO uint32_t  RWAKEUP:1;
X    volatile uint32_t  RWAKEUP:1;
N    __I  uint32_t  RESERVE0:1;
X    volatile const  uint32_t  RESERVE0:1;
N    __IO uint32_t  USB_EN:1;
X    volatile uint32_t  USB_EN:1;
N    __IO uint32_t  DPPU_EN:1;
X    volatile uint32_t  DPPU_EN:1;
N    __IO uint32_t  PWRDN:1;
X    volatile uint32_t  PWRDN:1;
N    __I  uint32_t  RESERVE1:22;
X    volatile const  uint32_t  RESERVE1:22;
N} USBD_ATTR_T;
N
N
N
Ntypedef struct
N{
N    __IO uint32_t  FLDET:1;
X    volatile uint32_t  FLDET:1;
N    __I  uint32_t  RESERVE:31;
X    volatile const  uint32_t  RESERVE:31;
N} USBD_FLDET_T;
N
Ntypedef struct
N{
N    __I  uint32_t  RESERVE0:3;
X    volatile const  uint32_t  RESERVE0:3;
N    __IO uint32_t  STBUFSEG:6;
X    volatile uint32_t  STBUFSEG:6;
N    __I  uint32_t  RESERVE:23;
X    volatile const  uint32_t  RESERVE:23;
N} USBD_STBUFSEG_T;
N
Ntypedef struct
N{
N    __IO uint32_t  MXPLD:9;
X    volatile uint32_t  MXPLD:9;
N    __I  uint32_t  RESERVE:23;
X    volatile const  uint32_t  RESERVE:23;
N} USBD_MXPLD_T;
N
Ntypedef struct
N{
N    __IO uint32_t  EP_NUM:4;
X    volatile uint32_t  EP_NUM:4;
N    __IO uint32_t  ISOCH:1;
X    volatile uint32_t  ISOCH:1;
N    __IO uint32_t  STATE:2;
X    volatile uint32_t  STATE:2;
N    __IO uint32_t  DSQ_SYNC:1;
X    volatile uint32_t  DSQ_SYNC:1;
N    __I  uint32_t  RESERVE0:1;
X    volatile const  uint32_t  RESERVE0:1;
N    __IO uint32_t  CSTALL:1;
X    volatile uint32_t  CSTALL:1;
N    __I  uint32_t  RESERVE1:22;
X    volatile const  uint32_t  RESERVE1:22;
N} USBD_CFG_T;
N
Ntypedef struct
N{
N    __IO uint32_t  CLRRDY:1;
X    volatile uint32_t  CLRRDY:1;
N    __IO uint32_t  SSTALL:1;
X    volatile uint32_t  SSTALL:1;
N    __I  uint32_t  RESERVE:30;
X    volatile const  uint32_t  RESERVE:30;
N} USBD_CFGP_T;
N
Ntypedef struct
N{
N    __IO uint32_t  DRVSE0:1;
X    volatile uint32_t  DRVSE0:1;
N    __I  uint32_t  RESERVE:31;
X    volatile const  uint32_t  RESERVE:31;
N} USBD_DRVSE0_T;
N
Ntypedef struct
N{
N    union {
N        __IO uint32_t u32BUFSEG;
X        volatile uint32_t u32BUFSEG;
N        struct {
N            __I  uint32_t  RESERVE0:3;
X            volatile const  uint32_t  RESERVE0:3;
N            __IO uint32_t  BUFSEG:6;
X            volatile uint32_t  BUFSEG:6;
N            __I  uint32_t  RESERVE:23;
X            volatile const  uint32_t  RESERVE:23;
N        } BUFSEG;
N    };
N    
N    union {
N        __IO uint32_t u32MXPLD;
X        volatile uint32_t u32MXPLD;
N        struct {
N            __IO uint32_t  MXPLD:9;
X            volatile uint32_t  MXPLD:9;
N            __I  uint32_t  RESERVE:23;
X            volatile const  uint32_t  RESERVE:23;
N        } MXPLD;
N    };
N    
N    union {
N        __IO uint32_t u32CFG;
X        volatile uint32_t u32CFG;
N        struct {
N            __IO uint32_t  EP_NUM:4;
X            volatile uint32_t  EP_NUM:4;
N            __IO uint32_t  ISOCH:1;
X            volatile uint32_t  ISOCH:1;
N            __IO uint32_t  STATE:2;
X            volatile uint32_t  STATE:2;
N            __IO uint32_t  DSQ_SYNC:1;
X            volatile uint32_t  DSQ_SYNC:1;
N            __I  uint32_t  RESERVE0:1;
X            volatile const  uint32_t  RESERVE0:1;
N            __IO uint32_t  CSTALL:1;
X            volatile uint32_t  CSTALL:1;
N            __I  uint32_t  RESERVE1:22;
X            volatile const  uint32_t  RESERVE1:22;
N        } CFG;
N    };
N    
N    union {
N        __IO uint32_t u32CFGP;
X        volatile uint32_t u32CFGP;
N        struct {
N            __IO uint32_t  CLRRDY:1;
X            volatile uint32_t  CLRRDY:1;
N            __IO uint32_t  SSTALL:1;
X            volatile uint32_t  SSTALL:1;
N            __I  uint32_t  RESERVE:30;
X            volatile const  uint32_t  RESERVE:30;
N        } CFGP;
N    };
N    
N} USBD_EP_T;
N
N
Ntypedef struct
N{
N    union {
N        __IO uint32_t u32INTEN;
X        volatile uint32_t u32INTEN;
N        struct {
N            __IO uint32_t  BUS_IE:1;
X            volatile uint32_t  BUS_IE:1;
N            __IO uint32_t  USB_IE:1;
X            volatile uint32_t  USB_IE:1;
N            __IO uint32_t  FLDET_IE:1;
X            volatile uint32_t  FLDET_IE:1;
N            __IO uint32_t  WAKEUP_IE:1;
X            volatile uint32_t  WAKEUP_IE:1;
N            __I  uint32_t  RESERVE0:4;
X            volatile const  uint32_t  RESERVE0:4;
N            __IO uint32_t  WAKEUP_EN:1;
X            volatile uint32_t  WAKEUP_EN:1;
N            __I  uint32_t  RESERVE1:6;
X            volatile const  uint32_t  RESERVE1:6;
N            __IO uint32_t  INNAK_EN:1;
X            volatile uint32_t  INNAK_EN:1;
N            __I  uint32_t  RESERVE2:16;
X            volatile const  uint32_t  RESERVE2:16;
N        } INTEN;
N    };
N    
N    union {
N        __IO uint32_t u32INTSTS;
X        volatile uint32_t u32INTSTS;
N        struct {
N            __IO uint32_t  BUS_STS:1;
X            volatile uint32_t  BUS_STS:1;
N            __IO uint32_t  USB_STS:1;
X            volatile uint32_t  USB_STS:1;
N            __IO uint32_t  FLDET_STS:1;
X            volatile uint32_t  FLDET_STS:1;
N            __IO uint32_t  WAKEUP_STS:1;
X            volatile uint32_t  WAKEUP_STS:1;
N            __I  uint32_t  RESERVE0:12;
X            volatile const  uint32_t  RESERVE0:12;
N            __IO uint32_t  EPEVT:6;
X            volatile uint32_t  EPEVT:6;
N            __I  uint32_t  RESERVE1:9;
X            volatile const  uint32_t  RESERVE1:9;
N            __IO uint32_t  SETUP:1;
X            volatile uint32_t  SETUP:1;
N        } INTSTS;
N    };
N    
N    union {
N        __IO uint32_t u32FADDR;
X        volatile uint32_t u32FADDR;
N        struct {
N            __IO uint32_t  FADDR:7;
X            volatile uint32_t  FADDR:7;
N            __I  uint32_t  RESERVE:25;
X            volatile const  uint32_t  RESERVE:25;
N        } FADDR;
N    };
N    
N    union {
N        __IO uint32_t u32EPSTS;
X        volatile uint32_t u32EPSTS;
N        struct {
N            __I  uint32_t  RESERVE0:7;
X            volatile const  uint32_t  RESERVE0:7;
N            __I  uint32_t  OVERRUN:1;
X            volatile const  uint32_t  OVERRUN:1;
N            __I  uint32_t  EPSTS0:3;
X            volatile const  uint32_t  EPSTS0:3;
N            __I  uint32_t  EPSTS1:3;
X            volatile const  uint32_t  EPSTS1:3;
N            __I  uint32_t  EPSTS2:3;
X            volatile const  uint32_t  EPSTS2:3;
N            __I  uint32_t  EPSTS3:3;
X            volatile const  uint32_t  EPSTS3:3;
N            __I  uint32_t  EPSTS4:3;
X            volatile const  uint32_t  EPSTS4:3;
N            __I  uint32_t  EPSTS5:3;
X            volatile const  uint32_t  EPSTS5:3;
N            __I  uint32_t  RESERVE1:6;
X            volatile const  uint32_t  RESERVE1:6;
N        } EPSTS;
N    };
N    
N    union {
N        __IO uint32_t u32ATTR;
X        volatile uint32_t u32ATTR;
N        struct {
N            __I  uint32_t  USBRST:1;
X            volatile const  uint32_t  USBRST:1;
N            __I  uint32_t  SUSPEND:1;
X            volatile const  uint32_t  SUSPEND:1;
N            __I  uint32_t  RESUME:1;
X            volatile const  uint32_t  RESUME:1;
N            __I  uint32_t  TIMEOUT:1;
X            volatile const  uint32_t  TIMEOUT:1;
N            __IO uint32_t  PHY_EN:1;
X            volatile uint32_t  PHY_EN:1;
N            __IO uint32_t  RWAKEUP:1;
X            volatile uint32_t  RWAKEUP:1;
N            __I  uint32_t  RESERVE0:1;
X            volatile const  uint32_t  RESERVE0:1;
N            __IO uint32_t  USB_EN:1;
X            volatile uint32_t  USB_EN:1;
N            __IO uint32_t  DPPU_EN:1;
X            volatile uint32_t  DPPU_EN:1;
N            __IO uint32_t  PWRDN:1;
X            volatile uint32_t  PWRDN:1;
N            __I  uint32_t  RESERVE1:22;
X            volatile const  uint32_t  RESERVE1:22;
N        } ATTR;
N    };
N    
N    union {
N        __IO uint32_t u32FLDET;
X        volatile uint32_t u32FLDET;
N        struct {
N            __I  uint32_t  FLDET:1;
X            volatile const  uint32_t  FLDET:1;
N            __I  uint32_t  RESERVE:31;
X            volatile const  uint32_t  RESERVE:31;
N        } FLDET;
N    };
N    
N    union {
N        __IO uint32_t u32STBUFSEG;
X        volatile uint32_t u32STBUFSEG;
N        struct {
N            __I  uint32_t  RESERVE0:3;
X            volatile const  uint32_t  RESERVE0:3;
N            __IO uint32_t  STBUFSEG:6;
X            volatile uint32_t  STBUFSEG:6;
N            __I  uint32_t  RESERVE:23;
X            volatile const  uint32_t  RESERVE:23;
N        } STBUFSEG;
N    };
N    
N    __I uint32_t RESERVE0;
X    volatile const uint32_t RESERVE0;
N    
N    USBD_EP_T EP[6];
N    
N    __I uint32_t RESERVE1[4];
X    volatile const uint32_t RESERVE1[4];
N    
N    union {
N        __IO uint32_t u32DRVSE0;
X        volatile uint32_t u32DRVSE0;
N        struct {
N            __IO uint32_t  DRVSE0:1;
X            volatile uint32_t  DRVSE0:1;
N            __I  uint32_t  RESERVE:31;
X            volatile const  uint32_t  RESERVE:31;
N        } DRVSE0;
N    };
N    
N     __I uint32_t RESERVE2[4];
X     volatile const uint32_t RESERVE2[4];
N    
N} USBD_T;
N
N/* USBD INTEN Bit Field Definitions */
N#define USBD_INTEN_INNAK_EN_Pos    15
N#define USBD_INTEN_INNAK_EN_Msk    (1ul << USBD_INTEN_INNAK_EN_Pos)
N
N#define USBD_INTEN_WAKEUP_EN_Pos   8
N#define USBD_INTEN_WAKEUP_EN_Msk   (1ul << USBD_INTEN_WAKEUP_EN_Pos)
N
N#define USBD_INTEN_WAKEUP_IE_Pos   3
N#define USBD_INTEN_WAKEUP_IE_Msk   (1ul << USBD_INTEN_WAKEUP_IE_Pos)
N
N#define USBD_INTEN_FLDET_IE_Pos    2
N#define USBD_INTEN_FLDET_IE_Msk    (1ul << USBD_INTEN_FLDET_IE_Pos)
N
N#define USBD_INTEN_USB_IE_Pos      1
N#define USBD_INTEN_USB_IE_Msk      (1ul << USBD_INTEN_USB_IE_Pos)
N
N#define USBD_INTEN_BUS_IE_Pos      0
N#define USBD_INTEN_BUS_IE_Msk      (1ul << USBD_INTEN_BUS_IE_Pos)
N
N/* USBD INTSTS Bit Field Definitions */
N#define USBD_INTSTS_SETUP_Pos        31
N#define USBD_INTSTS_SETUP_Msk        (1ul << USBD_INTSTS_SETUP_Pos)
N
N#define USBD_INTSTS_EPEVT_Pos        16
N#define USBD_INTSTS_EPEVT_Msk        (0x3Ful << USBD_INTSTS_EPEVT_Pos)
N
N#define USBD_INTSTS_WAKEUP_STS_Pos   3
N#define USBD_INTSTS_WAKEUP_STS_Msk   (1ul << USBD_INTSTS_WAKEUP_STS_Pos)
N
N#define USBD_INTSTS_FLDET_STS_Pos    2
N#define USBD_INTSTS_FLDET_STS_Msk    (1ul << USBD_INTSTS_FLDET_STS_Pos)
N
N#define USBD_INTSTS_USB_STS_Pos      1
N#define USBD_INTSTS_USB_STS_Msk      (1ul << USBD_INTSTS_USB_STS_Pos)
N
N#define USBD_INTSTS_BUS_STS_Pos      0
N#define USBD_INTSTS_BUS_STS_Msk      (1ul << USBD_INTSTS_BUS_STS_Pos)
N
N/* USBD FADDR Bit Field Definitions */
N#define USBD_FADDR_FADDR_Pos     0
N#define USBD_FADDR_FADDR_Msk     (0x7Ful << USBD_FADDR_FADDR_Pos)
N
N/* USBD EPSTS Bit Field Definitions */
N#define USBD_EPSTS_EPSTS5_Pos    23
N#define USBD_EPSTS_EPSTS5_Msk    (7ul << USBD_EPSTS_EPSTS5_Pos)
N
N#define USBD_EPSTS_EPSTS4_Pos    20
N#define USBD_EPSTS_EPSTS4_Msk    (7ul << USBD_EPSTS_EPSTS4_Pos)
N
N#define USBD_EPSTS_EPSTS3_Pos    17
N#define USBD_EPSTS_EPSTS3_Msk    (7ul << USBD_EPSTS_EPSTS3_Pos)
N
N#define USBD_EPSTS_EPSTS2_Pos    14
N#define USBD_EPSTS_EPSTS2_Msk    (7ul << USBD_EPSTS_EPSTS2_Pos)
N
N#define USBD_EPSTS_EPSTS1_Pos    11
N#define USBD_EPSTS_EPSTS1_Msk    (7ul << USBD_EPSTS_EPSTS1_Pos)
N
N#define USBD_EPSTS_EPSTS0_Pos    8
N#define USBD_EPSTS_EPSTS0_Msk    (7ul << USBD_EPSTS_EPSTS0_Pos)
N
N#define USBD_EPSTS_OVERRUN_Pos   7
N#define USBD_EPSTS_OVERRUN_Msk   (1ul << USBD_EPSTS_OVERRUN_Pos)
N
N/* USBD ATTR Bit Field Definitions */
N#define USBD_ATTR_PWRDN_Pos      9
N#define USBD_ATTR_PWRDN_Msk      (1ul << USBD_ATTR_PWRDN_Pos)
N
N#define USBD_ATTR_DPPU_EN_Pos    8
N#define USBD_ATTR_DPPU_EN_Msk    (1ul << USBD_ATTR_DPPU_EN_Pos)
N
N#define USBD_ATTR_USB_EN_Pos     7
N#define USBD_ATTR_USB_EN_Msk     (1ul << USBD_ATTR_USB_EN_Pos)
N
N#define USBD_ATTR_RWAKEUP_Pos    5
N#define USBD_ATTR_RWAKEUP_Msk    (1ul << USBD_ATTR_RWAKEUP_Pos)
N
N#define USBD_ATTR_PHY_EN_Pos     4
N#define USBD_ATTR_PHY_EN_Msk     (1ul << USBD_ATTR_PHY_EN_Pos)
N
N#define USBD_ATTR_TIMEOUT_Pos    3
N#define USBD_ATTR_TIMEOUT_Msk    (1ul << USBD_ATTR_TIMEOUT_Pos)
N
N#define USBD_ATTR_RESUME_Pos     2
N#define USBD_ATTR_RESUME_Msk     (1ul << USBD_ATTR_RESUME_Pos)
N
N#define USBD_ATTR_SUSPEND_Pos    1
N#define USBD_ATTR_SUSPEND_Msk    (1ul << USBD_ATTR_SUSPEND_Pos)
N
N#define USBD_ATTR_USBRST_Pos     0
N#define USBD_ATTR_USBRST_Msk     (1ul << USBD_ATTR_USBRST_Pos)
N
N/* USBD FLDET Bit Field Definitions */
N#define USBD_FLDET_FLDET_Pos     0
N#define USBD_FLDET_FLDET_Msk     (1ul << USBD_FLDET_FLDET_Pos)
N
N/* USBD STBUFSEG Bit Field Definitions */
N#define USBD_STBUFSEG_STBUFSEG_Pos   3
N#define USBD_STBUFSEG_STBUFSEG_Msk   (0x3Ful << USBD_STBUFSEG_STBUFSEG_Pos)
N
N/* USBD BUFSEG Bit Field Definitions */
N#define USBD_BUFSEG_BUFSEG_Pos   3
N#define USBD_BUFSEG_BUFSEG_Msk   (0x3Ful << USBD_BUFSEG_BUFSEG_Pos)
N
N/* USBD MXPLD Bit Field Definitions */
N#define USBD_MXPLD_MXPLD_Pos    0
N#define USBD_MXPLD_MXPLD_Msk    (0x1FFul << USBD_MXPLD_MXPLD_Pos)
N
N/* USBD CFG Bit Field Definitions */
N#define USBD_CFG_CSTALL_Pos     9
N#define USBD_CFG_CSTALL_Msk     (1ul << USBD_CFG_CSTALL_Pos)
N
N#define USBD_CFG_DSQ_SYNC_Pos   7
N#define USBD_CFG_DSQ_SYNC_Msk   (1ul << USBD_CFG_DSQ_SYNC_Pos)
N
N#define USBD_CFG_STATE_Pos      5
N#define USBD_CFG_STATE_Msk      (3ul << USBD_CFG_STATE_Pos)
N
N#define USBD_CFG_ISOCH_Pos      4
N#define USBD_CFG_ISOCH_Msk      (1ul << USBD_CFG_ISOCH_Pos)
N
N#define USBD_CFG_EP_NUM_Pos     0
N#define USBD_CFG_EP_NUM_Msk     (0xFul << USBD_CFG_EP_NUM_Pos)
N
N/* USBD CFGP Bit Field Definitions */
N#define USBD_CFGP_SSTALL_Pos    1
N#define USBD_CFGP_SSTALL_Msk    (1ul << USBD_CFGP_SSTALL_Pos)
N
N#define USBD_CFGP_CLRRDY_Pos    0
N#define USBD_CFGP_CLRRDY_Msk    (1ul << USBD_CFGP_CLRRDY_Pos)
N
N/* USBD DRVSE0 Bit Field Definitions */
N#define USBD_DRVSE0_DRVSE0_Pos   0
N#define USBD_DRVSE0_DRVSE0_Msk   (1ul << USBD_DRVSE0_DRVSE0_Pos)
N
N
N/*------------------------------ PDMA Controller -----------------------------*/
Ntypedef struct
N{
N    __IO uint32_t  PDMACEN:1;
X    volatile uint32_t  PDMACEN:1;
N    __IO uint32_t  SW_RST:1;
X    volatile uint32_t  SW_RST:1;
N    __IO uint32_t  MODE_SEL:2;
X    volatile uint32_t  MODE_SEL:2;
N    __IO uint32_t  SAD_SEL:2;
X    volatile uint32_t  SAD_SEL:2;
N    __IO uint32_t  DAD_SEL:2;
X    volatile uint32_t  DAD_SEL:2;
N    __I  uint32_t  RESERVE0:4;
X    volatile const  uint32_t  RESERVE0:4;
N    __IO uint32_t  WAR_BCR_SEL:4;
X    volatile uint32_t  WAR_BCR_SEL:4;
N    __I  uint32_t  RESERVE1:3;
X    volatile const  uint32_t  RESERVE1:3;
N    __IO uint32_t  APB_TWS:2;
X    volatile uint32_t  APB_TWS:2;
N    __I  uint32_t  RESERVE2:2;
X    volatile const  uint32_t  RESERVE2:2;
N    __IO uint32_t  TRIG_EN:1;
X    volatile uint32_t  TRIG_EN:1;
N    __I  uint32_t  RESERVE3:8;
X    volatile const  uint32_t  RESERVE3:8;
N} PDMA_CSR_T;
N
Ntypedef __IO uint32_t PDMA_SAR_T;
Xtypedef volatile uint32_t PDMA_SAR_T;
Ntypedef __IO uint32_t PDMA_DAR_T;
Xtypedef volatile uint32_t PDMA_DAR_T;
N
Ntypedef __IO uint32_t PDMA_BCR_T;
Xtypedef volatile uint32_t PDMA_BCR_T;
N
Ntypedef __I uint32_t PDMA_CSAR_T;
Xtypedef volatile const uint32_t PDMA_CSAR_T;
Ntypedef __I uint32_t PDMA_CDAR_T;
Xtypedef volatile const uint32_t PDMA_CDAR_T;
N
Ntypedef struct
N{
N    __I uint32_t  CBCR:16;
X    volatile const uint32_t  CBCR:16;
N    __I  uint32_t  RESERVE:16;
X    volatile const  uint32_t  RESERVE:16;
N} PDMA_CBCR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  TABORT_IE:1;
X    volatile uint32_t  TABORT_IE:1;
N    __IO uint32_t  BLKD_IE:1;
X    volatile uint32_t  BLKD_IE:1;
N    __I  uint32_t  RESERVE:30;
X    volatile const  uint32_t  RESERVE:30;
N} PDMA_IER_T;
N
Ntypedef struct
N{
N    __IO uint32_t  TABORT_IF:1;
X    volatile uint32_t  TABORT_IF:1;
N    __IO uint32_t  BLKD_IF:1;
X    volatile uint32_t  BLKD_IF:1;
N    __I  uint32_t  RESERVE:30;
X    volatile const  uint32_t  RESERVE:30;
N} PDMA_ISR_T;
N
Ntypedef __I uint32_t PDMA_SBUF_T;
Xtypedef volatile const uint32_t PDMA_SBUF_T;
N
Ntypedef struct
N{
N    __I  uint32_t  RESERVE0:8;
X    volatile const  uint32_t  RESERVE0:8;
N    __IO uint32_t  CLK0_EN:1;
X    volatile uint32_t  CLK0_EN:1;
N    __IO uint32_t  CLK1_EN:1;
X    volatile uint32_t  CLK1_EN:1;
N    __IO uint32_t  CLK2_EN:1;
X    volatile uint32_t  CLK2_EN:1;
N    __IO uint32_t  CLK3_EN:1;
X    volatile uint32_t  CLK3_EN:1;
N    __IO uint32_t  CLK4_EN:1;
X    volatile uint32_t  CLK4_EN:1;
N    __IO uint32_t  CLK5_EN:1;
X    volatile uint32_t  CLK5_EN:1;
N    __IO uint32_t  CLK6_EN:1;
X    volatile uint32_t  CLK6_EN:1;
N    __IO uint32_t  CLK7_EN:1;
X    volatile uint32_t  CLK7_EN:1;
N    __IO uint32_t  CLK8_EN:1;
X    volatile uint32_t  CLK8_EN:1;
N    __I  uint32_t  RESERVE1:15;
X    volatile const  uint32_t  RESERVE1:15;
N} PDMA_GCRCSR_T;
N
N
Ntypedef struct
N{
N    __IO uint32_t  SPI0_RXSEL:4;
X    volatile uint32_t  SPI0_RXSEL:4;
N    __IO uint32_t  SPI0_TXSEL:4;
X    volatile uint32_t  SPI0_TXSEL:4;
N    __IO uint32_t  SPI1_RXSEL:4;
X    volatile uint32_t  SPI1_RXSEL:4;
N    __IO uint32_t  SPI1_TXSEL:4;
X    volatile uint32_t  SPI1_TXSEL:4;
N    __IO uint32_t  SPI2_RXSEL:4;
X    volatile uint32_t  SPI2_RXSEL:4;
N    __IO uint32_t  SPI2_TXSEL:4;
X    volatile uint32_t  SPI2_TXSEL:4;
N    __IO uint32_t  SPI3_RXSEL:4;
X    volatile uint32_t  SPI3_RXSEL:4;
N    __IO uint32_t  SPI3_TXSEL:4;
X    volatile uint32_t  SPI3_TXSEL:4;
N} PDMA_PDSSR0_T;
N
N
Ntypedef struct
N{
N    __IO uint32_t  UART0_RXSEL:4;
X    volatile uint32_t  UART0_RXSEL:4;
N    __IO uint32_t  UART0_TXSEL:4;
X    volatile uint32_t  UART0_TXSEL:4;
N    __IO uint32_t  UART1_RXSEL:4;
X    volatile uint32_t  UART1_RXSEL:4;
N    __IO uint32_t  UART1_TXSEL:4;
X    volatile uint32_t  UART1_TXSEL:4;
N    __IO uint32_t  RESERVE0:8;
X    volatile uint32_t  RESERVE0:8;
N    __IO uint32_t  ADC_RXSEL:4;
X    volatile uint32_t  ADC_RXSEL:4;
N    __IO uint32_t  RESERVE1:4;
X    volatile uint32_t  RESERVE1:4;
N} PDMA_PDSSR1_T;
N                                                        
N
Ntypedef struct
N{
N    __I uint32_t  INTR0:1;
X    volatile const uint32_t  INTR0:1;
N    __I uint32_t  INTR1:1;
X    volatile const uint32_t  INTR1:1;
N    __I uint32_t  INTR2:1;
X    volatile const uint32_t  INTR2:1;
N    __I uint32_t  INTR3:1;
X    volatile const uint32_t  INTR3:1;
N    __I uint32_t  INTR4:1;
X    volatile const uint32_t  INTR4:1;
N    __I uint32_t  INTR5:1;
X    volatile const uint32_t  INTR5:1;
N    __I uint32_t  INTR6:1;
X    volatile const uint32_t  INTR6:1;
N    __I uint32_t  INTR7:1;
X    volatile const uint32_t  INTR7:1;
N    __I uint32_t  INTR8:1;
X    volatile const uint32_t  INTR8:1;
N    __I uint32_t  RESERVE:22;
X    volatile const uint32_t  RESERVE:22;
N    __I uint32_t  INTR:1;
X    volatile const uint32_t  INTR:1;
N} PDMA_GCRISR_T;
N
N
Ntypedef struct
N{
N    __IO uint32_t  I2S_RXSEL:4;
X    volatile uint32_t  I2S_RXSEL:4;
N    __IO uint32_t  I2S_TXSEL:4;
X    volatile uint32_t  I2S_TXSEL:4;
N    __I  uint32_t  RESERVE:24;
X    volatile const  uint32_t  RESERVE:24;
N} PDMA_PDSSR2_T;
N
Ntypedef struct
N{
N    union 
N    {
N        __IO uint32_t u32CSR;
X        volatile uint32_t u32CSR;
N        
N        struct 
N        {
N            __IO uint32_t  PDMACEN:1;
X            volatile uint32_t  PDMACEN:1;
N            __IO uint32_t  SW_RST:1;
X            volatile uint32_t  SW_RST:1;
N            __IO uint32_t  MODE_SEL:2;
X            volatile uint32_t  MODE_SEL:2;
N            __IO uint32_t  SAD_SEL:2;
X            volatile uint32_t  SAD_SEL:2;
N            __IO uint32_t  DAD_SEL:2;
X            volatile uint32_t  DAD_SEL:2;
N            __I  uint32_t  RESERVE0:11;
X            volatile const  uint32_t  RESERVE0:11;
N            __IO uint32_t  APB_TWS:2;
X            volatile uint32_t  APB_TWS:2;
N            __I  uint32_t  RESERVE1:2;
X            volatile const  uint32_t  RESERVE1:2;
N            __IO uint32_t  TRIG_EN:1;
X            volatile uint32_t  TRIG_EN:1;
N            __I  uint32_t  RESERVE2:8;
X            volatile const  uint32_t  RESERVE2:8;
N        } CSR;
N    };
N
N    union 
N    {
N        __IO uint32_t u32SAR;
X        volatile uint32_t u32SAR;
N        __IO uint32_t SAR;
X        volatile uint32_t SAR;
N    };
N
N    union 
N    {
N        __IO uint32_t u32DAR;
X        volatile uint32_t u32DAR;
N        __IO uint32_t DAR;
X        volatile uint32_t DAR;
N    };
N
N    union 
N    {
N        __IO uint32_t u32BCR;
X        volatile uint32_t u32BCR;
N        
N        struct 
N        {
N            __IO uint32_t  BCR:16;
X            volatile uint32_t  BCR:16;
N            __I  uint32_t  RESERVE0:16;
X            volatile const  uint32_t  RESERVE0:16;
N        } BCR;
N    };
N
N    union 
N    {
N        __I uint32_t u32POINT;
X        volatile const uint32_t u32POINT;
N        
N        struct 
N        {
N            __I  uint32_t  POINT:4;
X            volatile const  uint32_t  POINT:4;
N            __I  uint32_t  RESERVE0:28;
X            volatile const  uint32_t  RESERVE0:28;
N        } POINT;
N    };
N
N    union 
N    {
N        __I uint32_t u32CSAR;
X        volatile const uint32_t u32CSAR;
N        __I uint32_t CSAR;
X        volatile const uint32_t CSAR;
N    };
N
N    union 
N    {
N        __I uint32_t u32CDAR;
X        volatile const uint32_t u32CDAR;
N        __I uint32_t CDAR;
X        volatile const uint32_t CDAR;
N    };
N
N    union 
N    {
N        __I uint32_t u32CBCR;
X        volatile const uint32_t u32CBCR;
N        
N        struct 
N        {
N            __I uint32_t  CBCR:16;
X            volatile const uint32_t  CBCR:16;
N            __I  uint32_t  RESERVE0:16;
X            volatile const  uint32_t  RESERVE0:16;
N        } CBCR;
N    };
N
N    union 
N    {
N        __IO uint32_t u32IER;
X        volatile uint32_t u32IER;
N        
N        struct 
N        {
N            __IO uint32_t  TABORT_IE:1;
X            volatile uint32_t  TABORT_IE:1;
N            __IO uint32_t  BLKD_IE:1;
X            volatile uint32_t  BLKD_IE:1;
N            __I  uint32_t  RESERVE:30;
X            volatile const  uint32_t  RESERVE:30;
N        } IER;
N    };
N
N    union 
N    {
N        __IO uint32_t u32ISR;
X        volatile uint32_t u32ISR;
N        
N        struct 
N        {
N            __IO uint32_t  TABORT_IF:1;
X            volatile uint32_t  TABORT_IF:1;
N            __IO uint32_t  BLKD_IF:1;
X            volatile uint32_t  BLKD_IF:1;
N            __I  uint32_t  RESERVE:30;
X            volatile const  uint32_t  RESERVE:30;
N        } ISR;
N    };
N
N    __I uint32_t RESERVE[22];
X    volatile const uint32_t RESERVE[22];
N
N    union 
N    {
N        __I uint32_t u32SBUF;
X        volatile const uint32_t u32SBUF;
N        __I uint32_t SBUF;
X        volatile const uint32_t SBUF;
N    };
N} PDMA_T;
N
Ntypedef struct
N{
N    union 
N    {
N        __IO uint32_t u32GCRCSR;
X        volatile uint32_t u32GCRCSR;
N        
N        struct 
N        {
N            __I  uint32_t  RESERVE0:8;
X            volatile const  uint32_t  RESERVE0:8;
N            __IO uint32_t  CLK0_EN:1;
X            volatile uint32_t  CLK0_EN:1;
N            __IO uint32_t  CLK1_EN:1;
X            volatile uint32_t  CLK1_EN:1;
N            __IO uint32_t  CLK2_EN:1;
X            volatile uint32_t  CLK2_EN:1;
N            __IO uint32_t  CLK3_EN:1;
X            volatile uint32_t  CLK3_EN:1;
N            __IO uint32_t  CLK4_EN:1;
X            volatile uint32_t  CLK4_EN:1;
N            __IO uint32_t  CLK5_EN:1;
X            volatile uint32_t  CLK5_EN:1;
N            __IO uint32_t  CLK6_EN:1;
X            volatile uint32_t  CLK6_EN:1;
N            __IO uint32_t  CLK7_EN:1;
X            volatile uint32_t  CLK7_EN:1;
N            __IO uint32_t  CLK8_EN:1;
X            volatile uint32_t  CLK8_EN:1;
N            __I  uint32_t  RESERVE1:15;
X            volatile const  uint32_t  RESERVE1:15;
N        } GCRCSR;
N    };
N
N    union 
N    {
N        __IO uint32_t u32PDSSR0;
X        volatile uint32_t u32PDSSR0;
N        
N        struct 
N        {
N            __IO uint32_t  SPI0_RXSEL:4;
X            volatile uint32_t  SPI0_RXSEL:4;
N            __IO uint32_t  SPI0_TXSEL:4;
X            volatile uint32_t  SPI0_TXSEL:4;
N            __IO uint32_t  SPI1_RXSEL:4;
X            volatile uint32_t  SPI1_RXSEL:4;
N            __IO uint32_t  SPI1_TXSEL:4;
X            volatile uint32_t  SPI1_TXSEL:4;
N            __IO uint32_t  SPI2_RXSEL:4;
X            volatile uint32_t  SPI2_RXSEL:4;
N            __IO uint32_t  SPI2_TXSEL:4;
X            volatile uint32_t  SPI2_TXSEL:4;
N            __IO uint32_t  SPI3_RXSEL:4;
X            volatile uint32_t  SPI3_RXSEL:4;
N            __IO uint32_t  SPI3_TXSEL:4;
X            volatile uint32_t  SPI3_TXSEL:4;
N        } PDSSR0;
N    };
N
N    union 
N    {
N        __IO uint32_t u32PDSSR1;
X        volatile uint32_t u32PDSSR1;
N        
N        struct 
N        {
N            __IO uint32_t  UART0_RXSEL:4;
X            volatile uint32_t  UART0_RXSEL:4;
N            __IO uint32_t  UART0_TXSEL:4;
X            volatile uint32_t  UART0_TXSEL:4;
N            __IO uint32_t  UART1_RXSEL:4;
X            volatile uint32_t  UART1_RXSEL:4;
N            __IO uint32_t  UART1_TXSEL:4;
X            volatile uint32_t  UART1_TXSEL:4;
N            __IO uint32_t  RESERVE0:8;
X            volatile uint32_t  RESERVE0:8;
N            __IO uint32_t  ADC_RXSEL:4;
X            volatile uint32_t  ADC_RXSEL:4;
N            __IO uint32_t  RESERVE1:4;
X            volatile uint32_t  RESERVE1:4;
N        } PDSSR1;
N    };
N
N    union 
N    {
N        __IO uint32_t u32GCRISR;
X        volatile uint32_t u32GCRISR;
N        
N        struct 
N        {
N            __I uint32_t  INTR0:1;
X            volatile const uint32_t  INTR0:1;
N            __I uint32_t  INTR1:1;
X            volatile const uint32_t  INTR1:1;
N            __I uint32_t  INTR2:1;
X            volatile const uint32_t  INTR2:1;
N            __I uint32_t  INTR3:1;
X            volatile const uint32_t  INTR3:1;
N            __I uint32_t  INTR4:1;
X            volatile const uint32_t  INTR4:1;
N            __I uint32_t  INTR5:1;
X            volatile const uint32_t  INTR5:1;
N            __I uint32_t  INTR6:1;
X            volatile const uint32_t  INTR6:1;
N            __I uint32_t  INTR7:1;
X            volatile const uint32_t  INTR7:1;
N            __I uint32_t  INTR8:1;
X            volatile const uint32_t  INTR8:1;
N            __I uint32_t  RESERVE:22;
X            volatile const uint32_t  RESERVE:22;
N            __I uint32_t  INTR:1;
X            volatile const uint32_t  INTR:1;
N        } GCRISR;
N    };
N
N    union 
N    {
N        __IO uint32_t u32PDSSR2;
X        volatile uint32_t u32PDSSR2;
N        
N        struct 
N        {
N            __IO uint32_t  I2S_RXSEL:4;
X            volatile uint32_t  I2S_RXSEL:4;
N            __IO uint32_t  I2S_TXSEL:4;
X            volatile uint32_t  I2S_TXSEL:4;
N            __I  uint32_t  RESERVE:24;
X            volatile const  uint32_t  RESERVE:24;
N        } PDSSR2;
N    };
N} PDMA_GCR_T;
N
N/* PDMA CSR Bit Field Definitions */
N#define PDMA_CSR_PDMACEN_Pos                        0
N#define PDMA_CSR_PDMACEN_Msk                        (1ul << PDMA_CSR_PDMACEN_Pos)
N
N#define PDMA_CSR_SW_RST_Pos                         1
N#define PDMA_CSR_SW_RST_Msk                         (1ul << PDMA_CSR_SW_RST_Pos)
N
N#define PDMA_CSR_MODE_SEL_Pos                       2
N#define PDMA_CSR_MODE_SEL_Msk                       (3ul << PDMA_CSR_MODE_SEL_Pos)
N
N#define PDMA_CSR_SAD_SEL_Pos                        4
N#define PDMA_CSR_SAD_SEL_Msk                        (3ul << PDMA_CSR_SAD_SEL_Pos)
N
N#define PDMA_CSR_DAD_SEL_Pos                        6
N#define PDMA_CSR_DAD_SEL_Msk                        (3ul << PDMA_CSR_DAD_SEL_Pos)
N
N#define PDMA_CSR_APB_TWS_Pos                        19
N#define PDMA_CSR_APB_TWS_Msk                        (3ul << PDMA_CSR_APB_TWS_Pos)
N
N#define PDMA_CSR_TRIG_EN_Pos                        23
N#define PDMA_CSR_TRIG_EN_Msk                        (1ul << PDMA_CSR_TRIG_EN_Pos)
N
N/* PDMA BCR Bit Field Definitions */
N#define PDMA_BCR_BCR_Pos                            0
N#define PDMA_BCR_BCR_Msk                            (0xFFFFul << PDMA_BCR_BCR_Pos)
N
N/* PDMA POINT Bit Field Definitions */
N#define PDMA_POINT_POINT_Pos                        0
N#define PDMA_POINT_POINT_Msk                        (0xFul << PDMA_POINT_POINT_Pos)
N
N/* PDMA CBCR Bit Field Definitions */
N#define PDMA_CBCR_CBCR_Pos                          0
N#define PDMA_CBCR_CBCR_Msk                          (0xFFFFul << PDMA_CBCR_CBCR_Pos)
N
N
N/* PDMA IER Bit Field Definitions */
N#define PDMA_IER_TABORT_IE_Pos                      0
N#define PDMA_IER_TABORT_IE_Msk                      (1ul << PDMA_IER_TABORT_IE_Pos)
N
N#define PDMA_IER_BLKD_IE_Pos                        1
N#define PDMA_IER_BLKD_IE_Msk                        (1ul << PDMA_IER_BLKD_IE_Pos)
N
N/* PDMA ISR Bit Field Definitions */
N#define PDMA_ISR_TABORT_IF_Pos                      0
N#define PDMA_ISR_TABORT_IF_Msk                      (1ul << PDMA_ISR_TABORT_IF_Pos)
N
N#define PDMA_ISR_BLKD_IF_Pos                        1
N#define PDMA_ISR_BLKD_IF_Msk                        (1ul << PDMA_ISR_BLKD_IF_Pos)
N
N/* PDMA GCRCSR Bit Field Definitions */
N#define PDMA_GCRCSR_CLK0_EN_Pos                     8
N#define PDMA_GCRCSR_CLK0_EN_Msk                     (1ul << PDMA_GCRCSR_CLK0_EN_Pos)
N
N#define PDMA_GCRCSR_CLK1_EN_Pos                     9
N#define PDMA_GCRCSR_CLK1_EN_Msk                     (1ul << PDMA_GCRCSR_CLK1_EN_Pos)
N
N#define PDMA_GCRCSR_CLK2_EN_Pos                     10
N#define PDMA_GCRCSR_CLK2_EN_Msk                     (1ul << PDMA_GCRCSR_CLK2_EN_Pos)
N
N#define PDMA_GCRCSR_CLK3_EN_Pos                     11
N#define PDMA_GCRCSR_CLK3_EN_Msk                     (1ul << PDMA_GCRCSR_CLK3_EN_Pos)
N
N#define PDMA_GCRCSR_CLK4_EN_Pos                     12
N#define PDMA_GCRCSR_CLK4_EN_Msk                     (1ul << PDMA_GCRCSR_CLK4_EN_Pos)
N
N#define PDMA_GCRCSR_CLK5_EN_Pos                     13
N#define PDMA_GCRCSR_CLK5_EN_Msk                     (1ul << PDMA_GCRCSR_CLK5_EN_Pos)
N
N#define PDMA_GCRCSR_CLK6_EN_Pos                     14
N#define PDMA_GCRCSR_CLK6_EN_Msk                     (1ul << PDMA_GCRCSR_CLK6_EN_Pos)
N
N#define PDMA_GCRCSR_CLK7_EN_Pos                     15
N#define PDMA_GCRCSR_CLK7_EN_Msk                     (1ul << PDMA_GCRCSR_CLK7_EN_Pos)
N
N#define PDMA_GCRCSR_CLK8_EN_Pos                     16
N#define PDMA_GCRCSR_CLK8_EN_Msk                     (1ul << PDMA_GCRCSR_CLK8_EN_Pos)
N
N/* PDMA PDSSR0 Bit Field Definitions */
N#define PDMA_PDSSR0_SPI0_RXSEL_Pos                  0
N#define PDMA_PDSSR0_SPI0_RXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI0_RXSEL_Pos)
N
N#define PDMA_PDSSR0_SPI0_TXSEL_Pos                  4
N#define PDMA_PDSSR0_SPI0_TXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI0_TXSEL_Pos)
N
N#define PDMA_PDSSR0_SPI1_RXSEL_Pos                  8
N#define PDMA_PDSSR0_SPI1_RXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI1_RXSEL_Pos)
N
N#define PDMA_PDSSR0_SPI1_TXSEL_Pos                  12
N#define PDMA_PDSSR0_SPI1_TXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI1_TXSEL_Pos)
N
N#define PDMA_PDSSR0_SPI2_RXSEL_Pos                  16
N#define PDMA_PDSSR0_SPI2_RXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI2_RXSEL_Pos)
N
N#define PDMA_PDSSR0_SPI2_TXSEL_Pos                  20
N#define PDMA_PDSSR0_SPI2_TXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI2_TXSEL_Pos)
N
N#define PDMA_PDSSR0_SPI3_RXSEL_Pos                  24
N#define PDMA_PDSSR0_SPI3_RXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI3_RXSEL_Pos)
N
N#define PDMA_PDSSR0_SPI3_TXSEL_Pos                  28
N#define PDMA_PDSSR0_SPI3_TXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI3_TXSEL_Pos)
N
N/* PDMA PDSSR1 Bit Field Definitions */
N#define PDMA_PDSSR1_UART0_RXSEL_Pos                 0
N#define PDMA_PDSSR1_UART0_RXSEL_Msk                 (0xFul << PDMA_PDSSR1_UART0_RXSEL_Pos)
N
N#define PDMA_PDSSR1_UART0_TXSEL_Pos                 4
N#define PDMA_PDSSR1_UART0_TXSEL_Msk                 (0xFul << PDMA_PDSSR1_UART0_TXSEL_Pos)
N
N#define PDMA_PDSSR1_UART1_RXSEL_Pos                 8
N#define PDMA_PDSSR1_UART1_RXSEL_Msk                 (0xFul << PDMA_PDSSR1_UART1_RXSEL_Pos)
N
N#define PDMA_PDSSR1_UART1_TXSEL_Pos                 12
N#define PDMA_PDSSR1_UART1_TXSEL_Msk                 (0xFul << PDMA_PDSSR1_UART1_TXSEL_Pos)
N
N#define PDMA_PDSSR1_ADC_RXSEL_Pos                   24
N#define PDMA_PDSSR1_ADC_RXSEL_Msk                   (0xFul << PDMA_PDSSR1_ADC_RXSEL_Pos)
N
N/* PDMA GCRISR Bit Field Definitions */
N#define PDMA_GCRISR_INTR0_Pos                       0
N#define PDMA_GCRISR_INTR0_Msk                       (1ul << PDMA_GCRISR_INTR0_Pos)
N
N#define PDMA_GCRISR_INTR1_Pos                       1
N#define PDMA_GCRISR_INTR1_Msk                       (1ul << PDMA_GCRISR_INTR1_Pos)
N
N#define PDMA_GCRISR_INTR2_Pos                       2
N#define PDMA_GCRISR_INTR2_Msk                       (1ul << PDMA_GCRISR_INTR2_Pos)
N
N#define PDMA_GCRISR_INTR3_Pos                       3
N#define PDMA_GCRISR_INTR3_Msk                       (1ul << PDMA_GCRISR_INTR3_Pos)
N
N#define PDMA_GCRISR_INTR4_Pos                       4
N#define PDMA_GCRISR_INTR4_Msk                       (1ul << PDMA_GCRISR_INTR4_Pos)
N
N#define PDMA_GCRISR_INTR5_Pos                       5
N#define PDMA_GCRISR_INTR5_Msk                       (1ul << PDMA_GCRISR_INTR5_Pos)
N
N#define PDMA_GCRISR_INTR6_Pos                       6
N#define PDMA_GCRISR_INTR6_Msk                       (1ul << PDMA_GCRISR_INTR6_Pos)
N
N#define PDMA_GCRISR_INTR7_Pos                       7
N#define PDMA_GCRISR_INTR7_Msk                       (1ul << PDMA_GCRISR_INTR7_Pos)
N
N#define PDMA_GCRISR_INTR8_Pos                       8
N#define PDMA_GCRISR_INTR8_Msk                       (1ul << PDMA_GCRISR_INTR8_Pos)
N
N#define PDMA_GCRISR_INTR_Pos                        31
N#define PDMA_GCRISR_INTR_Msk                        (1ul << PDMA_GCRISR_INTR_Pos)
N
N/* PDMA PDSSR2 Bit Field Definitions */
N#define PDMA_PDSSR2_I2S_RXSEL_Pos                   0
N#define PDMA_PDSSR2_I2S_RXSEL_Msk                   (0xFul << PDMA_PDSSR2_I2S_RXSEL_Pos)
N
N#define PDMA_PDSSR2_I2S_TXSEL_Pos                   4
N#define PDMA_PDSSR2_I2S_TXSEL_Msk                   (0xFul << PDMA_PDSSR2_I2S_TXSEL_Pos)
N
N/*----------------------------- PWM Controller -------------------------------*/
Ntypedef struct
N{
N    __IO uint32_t  CP01:8;
X    volatile uint32_t  CP01:8;
N    __IO uint32_t  CP23:8;
X    volatile uint32_t  CP23:8;
N    __IO uint32_t  DZI01:8;
X    volatile uint32_t  DZI01:8;
N    __IO uint32_t  DZI23:8;
X    volatile uint32_t  DZI23:8;
N} PWM_PPR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  CSR0:3;
X    volatile uint32_t  CSR0:3;
N    __I  uint32_t  RESERVE0:1;
X    volatile const  uint32_t  RESERVE0:1;
N    __IO uint32_t  CSR1:3;
X    volatile uint32_t  CSR1:3;
N    __I  uint32_t  RESERVE1:1;
X    volatile const  uint32_t  RESERVE1:1;
N    __IO uint32_t  CSR2:3;
X    volatile uint32_t  CSR2:3;
N    __I  uint32_t  RESERVE2:1;
X    volatile const  uint32_t  RESERVE2:1;
N    __IO uint32_t  CSR3:3;
X    volatile uint32_t  CSR3:3;
N    __I  uint32_t  RESERVE3:17;
X    volatile const  uint32_t  RESERVE3:17;
N} PWM_CSR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  CH0EN:1;
X    volatile uint32_t  CH0EN:1;
N    __I  uint32_t  RESERVE0:1;
X    volatile const  uint32_t  RESERVE0:1;
N    __IO uint32_t  CH0INV:1;
X    volatile uint32_t  CH0INV:1;
N    __IO uint32_t  CH0MOD:1;
X    volatile uint32_t  CH0MOD:1;
N    __IO uint32_t  DZEN01:1;
X    volatile uint32_t  DZEN01:1;
N    __IO uint32_t  DZEN23:1;
X    volatile uint32_t  DZEN23:1;
N    __I  uint32_t  RESERVE1:2;
X    volatile const  uint32_t  RESERVE1:2;
N    __IO uint32_t  CH1EN:1;
X    volatile uint32_t  CH1EN:1;
N    __I  uint32_t  RESERVE2:1;
X    volatile const  uint32_t  RESERVE2:1;
N    __IO uint32_t  CH1INV:1;
X    volatile uint32_t  CH1INV:1;
N    __IO uint32_t  CH1MOD:1;
X    volatile uint32_t  CH1MOD:1;
N    __I  uint32_t  RESERVE3:4;
X    volatile const  uint32_t  RESERVE3:4;
N    __IO uint32_t  CH2EN:1;
X    volatile uint32_t  CH2EN:1;
N    __I  uint32_t  RESERVE4:1;
X    volatile const  uint32_t  RESERVE4:1;
N    __IO uint32_t  CH2INV:1;
X    volatile uint32_t  CH2INV:1;
N    __IO uint32_t  CH2MOD:1;
X    volatile uint32_t  CH2MOD:1;
N    __I  uint32_t  RESERVE5:4;
X    volatile const  uint32_t  RESERVE5:4;
N    __IO uint32_t  CH3EN:1;
X    volatile uint32_t  CH3EN:1;
N    __I  uint32_t  RESERVE6:1;
X    volatile const  uint32_t  RESERVE6:1;
N    __IO uint32_t  CH3INV:1;
X    volatile uint32_t  CH3INV:1;
N    __IO uint32_t  CH3MOD:1;
X    volatile uint32_t  CH3MOD:1;
N    __I  uint32_t  RESERVE7:4;   
X    volatile const  uint32_t  RESERVE7:4;   
N} PWM_PCR_T;
N
Ntypedef __IO uint32_t PWM_CNR_T;
Xtypedef volatile uint32_t PWM_CNR_T;
N
Ntypedef __IO uint32_t PWM_CMR_T;
Xtypedef volatile uint32_t PWM_CMR_T;
N
Ntypedef __I  uint32_t PWM_PDR_T;
Xtypedef volatile const  uint32_t PWM_PDR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  BCn:1;
X    volatile uint32_t  BCn:1;
N    __I  uint32_t  RESERVE:31;
X    volatile const  uint32_t  RESERVE:31;
N} PWM_PBCR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  PWMIE0:1;
X    volatile uint32_t  PWMIE0:1;
N    __IO uint32_t  PWMIE1:1;
X    volatile uint32_t  PWMIE1:1;
N    __IO uint32_t  PWMIE2:1;
X    volatile uint32_t  PWMIE2:1;
N    __IO uint32_t  PWMIE3:1;
X    volatile uint32_t  PWMIE3:1;
N    __I  uint32_t  RESERVE:28;
X    volatile const  uint32_t  RESERVE:28;
N} PWM_PIER_T;
N
Ntypedef struct
N{
N    __IO uint32_t  PWMIF0:1;
X    volatile uint32_t  PWMIF0:1;
N    __IO uint32_t  PWMIF1:1;
X    volatile uint32_t  PWMIF1:1;
N    __IO uint32_t  PWMIF2:1;
X    volatile uint32_t  PWMIF2:1;
N    __IO uint32_t  PWMIF3:1;
X    volatile uint32_t  PWMIF3:1;
N    __I  uint32_t  RESERVE:28;
X    volatile const  uint32_t  RESERVE:28;
N} PWM_PIIR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  INV0:1;
X    volatile uint32_t  INV0:1;
N    __IO uint32_t  CRL_IE0:1;
X    volatile uint32_t  CRL_IE0:1;
N    __IO uint32_t  CFL_IE0:1;
X    volatile uint32_t  CFL_IE0:1;
N    __IO uint32_t  CAPCH0EN:1;
X    volatile uint32_t  CAPCH0EN:1;
N    __IO uint32_t  CAPIF0:1;
X    volatile uint32_t  CAPIF0:1;
N    __I  uint32_t  RESERVE0:1;
X    volatile const  uint32_t  RESERVE0:1;
N    __IO uint32_t  CRLRI0:1;
X    volatile uint32_t  CRLRI0:1;
N    __IO uint32_t  CFLRI0:1;
X    volatile uint32_t  CFLRI0:1;
N    __I  uint32_t  RESERVE1:8;
X    volatile const  uint32_t  RESERVE1:8;
N    __IO uint32_t  INV1:1;
X    volatile uint32_t  INV1:1;
N    __IO uint32_t  CRL_IE1:1;
X    volatile uint32_t  CRL_IE1:1;
N    __IO uint32_t  CFL_IE1:1;
X    volatile uint32_t  CFL_IE1:1;
N    __IO uint32_t  CAPCH1EN:1;
X    volatile uint32_t  CAPCH1EN:1;
N    __IO uint32_t  CAPIF1:1;
X    volatile uint32_t  CAPIF1:1;
N    __I  uint32_t  RESERVE2:1;
X    volatile const  uint32_t  RESERVE2:1;
N    __IO uint32_t  CRLRI1:1;
X    volatile uint32_t  CRLRI1:1;
N    __IO uint32_t  CFLRI1:1;
X    volatile uint32_t  CFLRI1:1;
N    __I  uint32_t  RESERVE3:8;
X    volatile const  uint32_t  RESERVE3:8;
N} PWM_CCR0_T;
N
Ntypedef struct
N{
N    __IO uint32_t  INV2:1;
X    volatile uint32_t  INV2:1;
N    __IO uint32_t  CRL_IE2:1;
X    volatile uint32_t  CRL_IE2:1;
N    __IO uint32_t  CFL_IE2:1;
X    volatile uint32_t  CFL_IE2:1;
N    __IO uint32_t  CAPCH2EN:1;
X    volatile uint32_t  CAPCH2EN:1;
N    __IO uint32_t  CAPIF2:1;
X    volatile uint32_t  CAPIF2:1;
N    __I  uint32_t  RESERVE0:1;
X    volatile const  uint32_t  RESERVE0:1;
N    __IO uint32_t  CRLRI2:1;
X    volatile uint32_t  CRLRI2:1;
N    __IO uint32_t  CFLRI2:1;
X    volatile uint32_t  CFLRI2:1;
N    __I  uint32_t  RESERVE1:8;
X    volatile const  uint32_t  RESERVE1:8;
N    __IO uint32_t  INV3:1;
X    volatile uint32_t  INV3:1;
N    __IO uint32_t  CRL_IE3:1;
X    volatile uint32_t  CRL_IE3:1;
N    __IO uint32_t  CFL_IE3:1;
X    volatile uint32_t  CFL_IE3:1;
N    __IO uint32_t  CAPCH3EN:1;
X    volatile uint32_t  CAPCH3EN:1;
N    __IO uint32_t  CAPIF3:1;
X    volatile uint32_t  CAPIF3:1;
N    __I  uint32_t  RESERVE2:1;
X    volatile const  uint32_t  RESERVE2:1;
N    __IO uint32_t  CRLRI3:1;
X    volatile uint32_t  CRLRI3:1;
N    __IO uint32_t  CFLRI3:1;
X    volatile uint32_t  CFLRI3:1;
N    __I  uint32_t  RESERVE3:8;
X    volatile const  uint32_t  RESERVE3:8;
N} PWM_CCR2_T;
N
Ntypedef __IO uint32_t PWM_CRLR_T;
Xtypedef volatile uint32_t PWM_CRLR_T;
N
Ntypedef __IO uint32_t PWM_CFLR_T;
Xtypedef volatile uint32_t PWM_CFLR_T;
N
Ntypedef __IO uint32_t PWM_CAPENR_T;
Xtypedef volatile uint32_t PWM_CAPENR_T;
N
Ntypedef struct
N{
N    __IO uint32_t  PWM0:1;
X    volatile uint32_t  PWM0:1;
N    __IO uint32_t  PWM1:1;
X    volatile uint32_t  PWM1:1;
N    __IO uint32_t  PWM2:1;
X    volatile uint32_t  PWM2:1;
N    __IO uint32_t  PWM3:1;
X    volatile uint32_t  PWM3:1;
N    __I  uint32_t  RESERVE:28;
X    volatile const  uint32_t  RESERVE:28;
N} PWM_POE_T;
N
Ntypedef struct
N{
N    union 
N    {
N        __IO uint32_t u32PPR;
X        volatile uint32_t u32PPR;
N        
N        struct 
N        {
N            __IO uint32_t  CP01:8;
X            volatile uint32_t  CP01:8;
N            __IO uint32_t  CP23:8;
X            volatile uint32_t  CP23:8;
N            __IO uint32_t  DZI01:8;
X            volatile uint32_t  DZI01:8;
N            __IO uint32_t  DZI23:8;
X            volatile uint32_t  DZI23:8;
N        } PPR;
N    };
N    
N    union 
N    {
N        __IO uint32_t u32CSR;
X        volatile uint32_t u32CSR;
N        
N        struct 
N        {
N            __IO uint32_t  CSR0:3;
X            volatile uint32_t  CSR0:3;
N            __I  uint32_t  RESERVE0:1;
X            volatile const  uint32_t  RESERVE0:1;
N            __IO uint32_t  CSR1:3;
X            volatile uint32_t  CSR1:3;
N            __I  uint32_t  RESERVE1:1;
X            volatile const  uint32_t  RESERVE1:1;
N            __IO uint32_t  CSR2:3;
X            volatile uint32_t  CSR2:3;
N            __I  uint32_t  RESERVE2:1;
X            volatile const  uint32_t  RESERVE2:1;
N            __IO uint32_t  CSR3:3;
X            volatile uint32_t  CSR3:3;
N            __I  uint32_t  RESERVE3:17;
X            volatile const  uint32_t  RESERVE3:17;
N        } CSR;
N    };
N
N    union 
N    {
N        __IO uint32_t u32PCR;
X        volatile uint32_t u32PCR;
N        
N        struct 
N        {
N            __IO uint32_t  CH0EN:1;
X            volatile uint32_t  CH0EN:1;
N            __I  uint32_t  RESERVE0:1;
X            volatile const  uint32_t  RESERVE0:1;
N            __IO uint32_t  CH0INV:1;
X            volatile uint32_t  CH0INV:1;
N            __IO uint32_t  CH0MOD:1;
X            volatile uint32_t  CH0MOD:1;
N            __IO uint32_t  DZEN01:1;
X            volatile uint32_t  DZEN01:1;
N            __IO uint32_t  DZEN23:1;
X            volatile uint32_t  DZEN23:1;
N            __I  uint32_t  RESERVE1:2;
X            volatile const  uint32_t  RESERVE1:2;
N            __IO uint32_t  CH1EN:1;
X            volatile uint32_t  CH1EN:1;
N            __I  uint32_t  RESERVE2:1;
X            volatile const  uint32_t  RESERVE2:1;
N            __IO uint32_t  CH1INV:1;
X            volatile uint32_t  CH1INV:1;
N            __IO uint32_t  CH1MOD:1;
X            volatile uint32_t  CH1MOD:1;
N            __I  uint32_t  RESERVE3:4;
X            volatile const  uint32_t  RESERVE3:4;
N            __IO uint32_t  CH2EN:1;
X            volatile uint32_t  CH2EN:1;
N            __I  uint32_t  RESERVE4:1;
X            volatile const  uint32_t  RESERVE4:1;
N            __IO uint32_t  CH2INV:1;
X            volatile uint32_t  CH2INV:1;
N            __IO uint32_t  CH2MOD:1;
X            volatile uint32_t  CH2MOD:1;
N            __I  uint32_t  RESERVE5:4;
X            volatile const  uint32_t  RESERVE5:4;
N            __IO uint32_t  CH3EN:1;
X            volatile uint32_t  CH3EN:1;
N            __I  uint32_t  RESERVE6:1;
X            volatile const  uint32_t  RESERVE6:1;
N            __IO uint32_t  CH3INV:1;
X            volatile uint32_t  CH3INV:1;
N            __IO uint32_t  CH3MOD:1;
X            volatile uint32_t  CH3MOD:1;
N            __I  uint32_t  RESERVE7:4;   
X            volatile const  uint32_t  RESERVE7:4;   
N        } PCR;
N    };
N
N    union 
N    {
N        __IO uint32_t u32CNR0;
X        volatile uint32_t u32CNR0;
N        __IO uint32_t CNR0;
X        volatile uint32_t CNR0;
N    };
N
N    union 
N    {
N        __IO uint32_t u32CMR0;
X        volatile uint32_t u32CMR0;
N        __IO uint32_t CMR0;
X        volatile uint32_t CMR0;
N    };
N
N    union 
N    {
N        __I  uint32_t u32PDR0;
X        volatile const  uint32_t u32PDR0;
N        __I  uint32_t PDR0;
X        volatile const  uint32_t PDR0;
N    };
N    
N    union 
N    {
N        __IO uint32_t u32CNR1;
X        volatile uint32_t u32CNR1;
N        __IO uint32_t CNR1;
X        volatile uint32_t CNR1;
N    };
N
N    union 
N    {
N        __IO uint32_t u32CMR1;
X        volatile uint32_t u32CMR1;
N        __IO uint32_t CMR1;
X        volatile uint32_t CMR1;
N    };
N
N    union 
N    {
N        __I  uint32_t u32PDR1;
X        volatile const  uint32_t u32PDR1;
N        __I  uint32_t PDR1;
X        volatile const  uint32_t PDR1;
N    };
N
N    union 
N    {
N        __IO uint32_t u32CNR2;
X        volatile uint32_t u32CNR2;
N        __IO uint32_t CNR2;
X        volatile uint32_t CNR2;
N    };
N
N    union 
N    {
N        __IO uint32_t u32CMR2;
X        volatile uint32_t u32CMR2;
N        __IO uint32_t CMR2;
X        volatile uint32_t CMR2;
N    };
N
N    union 
N    {
N        __I  uint32_t u32PDR2;
X        volatile const  uint32_t u32PDR2;
N        __I  uint32_t PDR2;
X        volatile const  uint32_t PDR2;
N    };
N
N    union 
N    {
N        __IO uint32_t u32CNR3;
X        volatile uint32_t u32CNR3;
N        __IO uint32_t CNR3;
X        volatile uint32_t CNR3;
N    };
N
N    union 
N    {
N        __IO uint32_t u32CMR3;
X        volatile uint32_t u32CMR3;
N        __IO uint32_t CMR3;
X        volatile uint32_t CMR3;
N    };
N
N    union 
N    {
N        __I  uint32_t u32PDR3;
X        volatile const  uint32_t u32PDR3;
N        __I  uint32_t PDR3;
X        volatile const  uint32_t PDR3;
N    };
N
N    union 
N    {
N        __IO uint32_t u32PBCR;
X        volatile uint32_t u32PBCR;
N        
N        struct 
N        {
N            __IO uint32_t  BCn:1;
X            volatile uint32_t  BCn:1;
N            __I  uint32_t  RESERVE:31;
X            volatile const  uint32_t  RESERVE:31;
N        } PBCR;
N    };
N
N    union 
N    {
N        __IO uint32_t u32PIER;
X        volatile uint32_t u32PIER;
N        
N        struct 
N        {
N            __IO uint32_t  PWMIE0:1;
X            volatile uint32_t  PWMIE0:1;
N            __IO uint32_t  PWMIE1:1;
X            volatile uint32_t  PWMIE1:1;
N            __IO uint32_t  PWMIE2:1;
X            volatile uint32_t  PWMIE2:1;
N            __IO uint32_t  PWMIE3:1;
X            volatile uint32_t  PWMIE3:1;
N            __I  uint32_t  RESERVE:28;
X            volatile const  uint32_t  RESERVE:28;
N        } PIER;
N    };
N    
N    union 
N    {
N        __IO uint32_t u32PIIR;
X        volatile uint32_t u32PIIR;
N        
N        struct 
N        {
N            __IO uint32_t  PWMIF0:1;
X            volatile uint32_t  PWMIF0:1;
N            __IO uint32_t  PWMIF1:1;
X            volatile uint32_t  PWMIF1:1;
N            __IO uint32_t  PWMIF2:1;
X            volatile uint32_t  PWMIF2:1;
N            __IO uint32_t  PWMIF3:1;
X            volatile uint32_t  PWMIF3:1;
N            __I  uint32_t  RESERVE:28;
X            volatile const  uint32_t  RESERVE:28;
N        } PIIR;
N    };    
N    
N    uint32_t    RESERVE1[2];
N
N    union 
N    {
N        __IO uint32_t u32CCR0;
X        volatile uint32_t u32CCR0;
N        
N        struct 
N        {
N            __IO uint32_t  INV0:1;
X            volatile uint32_t  INV0:1;
N            __IO uint32_t  CRL_IE0:1;
X            volatile uint32_t  CRL_IE0:1;
N            __IO uint32_t  CFL_IE0:1;
X            volatile uint32_t  CFL_IE0:1;
N            __IO uint32_t  CAPCH0EN:1;
X            volatile uint32_t  CAPCH0EN:1;
N            __IO uint32_t  CAPIF0:1;
X            volatile uint32_t  CAPIF0:1;
N            __I  uint32_t  RESERVE0:1;
X            volatile const  uint32_t  RESERVE0:1;
N            __IO uint32_t  CRLRI0:1;
X            volatile uint32_t  CRLRI0:1;
N            __IO uint32_t  CFLRI0:1;
X            volatile uint32_t  CFLRI0:1;
N            __I  uint32_t  RESERVE1:8;
X            volatile const  uint32_t  RESERVE1:8;
N            __IO uint32_t  INV1:1;
X            volatile uint32_t  INV1:1;
N            __IO uint32_t  CRL_IE1:1;
X            volatile uint32_t  CRL_IE1:1;
N            __IO uint32_t  CFL_IE1:1;
X            volatile uint32_t  CFL_IE1:1;
N            __IO uint32_t  CAPCH1EN:1;
X            volatile uint32_t  CAPCH1EN:1;
N            __IO uint32_t  CAPIF1:1;
X            volatile uint32_t  CAPIF1:1;
N            __I  uint32_t  RESERVE2:1;
X            volatile const  uint32_t  RESERVE2:1;
N            __IO uint32_t  CRLRI1:1;
X            volatile uint32_t  CRLRI1:1;
N            __IO uint32_t  CFLRI1:1;
X            volatile uint32_t  CFLRI1:1;
N            __I  uint32_t  RESERVE3:8;
X            volatile const  uint32_t  RESERVE3:8;
N        } CCR0;
N    };
N    
N    union 
N    {
N        __IO uint32_t u32CCR2;
X        volatile uint32_t u32CCR2;
N        
N        struct 
N        {
N            __IO uint32_t  INV2:1;
X            volatile uint32_t  INV2:1;
N            __IO uint32_t  CRL_IE2:1;
X            volatile uint32_t  CRL_IE2:1;
N            __IO uint32_t  CFL_IE2:1;
X            volatile uint32_t  CFL_IE2:1;
N            __IO uint32_t  CAPCH2EN:1;
X            volatile uint32_t  CAPCH2EN:1;
N            __IO uint32_t  CAPIF2:1;
X            volatile uint32_t  CAPIF2:1;
N            __I  uint32_t  RESERVE0:1;
X            volatile const  uint32_t  RESERVE0:1;
N            __IO uint32_t  CRLRI2:1;
X            volatile uint32_t  CRLRI2:1;
N            __IO uint32_t  CFLRI2:1;
X            volatile uint32_t  CFLRI2:1;
N            __I  uint32_t  RESERVE1:8;
X            volatile const  uint32_t  RESERVE1:8;
N            __IO uint32_t  INV3:1;
X            volatile uint32_t  INV3:1;
N            __IO uint32_t  CRL_IE3:1;
X            volatile uint32_t  CRL_IE3:1;
N            __IO uint32_t  CFL_IE3:1;
X            volatile uint32_t  CFL_IE3:1;
N            __IO uint32_t  CAPCH3EN:1;
X            volatile uint32_t  CAPCH3EN:1;
N            __IO uint32_t  CAPIF3:1;
X            volatile uint32_t  CAPIF3:1;
N            __I  uint32_t  RESERVE2:1;
X            volatile const  uint32_t  RESERVE2:1;
N            __IO uint32_t  CRLRI3:1;
X            volatile uint32_t  CRLRI3:1;
N            __IO uint32_t  CFLRI3:1;
X            volatile uint32_t  CFLRI3:1;
N            __I  uint32_t  RESERVE3:8;
X            volatile const  uint32_t  RESERVE3:8;
N        } CCR2;
N    };    
N
N    union 
N    {
N        __IO uint32_t u32CRLR0;
X        volatile uint32_t u32CRLR0;
N        __IO uint32_t CRLR0;
X        volatile uint32_t CRLR0;
N    };
N
N    union 
N    {
N        __IO uint32_t u32CFLR0;
X        volatile uint32_t u32CFLR0;
N        __IO uint32_t CFLR0;
X        volatile uint32_t CFLR0;
N    };
N
N    union 
N    {
N        __IO uint32_t u32CRLR1;
X        volatile uint32_t u32CRLR1;
N        __IO uint32_t CRLR1;
X        volatile uint32_t CRLR1;
N    };
N
N    union 
N    {
N        __IO uint32_t u32CFLR1;
X        volatile uint32_t u32CFLR1;
N        __IO uint32_t CFLR1;
X        volatile uint32_t CFLR1;
N    };
N
N    union 
N    {
N        __IO uint32_t u32CRLR2;
X        volatile uint32_t u32CRLR2;
N        __IO uint32_t CRLR2;
X        volatile uint32_t CRLR2;
N    };
N
N    union 
N    {
N        __IO uint32_t u32CFLR2;
X        volatile uint32_t u32CFLR2;
N        __IO uint32_t CFLR2;
X        volatile uint32_t CFLR2;
N    };
N    
N    union 
N    {
N        __IO uint32_t u32CRLR3;
X        volatile uint32_t u32CRLR3;
N        __IO uint32_t CRLR3;
X        volatile uint32_t CRLR3;
N    };
N
N    union 
N    {
N        __IO uint32_t u32CFLR3;
X        volatile uint32_t u32CFLR3;
N        __IO uint32_t CFLR3;
X        volatile uint32_t CFLR3;
N    };    
N
N    union 
N    {
N        __IO uint32_t u32CAPENR;
X        volatile uint32_t u32CAPENR;
N        __IO uint32_t CAPENR;
X        volatile uint32_t CAPENR;
N    };
N
N    union 
N    {
N        __IO uint32_t u32POE;
X        volatile uint32_t u32POE;
N        
N        struct 
N        {
N            __IO uint32_t  PWM0:1;
X            volatile uint32_t  PWM0:1;
N            __IO uint32_t  PWM1:1;
X            volatile uint32_t  PWM1:1;
N            __IO uint32_t  PWM2:1;
X            volatile uint32_t  PWM2:1;
N            __IO uint32_t  PWM3:1;
X            volatile uint32_t  PWM3:1;
N            __I  uint32_t  RESERVE:28;
X            volatile const  uint32_t  RESERVE:28;
N        } POE;
N    }; 
N} PWM_T;
N
N/* PWM PPR Bit Field Definitions */
N#define PWM_PPR_DZI23_Pos                       24
N#define PWM_PPR_DZI23_Msk                       (0xFFul << PWM_PPR_DZI23_Pos)
N
N#define PWM_PPR_DZI01_Pos                       16
N#define PWM_PPR_DZI01_Msk                       (0xFFul << PWM_PPR_DZI01_Pos)
N
N#define PWM_PPR_CP23_Pos                        8
N#define PWM_PPR_CP23_Msk                        (0xFFul << PWM_PPR_CP23_Pos)
N
N#define PWM_PPR_CP01_Pos                        0
N#define PWM_PPR_CP01_Msk                        (0xFFul << PWM_PPR_CP01_Pos)
N
N/* PWM CSR Bit Field Definitions */
N#define PWM_CSR_CSR3_Pos                        12
N#define PWM_CSR_CSR3_Msk                        (7ul << PWM_CSR_CSR3_Pos)
N
N#define PWM_CSR_CSR2_Pos                        8
N#define PWM_CSR_CSR2_Msk                        (7ul << PWM_CSR_CSR2_Pos)
N
N#define PWM_CSR_CSR1_Pos                        4
N#define PWM_CSR_CSR1_Msk                        (7ul << PWM_CSR_CSR1_Pos)
N
N#define PWM_CSR_CSR0_Pos                        0
N#define PWM_CSR_CSR0_Msk                        (7ul << PWM_CSR_CSR0_Pos)
N
N/* PWM PCR Bit Field Definitions */
N#define PWM_PCR_CH3MOD_Pos                      27
N#define PWM_PCR_CH3MOD_Msk                      (1ul << PWM_PCR_CH3MOD_Pos)
N
N#define PWM_PCR_CH3INV_Pos                      26
N#define PWM_PCR_CH3INV_Msk                      (1ul << PWM_PCR_CH3INV_Pos)
N
N#define PWM_PCR_CH3EN_Pos                       24
N#define PWM_PCR_CH3EN_Msk                       (1ul << PWM_PCR_CH3EN_Pos)
N
N#define PWM_PCR_CH2MOD_Pos                      19
N#define PWM_PCR_CH2MOD_Msk                      (1ul << PWM_PCR_CH2MOD_Pos)
N
N#define PWM_PCR_CH2INV_Pos                      18
N#define PWM_PCR_CH2INV_Msk                      (1ul << PWM_PCR_CH2INV_Pos)
N
N#define PWM_PCR_CH2EN_Pos                       16
N#define PWM_PCR_CH2EN_Msk                       (1ul << PWM_PCR_CH2EN_Pos)
N
N#define PWM_PCR_CH1MOD_Pos                      11
N#define PWM_PCR_CH1MOD_Msk                      (1ul << PWM_PCR_CH1MOD_Pos)
N
N#define PWM_PCR_CH1INV_Pos                      10
N#define PWM_PCR_CH1INV_Msk                      (1ul << PWM_PCR_CH1INV_Pos)
N
N#define PWM_PCR_CH1EN_Pos                       8
N#define PWM_PCR_CH1EN_Msk                       (1ul << PWM_PCR_CH1EN_Pos)
N
N#define PWM_PCR_DZEN23_Pos                      5
N#define PWM_PCR_DZEN23_Msk                      (1ul << PWM_PCR_DZEN23_Pos)
N
N#define PWM_PCR_DZEN01_Pos                      4
N#define PWM_PCR_DZEN01_Msk                      (1ul << PWM_PCR_DZEN01_Pos)
N
N#define PWM_PCR_CH0MOD_Pos                      3
N#define PWM_PCR_CH0MOD_Msk                      (1ul << PWM_PCR_CH0MOD_Pos)
N
N#define PWM_PCR_CH0INV_Pos                      2
N#define PWM_PCR_CH0INV_Msk                      (1ul << PWM_PCR_CH0INV_Pos)
N
N#define PWM_PCR_CH0EN_Pos                       0
N#define PWM_PCR_CH0EN_Msk                       (1ul << PWM_PCR_CH0EN_Pos)
N
N/* PWM CNR Bit Field Definitions */
N#define PWM_CNR_CNR_Pos                         0
N#define PWM_CNR_CNR_Msk                         (0xFFFFul << PWM_CNR_CNR_Pos)
N
N/* PWM CMR Bit Field Definitions */
N#define PWM_CMR_CMR_Pos                         0
N#define PWM_CMR_CMR_Msk                         (0xFFFFul << PWM_CMR_CMR_Pos)
N
N/* PWM PDR Bit Field Definitions */
N#define PWM_PDR_PDR_Pos                         0
N#define PWM_PDR_PDR_Msk                         (0xFFFFul << PWM_PDR_PDR_Pos)
N
N/* PWM PBCR Bit Field Definitions */
N#define PWM_PBCR_BCn_Pos                        0
N#define PWM_PBCR_BCn_Msk                        (1ul << PWM_PBCR_BCn_Pos)
N
N/* PWM PIER Bit Field Definitions */
N#define PWM_PIER_PWMIE3_Pos                     3
N#define PWM_PIER_PWMIE3_Msk                     (1ul << PWM_PIER_PWMIE3_Pos)
N
N#define PWM_PIER_PWMIE2_Pos                     2
N#define PWM_PIER_PWMIE2_Msk                     (1ul << PWM_PIER_PWMIE2_Pos)
N
N#define PWM_PIER_PWMIE1_Pos                     1
N#define PWM_PIER_PWMIE1_Msk                     (1ul << PWM_PIER_PWMIE1_Pos)
N
N#define PWM_PIER_PWMIE0_Pos                     0
N#define PWM_PIER_PWMIE0_Msk                     (1ul << PWM_PIER_PWMIE0_Pos)
N
N/* PWM PIIR Bit Field Definitions */
N#define PWM_PIIR_PWMIF3_Pos                     3
N#define PWM_PIIR_PWMIF3_Msk                     (1ul << PWM_PIIR_PWMIF3_Pos)
N
N#define PWM_PIIR_PWMIF2_Pos                     2
N#define PWM_PIIR_PWMIF2_Msk                     (1ul << PWM_PIIR_PWMIF2_Pos)
N
N#define PWM_PIIR_PWMIF1_Pos                     1
N#define PWM_PIIR_PWMIF1_Msk                     (1ul << PWM_PIIR_PWMIF1_Pos)
N
N#define PWM_PIIR_PWMIF0_Pos                     0
N#define PWM_PIIR_PWMIF0_Msk                     (1ul << PWM_PIIR_PWMIF0_Pos)
N
N/* PWM CCR0 Bit Field Definitions */
N#define PWM_CCR0_CFLRI1_Pos                     23
N#define PWM_CCR0_CFLRI1_Msk                     (1ul << PWM_CCR0_CFLRI1_Pos)
N
N#define PWM_CCR0_CRLRI1_Pos                     22
N#define PWM_CCR0_CRLRI1_Msk                     (1ul << PWM_CCR0_CRLRI1_Pos)
N
N#define PWM_CCR0_CAPIF1_Pos                     20
N#define PWM_CCR0_CAPIF1_Msk                     (1ul << PWM_CCR0_CAPIF1_Pos)
N
N#define PWM_CCR0_CAPCH1EN_Pos                   19
N#define PWM_CCR0_CAPCH1EN_Msk                   (1ul << PWM_CCR0_CAPCH1EN_Pos)
N
N#define PWM_CCR0_CFL_IE1_Pos                    18
N#define PWM_CCR0_CFL_IE1_Msk                    (1ul << PWM_CCR0_CFL_IE1_Pos)
N
N#define PWM_CCR0_CRL_IE1_Pos                    17
N#define PWM_CCR0_CRL_IE1_Msk                    (1ul << PWM_CCR0_CRL_IE1_Pos)
N
N#define PWM_CCR0_INV1_Pos                       16
N#define PWM_CCR0_INV1_Msk                       (1ul << PWM_CCR0_INV1_Pos)
N
N#define PWM_CCR0_CFLRI0_Pos                     7
N#define PWM_CCR0_CFLRI0_Msk                     (1ul << PWM_CCR0_CFLRI0_Pos)
N
N#define PWM_CCR0_CRLRI0_Pos                     6
N#define PWM_CCR0_CRLRI0_Msk                     (1ul << PWM_CCR0_CRLRI0_Pos)
N
N#define PWM_CCR0_CAPIF0_Pos                     4
N#define PWM_CCR0_CAPIF0_Msk                     (1ul << PWM_CCR0_CAPIF0_Pos)
N
N#define PWM_CCR0_CAPCH0EN_Pos                   3
N#define PWM_CCR0_CAPCH0EN_Msk                   (1ul << PWM_CCR0_CAPCH0EN_Pos)
N
N#define PWM_CCR0_CFL_IE0_Pos                    2
N#define PWM_CCR0_CFL_IE0_Msk                    (1ul << PWM_CCR0_CFL_IE0_Pos)
N
N#define PWM_CCR0_CRL_IE0_Pos                    1
N#define PWM_CCR0_CRL_IE0_Msk                    (1ul << PWM_CCR0_CRL_IE0_Pos)
N
N#define PWM_CCR0_INV0_Pos                       0
N#define PWM_CCR0_INV0_Msk                       (1ul << PWM_CCR0_INV0_Pos)
N
N/* PWM CCR2 Bit Field Definitions */
N#define PWM_CCR2_CFLRI3_Pos                     23
N#define PWM_CCR2_CFLRI3_Msk                     (1ul << PWM_CCR2_CFLRI3_Pos)
N
N#define PWM_CCR2_CRLRI3_Pos                     22
N#define PWM_CCR2_CRLRI3_Msk                     (1ul << PWM_CCR2_CRLRI3_Pos)
N
N#define PWM_CCR2_CAPIF3_Pos                     20
N#define PWM_CCR2_CAPIF3_Msk                     (1ul << PWM_CCR2_CAPIF3_Pos)
N
N#define PWM_CCR2_CAPCH3EN_Pos                   19
N#define PWM_CCR2_CAPCH3EN_Msk                   (1ul << PWM_CCR2_CAPCH3EN_Pos)
N
N#define PWM_CCR2_CFL_IE3_Pos                    18
N#define PWM_CCR2_CFL_IE3_Msk                    (1ul << PWM_CCR2_CFL_IE3_Pos)
N
N#define PWM_CCR2_CRL_IE3_Pos                    17
N#define PWM_CCR2_CRL_IE3_Msk                    (1ul << PWM_CCR2_CRL_IE3_Pos)
N
N#define PWM_CCR2_INV3_Pos                       16
N#define PWM_CCR2_INV3_Msk                       (1ul << PWM_CCR2_INV3_Pos)
N
N#define PWM_CCR2_CFLRI2_Pos                     7
N#define PWM_CCR2_CFLRI2_Msk                     (1ul << PWM_CCR2_CFLRI2_Pos)
N
N#define PWM_CCR2_CRLRI2_Pos                     6
N#define PWM_CCR2_CRLRI2_Msk                     (1ul << PWM_CCR2_CRLRI2_Pos)
N
N#define PWM_CCR2_CAPIF2_Pos                     4
N#define PWM_CCR2_CAPIF2_Msk                     (1ul << PWM_CCR2_CAPIF2_Pos)
N
N#define PWM_CCR2_CAPCH2EN_Pos                   3
N#define PWM_CCR2_CAPCH2EN_Msk                   (1ul << PWM_CCR2_CAPCH2EN_Pos)
N
N#define PWM_CCR2_CFL_IE2_Pos                    2
N#define PWM_CCR2_CFL_IE2_Msk                    (1ul << PWM_CCR2_CFL_IE2_Pos)
N
N#define PWM_CCR2_CRL_IE2_Pos                    1
N#define PWM_CCR2_CRL_IE2_Msk                    (1ul << PWM_CCR2_CRL_IE2_Pos)
N
N#define PWM_CCR2_INV2_Pos                       0
N#define PWM_CCR2_INV2_Msk                       (1ul << PWM_CCR2_INV2_Pos)
N
N/* PWM CRLR Bit Field Definitions */
N#define PWM_CRLR_CRLR_Pos                       0
N#define PWM_CRLR_CRLR_Msk                       (0xFFFFul << PWM_CRLR_CRLR_Pos)
N
N/* PWM CFLR Bit Field Definitions */
N#define PWM_CFLR_CFLR_Pos                       0
N#define PWM_CFLR_CFLR_Msk                       (0xFFFFul << PWM_CFLR_CFLR_Pos)
N
N/* PWM CAPENR Bit Field Definitions */
N#define PWM_CAPENR_CAPENR_Pos                   0
N#define PWM_CAPENR_CAPENR_Msk                   (0xFul << PWM_CAPENR_CAPENR_Pos)
N
N/* PWM POE Bit Field Definitions */
N#define PWM_POE_PWM3_Pos                        3
N#define PWM_POE_PWM3_Msk                        (1ul << PWM_POE_PWM3_Pos)
N
N#define PWM_POE_PWM2_Pos                        2
N#define PWM_POE_PWM2_Msk                        (1ul << PWM_POE_PWM2_Pos)
N
N#define PWM_POE_PWM1_Pos                        1
N#define PWM_POE_PWM1_Msk                        (1ul << PWM_POE_PWM1_Pos)
N
N#define PWM_POE_PWM0_Pos                        0
N#define PWM_POE_PWM0_Msk                        (1ul << PWM_POE_PWM0_Pos)
N
N/*----------------------------- I2S Controller -------------------------------*/
N
Ntypedef struct
N{
N    __IO uint32_t  I2SEN:1;
X    volatile uint32_t  I2SEN:1;
N    __IO uint32_t  TXEN:1;
X    volatile uint32_t  TXEN:1;
N    __IO uint32_t  RXEN:1;
X    volatile uint32_t  RXEN:1;
N    __IO uint32_t  MUTE:1;
X    volatile uint32_t  MUTE:1;
N    __IO uint32_t  WORDWIDTH:2;
X    volatile uint32_t  WORDWIDTH:2;
N    __IO uint32_t  MONO:1;
X    volatile uint32_t  MONO:1;
N    __IO uint32_t  FORMAT:1;
X    volatile uint32_t  FORMAT:1;
N    __IO uint32_t  SLAVE:1;
X    volatile uint32_t  SLAVE:1;
N    __IO uint32_t  TXTH:3;
X    volatile uint32_t  TXTH:3;
N    __IO uint32_t  RXTH:3;
X    volatile uint32_t  RXTH:3;
N    __IO uint32_t  MCLKEN:1;
X    volatile uint32_t  MCLKEN:1;
N    __IO uint32_t  RCHZCEN:1;
X    volatile uint32_t  RCHZCEN:1;
N    __IO uint32_t  LCHZCEN:1;
X    volatile uint32_t  LCHZCEN:1;
N    __IO uint32_t  CLR_TXFIFO:1;
X    volatile uint32_t  CLR_TXFIFO:1;
N    __IO uint32_t  CLR_RXFIFO:1;
X    volatile uint32_t  CLR_RXFIFO:1;
N    __IO uint32_t  TXDMA:1;
X    volatile uint32_t  TXDMA:1;
N    __IO uint32_t  RXDMA:1; 
X    volatile uint32_t  RXDMA:1; 
N    __I  uint32_t  RESERVE:10;
X    volatile const  uint32_t  RESERVE:10;
N} I2S_I2SCON_T;
N
Ntypedef struct
N{
N    __IO uint32_t  MCLK_DIV:3;
X    volatile uint32_t  MCLK_DIV:3;
N    __I  uint32_t  RESERVE0:5;
X    volatile const  uint32_t  RESERVE0:5;
N    __IO uint32_t  BCLK_DIV:8;
X    volatile uint32_t  BCLK_DIV:8;
N    __I  uint32_t  RESERVE1:16;
X    volatile const  uint32_t  RESERVE1:16;
N} I2S_I2SCLKDIV_T;
N
Ntypedef struct
N{
N    __IO uint32_t  RXUDFIE:1;
X    volatile uint32_t  RXUDFIE:1;
N    __IO uint32_t  RXOVFIE:1;
X    volatile uint32_t  RXOVFIE:1;
N    __IO uint32_t  RXTHIE:1;
X    volatile uint32_t  RXTHIE:1;
N    __I  uint32_t  RESERVE0:5;
X    volatile const  uint32_t  RESERVE0:5;
N    __IO uint32_t  TXUDFIE:1;
X    volatile uint32_t  TXUDFIE:1;
N    __IO uint32_t  TXOVFIE:1;
X    volatile uint32_t  TXOVFIE:1;
N    __IO uint32_t  TXTHIE:1;
X    volatile uint32_t  TXTHIE:1;
N    __IO uint32_t  RZCIE:1;
X    volatile uint32_t  RZCIE:1;
N    __IO uint32_t  LZCIE:1;
X    volatile uint32_t  LZCIE:1;
N    __I  uint32_t  RESERVE1:19;
X    volatile const  uint32_t  RESERVE1:19;
N} I2S_I2SIE_T;
N
Ntypedef struct
N{
N    __I  uint32_t  I2SINT:1;
X    volatile const  uint32_t  I2SINT:1;
N    __I  uint32_t  I2SRXINT:1;
X    volatile const  uint32_t  I2SRXINT:1;
N    __I  uint32_t  I2STXINT:1;
X    volatile const  uint32_t  I2STXINT:1;
N    __I  uint32_t  RIGHT:1;
X    volatile const  uint32_t  RIGHT:1;
N    __I  uint32_t  RESERVE0:4;
X    volatile const  uint32_t  RESERVE0:4;
N    __IO uint32_t  RXUDF:1;
X    volatile uint32_t  RXUDF:1;
N    __IO uint32_t  RXOVF:1;
X    volatile uint32_t  RXOVF:1;
N    __I  uint32_t  RXTHF:1;
X    volatile const  uint32_t  RXTHF:1;
N    __I  uint32_t  RXFULL:1;
X    volatile const  uint32_t  RXFULL:1;
N    __I  uint32_t  RXEMPTY:1;
X    volatile const  uint32_t  RXEMPTY:1;
N    __I  uint32_t  RESERVE1:3;
X    volatile const  uint32_t  RESERVE1:3;
N    __IO uint32_t  TXUDF:1;
X    volatile uint32_t  TXUDF:1;
N    __IO uint32_t  TXOVF:1;
X    volatile uint32_t  TXOVF:1;
N    __I  uint32_t  TXTHF:1;
X    volatile const  uint32_t  TXTHF:1;
N    __I  uint32_t  TXFULL:1;
X    volatile const  uint32_t  TXFULL:1;
N    __I  uint32_t  TXEMPTY:1;
X    volatile const  uint32_t  TXEMPTY:1;
N    __I  uint32_t  TXBUSY:1;
X    volatile const  uint32_t  TXBUSY:1;
N    __I  uint32_t  RZCF:1;
X    volatile const  uint32_t  RZCF:1;
N    __I  uint32_t  LZCF:1;  
X    volatile const  uint32_t  LZCF:1;  
N    __I  uint32_t  RX_LEVEL:4;
X    volatile const  uint32_t  RX_LEVEL:4;
N    __I  uint32_t  TX_LEVEL:4;
X    volatile const  uint32_t  TX_LEVEL:4;
N} I2S_I2SSTATUS_T;
N
Ntypedef __O uint32_t I2S_I2STXFIFO_T;
Xtypedef volatile uint32_t I2S_I2STXFIFO_T;
N
Ntypedef __I uint32_t I2S_I2SRXFIFO_T;
Xtypedef volatile const uint32_t I2S_I2SRXFIFO_T;
N
Ntypedef struct
N{
N    union 
N    {
N        __IO uint32_t u32I2SCON;
X        volatile uint32_t u32I2SCON;
N        
N        struct 
N        {
N            __IO uint32_t  I2SEN:1;
X            volatile uint32_t  I2SEN:1;
N            __IO uint32_t  TXEN:1;
X            volatile uint32_t  TXEN:1;
N            __IO uint32_t  RXEN:1;
X            volatile uint32_t  RXEN:1;
N            __IO uint32_t  MUTE:1;
X            volatile uint32_t  MUTE:1;
N            __IO uint32_t  WORDWIDTH:2;
X            volatile uint32_t  WORDWIDTH:2;
N            __IO uint32_t  MONO:1;
X            volatile uint32_t  MONO:1;
N            __IO uint32_t  FORMAT:1;
X            volatile uint32_t  FORMAT:1;
N            __IO uint32_t  SLAVE:1;
X            volatile uint32_t  SLAVE:1;
N            __IO uint32_t  TXTH:3;
X            volatile uint32_t  TXTH:3;
N            __IO uint32_t  RXTH:3;
X            volatile uint32_t  RXTH:3;
N            __IO uint32_t  MCLKEN:1;
X            volatile uint32_t  MCLKEN:1;
N            __IO uint32_t  RCHZCEN:1;
X            volatile uint32_t  RCHZCEN:1;
N            __IO uint32_t  LCHZCEN:1;
X            volatile uint32_t  LCHZCEN:1;
N            __IO uint32_t  CLR_TXFIFO:1;
X            volatile uint32_t  CLR_TXFIFO:1;
N            __IO uint32_t  CLR_RXFIFO:1;
X            volatile uint32_t  CLR_RXFIFO:1;
N            __IO uint32_t  TXDMA:1;
X            volatile uint32_t  TXDMA:1;
N            __IO uint32_t  RXDMA:1; 
X            volatile uint32_t  RXDMA:1; 
N            __I  uint32_t  RESERVE:10;
X            volatile const  uint32_t  RESERVE:10;
N        } I2SCON;
N    };
N
N    union 
N    {
N        __IO uint32_t u32I2SCLKDIV;
X        volatile uint32_t u32I2SCLKDIV;
N        
N        struct 
N        {
N            __IO uint32_t  MCLK_DIV:3;
X            volatile uint32_t  MCLK_DIV:3;
N            __I  uint32_t  RESERVE0:5;
X            volatile const  uint32_t  RESERVE0:5;
N            __IO uint32_t  BCLK_DIV:8;
X            volatile uint32_t  BCLK_DIV:8;
N            __I  uint32_t  RESERVE1:16;
X            volatile const  uint32_t  RESERVE1:16;
N        } I2SCLKDIV;
N    };
N
N    union 
N    {
N        __IO uint32_t u32I2SIE;
X        volatile uint32_t u32I2SIE;
N        
N        struct 
N        {
N            __IO uint32_t  RXUDFIE:1;
X            volatile uint32_t  RXUDFIE:1;
N            __IO uint32_t  RXOVFIE:1;
X            volatile uint32_t  RXOVFIE:1;
N            __IO uint32_t  RXTHIE:1;
X            volatile uint32_t  RXTHIE:1;
N            __I  uint32_t  RESERVE0:5;
X            volatile const  uint32_t  RESERVE0:5;
N            __IO uint32_t  TXUDFIE:1;
X            volatile uint32_t  TXUDFIE:1;
N            __IO uint32_t  TXOVFIE:1;
X            volatile uint32_t  TXOVFIE:1;
N            __IO uint32_t  TXTHIE:1;
X            volatile uint32_t  TXTHIE:1;
N            __IO uint32_t  RZCIE:1;
X            volatile uint32_t  RZCIE:1;
N            __IO uint32_t  LZCIE:1;
X            volatile uint32_t  LZCIE:1;
N            __I  uint32_t  RESERVE1:19;
X            volatile const  uint32_t  RESERVE1:19;
N        } I2SIE;
N    };
N
N    union 
N    {
N        __I uint32_t u32I2SSTATUS;
X        volatile const uint32_t u32I2SSTATUS;
N        struct 
N        {
N            __I  uint32_t  I2SINT:1;
X            volatile const  uint32_t  I2SINT:1;
N            __I  uint32_t  I2SRXINT:1;
X            volatile const  uint32_t  I2SRXINT:1;
N            __I  uint32_t  I2STXINT:1;
X            volatile const  uint32_t  I2STXINT:1;
N            __I  uint32_t  RIGHT:1;
X            volatile const  uint32_t  RIGHT:1;
N            __I  uint32_t  RESERVE0:4;
X            volatile const  uint32_t  RESERVE0:4;
N            __IO uint32_t  RXUDF:1;
X            volatile uint32_t  RXUDF:1;
N            __IO uint32_t  RXOVF:1;
X            volatile uint32_t  RXOVF:1;
N            __I  uint32_t  RXTHF:1;
X            volatile const  uint32_t  RXTHF:1;
N            __I  uint32_t  RXFULL:1;
X            volatile const  uint32_t  RXFULL:1;
N            __I  uint32_t  RXEMPTY:1;
X            volatile const  uint32_t  RXEMPTY:1;
N            __I  uint32_t  RESERVE1:3;
X            volatile const  uint32_t  RESERVE1:3;
N            __IO uint32_t  TXUDF:1;
X            volatile uint32_t  TXUDF:1;
N            __IO uint32_t  TXOVF:1;
X            volatile uint32_t  TXOVF:1;
N            __I  uint32_t  TXTHF:1;
X            volatile const  uint32_t  TXTHF:1;
N            __I  uint32_t  TXFULL:1;
X            volatile const  uint32_t  TXFULL:1;
N            __I  uint32_t  TXEMPTY:1;
X            volatile const  uint32_t  TXEMPTY:1;
N            __I  uint32_t  TXBUSY:1;
X            volatile const  uint32_t  TXBUSY:1;
N            __I  uint32_t  RZCF:1;
X            volatile const  uint32_t  RZCF:1;
N            __I  uint32_t  LZCF:1;  
X            volatile const  uint32_t  LZCF:1;  
N            __I  uint32_t  RX_LEVEL:4;
X            volatile const  uint32_t  RX_LEVEL:4;
N            __I  uint32_t  TX_LEVEL:4;
X            volatile const  uint32_t  TX_LEVEL:4;
N        } I2SSTATUS;
N    };
N    
N    union 
N    {
N        __O uint32_t u32I2STXFIFO;
X        volatile uint32_t u32I2STXFIFO;
N        __O uint32_t I2STXFIFO;
X        volatile uint32_t I2STXFIFO;
N    };
N
N    union 
N    {
N        __I uint32_t u32I2SRXFIFO;
X        volatile const uint32_t u32I2SRXFIFO;
N        __I uint32_t I2SRXFIFO;
X        volatile const uint32_t I2SRXFIFO;
N    };
N} I2S_T;
N
N
N/* I2S I2SCON Bit Field Definitions */
N#define I2S_I2SCON_RXDMA_Pos                    21
N#define I2S_I2SCON_RXDMA_Msk                    (1ul << I2S_I2SCON_RXDMA_Pos)
N
N#define I2S_I2SCON_TXDMA_Pos                    20
N#define I2S_I2SCON_TXDMA_Msk                    (1ul << I2S_I2SCON_TXDMA_Pos)
N
N#define I2S_I2SCON_CLR_RXFIFO_Pos               19
N#define I2S_I2SCON_CLR_RXFIFO_Msk               (1ul << I2S_I2SCON_CLR_RXFIFO_Pos)
N
N#define I2S_I2SCON_CLR_TXFIFO_Pos               18
N#define I2S_I2SCON_CLR_TXFIFO_Msk               (1ul << I2S_I2SCON_CLR_TXFIFO_Pos)
N
N#define I2S_I2SCON_LCHZCEN_Pos                  17
N#define I2S_I2SCON_LCHZCEN_Msk                  (1ul << I2S_I2SCON_LCHZCEN_Pos)
N
N#define I2S_I2SCON_RCHZCEN_Pos                  16
N#define I2S_I2SCON_RCHZCEN_Msk                  (1ul << I2S_I2SCON_RCHZCEN_Pos)
N
N#define I2S_I2SCON_MCLKEN_Pos                   15
N#define I2S_I2SCON_MCLKEN_Msk                   (1ul << I2S_I2SCON_MCLKEN_Pos)
N
N#define I2S_I2SCON_RXTH_Pos                     12
N#define I2S_I2SCON_RXTH_Msk                     (7ul << I2S_I2SCON_RXTH_Pos)
N
N#define I2S_I2SCON_TXTH_Pos                     9
N#define I2S_I2SCON_TXTH_Msk                     (7ul << I2S_I2SCON_TXTH_Pos)
N
N#define I2S_I2SCON_SLAVE_Pos                    8
N#define I2S_I2SCON_SLAVE_Msk                    (1ul << I2S_I2SCON_SLAVE_Pos)
N
N#define I2S_I2SCON_FORMAT_Pos                   7
N#define I2S_I2SCON_FORMAT_Msk                   (1ul << I2S_I2SCON_FORMAT_Pos)
N
N#define I2S_I2SCON_MONO_Pos                     6
N#define I2S_I2SCON_MONO_Msk                     (1ul << I2S_I2SCON_MONO_Pos)
N
N#define I2S_I2SCON_WORDWIDTH_Pos                4
N#define I2S_I2SCON_WORDWIDTH_Msk                (3ul << I2S_I2SCON_WORDWIDTH_Pos)
N
N#define I2S_I2SCON_MUTE_Pos                     3
N#define I2S_I2SCON_MUTE_Msk                     (1ul << I2S_I2SCON_MUTE_Pos)
N
N#define I2S_I2SCON_RXEN_Pos                     2
N#define I2S_I2SCON_RXEN_Msk                     (1ul << I2S_I2SCON_RXEN_Pos)
N
N#define I2S_I2SCON_TXEN_Pos                     1
N#define I2S_I2SCON_TXEN_Msk                     (1ul << I2S_I2SCON_TXEN_Pos)
N
N#define I2S_I2SCON_I2SEN_Pos                    0
N#define I2S_I2SCON_I2SEN_Msk                    (1ul << I2S_I2SCON_I2SEN_Pos)
N
N/* I2S I2SCLKDIV Bit Field Definitions */
N#define I2S_I2SCLKDIV_BCLK_DIV_Pos              8
N#define I2S_I2SCLKDIV_BCLK_DIV_Msk              (0xFFul << I2S_I2SCLKDIV_BCLK_DIV_Pos)
N
N#define I2S_I2SCLKDIV_MCLK_DIV_Pos              0
N#define I2S_I2SCLKDIV_MCLK_DIV_Msk              (7ul << I2S_I2SCLKDIV_MCLK_DIV_Pos)
N
N/* I2S I2SIE Bit Field Definitions */
N#define I2S_I2SIE_LZCIE_Pos                     12
N#define I2S_I2SIE_LZCIE_Msk                     (1ul << I2S_I2SIE_LZCIE_Pos)
N
N#define I2S_I2SIE_RZCIE_Pos                     11
N#define I2S_I2SIE_RZCIE_Msk                     (1ul << I2S_I2SIE_RZCIE_Pos)
N
N#define I2S_I2SIE_TXTHIE_Pos                    10
N#define I2S_I2SIE_TXTHIE_Msk                    (1ul << I2S_I2SIE_TXTHIE_Pos)
N                                        
N#define I2S_I2SIE_TXOVFIE_Pos                   9
N#define I2S_I2SIE_TXOVFIE_Msk                   (1ul << I2S_I2SIE_TXOVFIE_Pos)
N
N#define I2S_I2SIE_TXUDFIE_Pos                   8
N#define I2S_I2SIE_TXUDFIE_Msk                   (1ul << I2S_I2SIE_TXUDFIE_Pos)
N
N#define I2S_I2SIE_RXTHIE_Pos                    2
N#define I2S_I2SIE_RXTHIE_Msk                    (1ul << I2S_I2SIE_RXTHIE_Pos)
N                                        
N#define I2S_I2SIE_RXOVFIE_Pos                   1
N#define I2S_I2SIE_RXOVFIE_Msk                   (1ul << I2S_I2SIE_RXOVFIE_Pos)
N
N#define I2S_I2SIE_RXUDFIE_Pos                   0
N#define I2S_I2SIE_RXUDFIE_Msk                   (1ul << I2S_I2SIE_RXUDFIE_Pos)
N
N
N/* I2S I2SSTATUS Bit Field Definitions */
N#define I2S_I2SSTATUS_TX_LEVEL_Pos              28
N#define I2S_I2SSTATUS_TX_LEVEL_Msk              (0xFul << I2S_I2SSTATUS_TX_LEVEL_Pos)
N
N#define I2S_I2SSTATUS_RX_LEVEL_Pos              24
N#define I2S_I2SSTATUS_RX_LEVEL_Msk              (0xFul << I2S_I2SSTATUS_RX_LEVEL_Pos)
N
N#define I2S_I2SSTATUS_LZCF_Pos                  23
N#define I2S_I2SSTATUS_LZCF_Msk                  (1ul << I2S_I2SSTATUS_LZCF_Pos)
N
N#define I2S_I2SSTATUS_RZCF_Pos                  22
N#define I2S_I2SSTATUS_RZCF_Msk                  (1ul << I2S_I2SSTATUS_RZCF_Pos)
N
N#define I2S_I2SSTATUS_TXBUSY_Pos                21
N#define I2S_I2SSTATUS_TXBUSY_Msk                (1ul << I2S_I2SSTATUS_TXBUSY_Pos)
N
N#define I2S_I2SSTATUS_TXEMPTY_Pos               20
N#define I2S_I2SSTATUS_TXEMPTY_Msk               (1ul << I2S_I2SSTATUS_TXEMPTY_Pos)
N
N#define I2S_I2SSTATUS_TXFULL_Pos                19
N#define I2S_I2SSTATUS_TXFULL_Msk                (1ul << I2S_I2SSTATUS_TXFULL_Pos)
N
N#define I2S_I2SSTATUS_TXTHF_Pos                 18
N#define I2S_I2SSTATUS_TXTHF_Msk                 (1ul << I2S_I2SSTATUS_TXTHF_Pos)
N
N#define I2S_I2SSTATUS_TXOVF_Pos                 17
N#define I2S_I2SSTATUS_TXOVF_Msk                 (1ul << I2S_I2SSTATUS_TXOVF_Pos)
N
N#define I2S_I2SSTATUS_TXUDF_Pos                 16
N#define I2S_I2SSTATUS_TXUDF_Msk                 (1ul << I2S_I2SSTATUS_TXUDF_Pos)
N
N#define I2S_I2SSTATUS_RXEMPTY_Pos               12
N#define I2S_I2SSTATUS_RXEMPTY_Msk               (1ul << I2S_I2SSTATUS_RXEMPTY_Pos)
N
N#define I2S_I2SSTATUS_RXFULL_Pos                11
N#define I2S_I2SSTATUS_RXFULL_Msk                (1ul << I2S_I2SSTATUS_RXFULL_Pos)
N
N#define I2S_I2SSTATUS_RXTHF_Pos                 10
N#define I2S_I2SSTATUS_RXTHF_Msk                 (1ul << I2S_I2SSTATUS_RXTHF_Pos)
N
N#define I2S_I2SSTATUS_RXOVF_Pos                 9
N#define I2S_I2SSTATUS_RXOVF_Msk                 (1ul << I2S_I2SSTATUS_RXOVF_Pos)
N
N#define I2S_I2SSTATUS_RXUDF_Pos                 8
N#define I2S_I2SSTATUS_RXUDF_Msk                 (1ul << I2S_I2SSTATUS_RXUDF_Pos)
N
N#define I2S_I2SSTATUS_RIGHT_Pos                 3
N#define I2S_I2SSTATUS_RIGHT_Msk                 (1ul << I2S_I2SSTATUS_RIGHT_Pos)
N
N#define I2S_I2SSTATUS_I2STXINT_Pos              2
N#define I2S_I2SSTATUS_I2STXINT_Msk              (1ul << I2S_I2SSTATUS_I2STXINT_Pos)
N
N#define I2S_I2SSTATUS_I2SRXINT_Pos              1
N#define I2S_I2SSTATUS_I2SRXINT_Msk              (1ul << I2S_I2SSTATUS_I2SRXINT_Pos)
N
N#define I2S_I2SSTATUS_I2SINT_Pos                0
N#define I2S_I2SSTATUS_I2SINT_Msk                (1ul << I2S_I2SSTATUS_I2SINT_Pos)
N
N
N/*----------------------------- EBI Controller -------------------------------*/
Ntypedef struct
N{
N    __IO uint32_t  ExtEN:1;
X    volatile uint32_t  ExtEN:1;
N    __IO uint32_t  ExtBW16:1;
X    volatile uint32_t  ExtBW16:1;
N    __I  uint32_t  RESERVE0:6;
X    volatile const  uint32_t  RESERVE0:6;
N    __IO uint32_t  MCLKDIV:3;
X    volatile uint32_t  MCLKDIV:3;
N    __I  uint32_t  RESERVE1:5;
X    volatile const  uint32_t  RESERVE1:5;
N    __IO uint32_t  ExttALE:3;
X    volatile uint32_t  ExttALE:3;
N    __I  uint32_t  RESERVE2:13;
X    volatile const  uint32_t  RESERVE2:13;
N} EBI_EBICON_T;
N
Ntypedef struct
N{
N    __I  uint32_t  RESERVE0:3;
X    volatile const  uint32_t  RESERVE0:3;
N    __IO uint32_t  ExttACC:5;
X    volatile uint32_t  ExttACC:5;
N    __IO uint32_t  ExttAHD:3;
X    volatile uint32_t  ExttAHD:3;
N    __I  uint32_t  RESERVE1:1;
X    volatile const  uint32_t  RESERVE1:1;
N    __IO uint32_t  ExtIW2X:4;
X    volatile uint32_t  ExtIW2X:4;
N    __I  uint32_t  RESERVE2:8;
X    volatile const  uint32_t  RESERVE2:8;
N    __IO uint32_t  ExtIR2R:4;
X    volatile uint32_t  ExtIR2R:4;
N    __I  uint32_t  RESERVE3:4;
X    volatile const  uint32_t  RESERVE3:4;
N} EBI_EXTIME_T;
N
Ntypedef struct
N{
N    union {
N        __IO uint32_t u32EBICON;
X        volatile uint32_t u32EBICON;
N        struct {
N            __IO uint32_t  ExtEN:1;
X            volatile uint32_t  ExtEN:1;
N            __IO uint32_t  ExtBW16:1;
X            volatile uint32_t  ExtBW16:1;
N            __I  uint32_t  RESERVE0:6;
X            volatile const  uint32_t  RESERVE0:6;
N            __IO uint32_t  MCLKDIV:3;
X            volatile uint32_t  MCLKDIV:3;
N            __I  uint32_t  RESERVE1:5;
X            volatile const  uint32_t  RESERVE1:5;
N            __IO uint32_t  ExttALE:3;
X            volatile uint32_t  ExttALE:3;
N            __I  uint32_t  RESERVE2:13;
X            volatile const  uint32_t  RESERVE2:13;
N        } EBICON;
N    };
N
N    union {
N        __IO uint32_t u32EXTIME;
X        volatile uint32_t u32EXTIME;
N        struct {
N            __I  uint32_t  RESERVE0:3;
X            volatile const  uint32_t  RESERVE0:3;
N            __IO uint32_t  ExttACC:5;
X            volatile uint32_t  ExttACC:5;
N            __IO uint32_t  ExttAHD:3;
X            volatile uint32_t  ExttAHD:3;
N            __I  uint32_t  RESERVE1:1;
X            volatile const  uint32_t  RESERVE1:1;
N            __IO uint32_t  ExtIW2X:4;
X            volatile uint32_t  ExtIW2X:4;
N            __I  uint32_t  RESERVE2:8;
X            volatile const  uint32_t  RESERVE2:8;
N            __IO uint32_t  ExtIR2R:4;
X            volatile uint32_t  ExtIR2R:4;
N            __I  uint32_t  RESERVE3:4;
X            volatile const  uint32_t  RESERVE3:4;
N        } EXTIME;
N    };
N} EBI_T;
N
N/* EBI EBICON Bit Field Definitions */
N#define EBI_EBICON_ExttALE_Pos      16
N#define EBI_EBICON_ExttALE_Msk      (0x7ul << EBI_EBICON_ExttALE_Pos)
N
N#define EBI_EBICON_MCLKDIV_Pos      8
N#define EBI_EBICON_MCLKDIV_Msk      (0x7ul << EBI_EBICON_MCLKDIV_Pos)
N
N#define EBI_EBICON_ExtBW16_Pos      1
N#define EBI_EBICON_ExtBW16_Msk      (1ul << EBI_EBICON_ExtBW16_Pos)
N
N#define EBI_EBICON_ExtEN_Pos        0
N#define EBI_EBICON_ExtEN_Msk        (1ul << EBI_EBICON_ExtEN_Pos)
N
N/* EBI EXTIME Bit Field Definitions */
N#define EBI_EXTIME_ExtIR2R_Pos      24
N#define EBI_EXTIME_ExtIR2R_Msk      (0xFul << EBI_EXTIME_ExtIR2R_Pos)
N
N#define EBI_EXTIME_ExtIW2X_Pos      12
N#define EBI_EXTIME_ExtIW2X_Msk      (0xFul << EBI_EXTIME_ExtIW2X_Pos)
N
N#define EBI_EXTIME_ExttAHD_Pos      8
N#define EBI_EXTIME_ExttAHD_Msk      (0x7ul << EBI_EXTIME_ExttAHD_Pos)
N
N#define EBI_EXTIME_ExttACC_Pos      3
N#define EBI_EXTIME_ExttACC_Msk      (0x1Ful << EBI_EXTIME_ExttACC_Pos)
N
N
N/******************************************************************************/
N/*                         Peripheral memory map                              */
N/******************************************************************************/
N/* Peripheral and SRAM base address */
N#define FLASH_BASE          ((     uint32_t)0x00000000)
N#define SRAM_BASE           ((     uint32_t)0x20000000)
N#define AHB_BASE            ((     uint32_t)0x50000000)
N#define APB1_BASE           ((     uint32_t)0x40000000)
N#define APB2_BASE           ((     uint32_t)0x40100000)
N
N/* Peripheral memory map */
N#define GPIO_BASE           (AHB_BASE        + 0x4000)
N
N#define GPIOA_BASE          (GPIO_BASE               )
N#define GPIOB_BASE          (GPIO_BASE       + 0x0040)
N#define GPIOC_BASE          (GPIO_BASE       + 0x0080)
N#define GPIOD_BASE          (GPIO_BASE       + 0x00C0)
N#define GPIOE_BASE          (GPIO_BASE       + 0x0100)
N#define GPIO_DBNCECON_BASE  (GPIO_BASE       + 0x0180)
N
N#define UART0_BASE           (APB1_BASE      + 0x50000)
N#define UART1_BASE           (APB2_BASE      + 0x50000)
N#define UART2_BASE           (APB2_BASE      + 0x54000)
N
N
N#define TIMER0_BASE          (APB1_BASE      + 0x10000)  
N#define TIMER1_BASE          (APB1_BASE      + 0x10020)  
N#define TIMER2_BASE          (APB2_BASE      + 0x10000)  
N#define TIMER3_BASE          (APB2_BASE      + 0x10020)  
N
N#define WDT_BASE             (APB1_BASE      + 0x4000)  
N
N#define SPI0_BASE            (APB1_BASE      + 0x30000)
N#define SPI1_BASE            (APB1_BASE      + 0x34000)
N#define SPI2_BASE            (APB2_BASE      + 0x30000)
N#define SPI3_BASE            (APB2_BASE      + 0x34000)
N
N#define I2C0_BASE            (APB1_BASE      + 0x20000)
N#define I2C1_BASE            (APB2_BASE      + 0x20000)
N
N#define RTC_BASE             (APB1_BASE      + 0x08000)
N
N#define ADC_BASE             (APB1_BASE      + 0xE0000)
N
N#define ACMP_BASE            (APB1_BASE      + 0xD0000)   
N
N#define SYSCLK_BASE          (AHB_BASE       + 0x00200)
N
N#define GCR_BASE             (AHB_BASE       + 0x00000)
N
N#define INT_BASE             (AHB_BASE       + 0x00300)
N
N#define FMC_BASE             (AHB_BASE       + 0x0C000)
N
N#define PS2_BASE             (APB2_BASE      + 0x00000)
N
N#define CAN0_BASE            (APB2_BASE      + 0x80000)
N#define CAN1_BASE            (APB2_BASE      + 0x84000)
N#define C_CAN_BASE           (APB2_BASE      + 0x88000)
N
N#define USBD_BASE            (APB1_BASE      + 0x60000)
N
N#define PDMA0_BASE           (AHB_BASE       + 0x08000)
N#define PDMA1_BASE           (AHB_BASE       + 0x08100)
N#define PDMA2_BASE           (AHB_BASE       + 0x08200)
N#define PDMA3_BASE           (AHB_BASE       + 0x08300)
N#define PDMA4_BASE           (AHB_BASE       + 0x08400)
N#define PDMA5_BASE           (AHB_BASE       + 0x08500)
N#define PDMA6_BASE           (AHB_BASE       + 0x08600)
N#define PDMA7_BASE           (AHB_BASE       + 0x08700)
N#define PDMA8_BASE           (AHB_BASE       + 0x08800)
N#define PDMA9_BASE           (AHB_BASE       + 0x08900)
N#define PDMA10_BASE          (AHB_BASE       + 0x08A00)
N#define PDMA11_BASE          (AHB_BASE       + 0x08B00)
N#define PDMA_GCR_BASE        (AHB_BASE       + 0x08F00)
N
N#define PWMA_BASE            (APB1_BASE      + 0x40000)
N#define PWMB_BASE            (APB2_BASE      + 0x40000)
N
N#define I2S_BASE             (APB2_BASE      + 0xA0000)
N
N#define EBI_BASE             (AHB_BASE       + 0x10000)
N
N/******************************************************************************/
N/*                         Peripheral declaration                             */
N/******************************************************************************/
N#define GPIOA               ((GPIO_T *) GPIOA_BASE)
N#define GPIOB               ((GPIO_T *) GPIOB_BASE)
N#define GPIOC               ((GPIO_T *) GPIOC_BASE)
N#define GPIOD               ((GPIO_T *) GPIOD_BASE)
N#define GPIOE               ((GPIO_T *) GPIOE_BASE)
N#define GPIO_DBNCECON       ((GPIO_DBNCECON_T *) GPIO_DBNCECON_BASE)
N#define GPIO_BIT_ADDR_BASE  (GPIO_BASE + 0x200)
N
N#define UART0               ((UART_T *) UART0_BASE)
N#define UART1               ((UART_T *) UART1_BASE)
N#define UART2               ((UART_T *) UART2_BASE)
N
N
N#define TIMER0              ((TIMER_T *) TIMER0_BASE)
N#define TIMER1              ((TIMER_T *) TIMER1_BASE)
N#define TIMER2              ((TIMER_T *) TIMER2_BASE)
N#define TIMER3              ((TIMER_T *) TIMER3_BASE)
N
N#define WDT                 ((WDT_T *) WDT_BASE)
N
N#define SPI0                ((SPI_T *) SPI0_BASE)
N#define SPI1                ((SPI_T *) SPI1_BASE)
N#define SPI2                ((SPI_T *) SPI2_BASE)
N#define SPI3                ((SPI_T *) SPI3_BASE)
N
N#define I2C0                ((I2C_T *) I2C0_BASE)
N#define I2C1                ((I2C_T *) I2C1_BASE)
N
N#define I2S                 ((I2S_T *) I2S_BASE)
N
N#define RTC                 ((RTC_T *) RTC_BASE)
N
N#define ADC                 ((ADC_T *) ADC_BASE)
N
N#define ACMP                ((ACMP_T *) ACMP_BASE)
N
N#define SYSCLK              ((SYSCLK_T *) SYSCLK_BASE)
N
N#define SYS                 ((GCR_T *) GCR_BASE)
N
N#define SYSINT              ((GCR_INT_T *) INT_BASE)
N
N#define FMC                 ((FMC_T *) FMC_BASE)
N
N#define PS2                 ((PS2_T *) PS2_BASE)
N
N#define CAN                 ((CAN_T *) CAN0_BASE)
N#define USBD                ((USBD_T *) USBD_BASE)
N
N#define PDMA0               ((PDMA_T *) PDMA0_BASE)
N#define PDMA1               ((PDMA_T *) PDMA1_BASE)
N#define PDMA2               ((PDMA_T *) PDMA2_BASE)
N#define PDMA3               ((PDMA_T *) PDMA3_BASE)
N#define PDMA4               ((PDMA_T *) PDMA4_BASE)
N#define PDMA5               ((PDMA_T *) PDMA5_BASE)
N#define PDMA6               ((PDMA_T *) PDMA6_BASE)
N#define PDMA7               ((PDMA_T *) PDMA7_BASE)
N#define PDMA8               ((PDMA_T *) PDMA8_BASE)
N#define PDMA9               ((PDMA_T *) PDMA9_BASE)
N#define PDMA_GCR            ((PDMA_GCR_T *) PDMA_GCR_BASE)
N
N#define PWMA                ((PWM_T *) PWMA_BASE)
N#define PWMB                ((PWM_T *) PWMB_BASE)
N
N#define EBI                 ((EBI_T *) EBI_BASE)
N
N#define UNLOCKREG(x)        *((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x59;*((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x16;*((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x88
N#define LOCKREG(x)          *((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x00;     
N
N#define REGCOPY(dest, src)  *((uint32_t *)&(dest)) = *((uint32_t *)&(src))
N#define CLEAR(dest)         *((uint32_t *)&(dest)) = 0
N
N//=============================================================================
Ntypedef volatile unsigned char  vu8;
Ntypedef volatile unsigned long  vu32;
Ntypedef volatile unsigned short vu16;
N#define M8(adr)  (*((vu8  *) (adr)))
N#define M16(adr) (*((vu16 *) (adr)))
N#define M32(adr) (*((vu32 *) (adr)))
N
N#define outpw(port,value)   *((volatile unsigned int *)(port))=value
N#define inpw(port)          (*((volatile unsigned int *)(port)))
N#define outpb(port,value)   *((volatile unsigned char *)(port))=value
N#define inpb(port)          (*((volatile unsigned char *)(port)))
N#define outps(port,value)   *((volatile unsigned short *)(port))=value
N#define inps(port)          (*((volatile unsigned short *)(port)))
N
N#define outp32(port,value)  *((volatile unsigned int *)(port))=value
N#define inp32(port)         (*((volatile unsigned int *)(port)))
N#define outp8(port,value)   *((volatile unsigned char *)(port))=value
N#define inp8(port)          (*((volatile unsigned char *)(port)))
N#define outp16(port,value)  *((volatile unsigned short *)(port))=value
N#define inp16(port)         (*((volatile unsigned short *)(port)))
N
N
N#define E_SUCCESS   0
N#ifndef NULL
S#define NULL        0
N#endif
N
N#define TRUE        1
N#define FALSE       0
N
N#define ENABLE     1
N#define DISABLE    0
N
N/* Define one bit mask */
N#define BIT0    0x00000001
N#define BIT1    0x00000002
N#define BIT2    0x00000004
N#define BIT3    0x00000008
N#define BIT4    0x00000010
N#define BIT5    0x00000020
N#define BIT6    0x00000040
N#define BIT7    0x00000080
N#define BIT8    0x00000100
N#define BIT9    0x00000200
N#define BIT10   0x00000400
N#define BIT11   0x00000800
N#define BIT12   0x00001000
N#define BIT13   0x00002000
N#define BIT14   0x00004000
N#define BIT15   0x00008000
N#define BIT16   0x00010000
N#define BIT17   0x00020000
N#define BIT18   0x00040000
N#define BIT19   0x00080000
N#define BIT20   0x00100000
N#define BIT21   0x00200000
N#define BIT22   0x00400000
N#define BIT23   0x00800000
N#define BIT24   0x01000000
N#define BIT25   0x02000000
N#define BIT26   0x04000000
N#define BIT27   0x08000000
N#define BIT28   0x10000000
N#define BIT29   0x20000000
N#define BIT30   0x40000000
N#define BIT31   0x80000000
N
N#endif
N                                                                                                 
L 11 "Smpl_CAN.c" 2
N#include "Driver\DrvGPIO.h"
L 1 "..\..\..\Include\Driver\DrvGPIO.h" 1
N/*---------------------------------------------------------------------------------------------------------*/
N/*                                                                                                         */
N/* Copyright(c) 2009 Nuvoton Technology Corp. All rights reserved.                                         */
N/*                                                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#ifndef DRVGPIO_H
N#define DRVGPIO_H
N
N#include "NUC1xx.h"
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define Version number								                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define DRVGPIO_MAJOR_NUM       1
N#define DRVGPIO_MINOR_NUM	    04
N#define DRVGPIO_BUILD_NUM	    005
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Version define with SysInfra				                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define DRVGPIO_VERSION_NUM     _SYSINFRA_VERSION(DRVGPIO_MAJOR_NUM, DRVGPIO_MINOR_NUM, DRVGPIO_BUILD_NUM)
N							   
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define Error Code									                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define E_DRVGPIO_ARGUMENT          _SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVGPIO, 1)
N#define E_DRVGPIO_GROUP_PIN         _SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVGPIO, 2)
N#define E_DRVGPIO_BUSY              _SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVGPIO, 3)   
N
Ntypedef void (*GPIO_GPAB_CALLBACK)(uint32_t u32GPAStatus, uint32_t u32GPBStatus);
Ntypedef void (*GPIO_GPCDE_CALLBACK)(uint32_t u32GPCStatus, uint32_t u32GPDStatus, uint32_t u32GPEStatus);
Ntypedef void (*GPIO_EINT0_CALLBACK)(void);
Ntypedef void (*GPIO_EINT1_CALLBACK)(void);
N
N/* Define GPIO[n] Pin I/O Bit Output/Input Control. Only NUC1x0xxxBN and NUC1x0xxxCN Series support this feature. */
N#define _DRVGPIO_DOUT(PortNum, PinNum)      (*((volatile uint32_t *) ((GPIO_BIT_ADDR_BASE+(0x40*PortNum)) + (0x4*PinNum))))    
N#define GPA_0	            _DRVGPIO_DOUT(0, 0)
N#define GPA_1	            _DRVGPIO_DOUT(0, 1)
N#define GPA_2	            _DRVGPIO_DOUT(0, 2)
N#define GPA_3	            _DRVGPIO_DOUT(0, 3)
N#define GPA_4	            _DRVGPIO_DOUT(0, 4)
N#define GPA_5	            _DRVGPIO_DOUT(0, 5)
N#define GPA_6	            _DRVGPIO_DOUT(0, 6)
N#define GPA_7	            _DRVGPIO_DOUT(0, 7)
N#define GPA_8	            _DRVGPIO_DOUT(0, 8)
N#define GPA_9	            _DRVGPIO_DOUT(0, 9)
N#define GPA_10	            _DRVGPIO_DOUT(0, 10)
N#define GPA_11	            _DRVGPIO_DOUT(0, 11)
N#define GPA_12	            _DRVGPIO_DOUT(0, 12)
N#define GPA_13	            _DRVGPIO_DOUT(0, 13)
N#define GPA_14	            _DRVGPIO_DOUT(0, 14)
N#define GPA_15	            _DRVGPIO_DOUT(0, 15)
N#define GPB_0	            _DRVGPIO_DOUT(1, 0)
N#define GPB_1	            _DRVGPIO_DOUT(1, 1)
N#define GPB_2	            _DRVGPIO_DOUT(1, 2)
N#define GPB_3	            _DRVGPIO_DOUT(1, 3)
N#define GPB_4	            _DRVGPIO_DOUT(1, 4)
N#define GPB_5	            _DRVGPIO_DOUT(1, 5)
N#define GPB_6	            _DRVGPIO_DOUT(1, 6)
N#define GPB_7	            _DRVGPIO_DOUT(1, 7)
N#define GPB_8	            _DRVGPIO_DOUT(1, 8)
N#define GPB_9	            _DRVGPIO_DOUT(1, 9)
N#define GPB_10	            _DRVGPIO_DOUT(1, 10)
N#define GPB_11	            _DRVGPIO_DOUT(1, 11)
N#define GPB_12	            _DRVGPIO_DOUT(1, 12)
N#define GPB_13	            _DRVGPIO_DOUT(1, 13)
N#define GPB_14	            _DRVGPIO_DOUT(1, 14)
N#define GPB_15	            _DRVGPIO_DOUT(1, 15)
N#define GPC_0	            _DRVGPIO_DOUT(2, 0)
N#define GPC_1	            _DRVGPIO_DOUT(2, 1)
N#define GPC_2	            _DRVGPIO_DOUT(2, 2)
N#define GPC_3	            _DRVGPIO_DOUT(2, 3)
N#define GPC_4	            _DRVGPIO_DOUT(2, 4)
N#define GPC_5	            _DRVGPIO_DOUT(2, 5)
N#define GPC_6	            _DRVGPIO_DOUT(2, 6)
N#define GPC_7	            _DRVGPIO_DOUT(2, 7)
N#define GPC_8	            _DRVGPIO_DOUT(2, 8)
N#define GPC_9	            _DRVGPIO_DOUT(2, 9)
N#define GPC_10	            _DRVGPIO_DOUT(2, 10)
N#define GPC_11	            _DRVGPIO_DOUT(2, 11)
N#define GPC_12	            _DRVGPIO_DOUT(2, 12)
N#define GPC_13	            _DRVGPIO_DOUT(2, 13)
N#define GPC_14	            _DRVGPIO_DOUT(2, 14)
N#define GPC_15	            _DRVGPIO_DOUT(2, 15)
N#define GPD_0	            _DRVGPIO_DOUT(3, 0)
N#define GPD_1	            _DRVGPIO_DOUT(3, 1)
N#define GPD_2	            _DRVGPIO_DOUT(3, 2)
N#define GPD_3	            _DRVGPIO_DOUT(3, 3)
N#define GPD_4	            _DRVGPIO_DOUT(3, 4)
N#define GPD_5	            _DRVGPIO_DOUT(3, 5)
N#define GPD_6	            _DRVGPIO_DOUT(3, 6)
N#define GPD_7	            _DRVGPIO_DOUT(3, 7)
N#define GPD_8	            _DRVGPIO_DOUT(3, 8)
N#define GPD_9	            _DRVGPIO_DOUT(3, 9)
N#define GPD_10	            _DRVGPIO_DOUT(3, 10)
N#define GPD_11	            _DRVGPIO_DOUT(3, 11)
N#define GPD_12	            _DRVGPIO_DOUT(3, 12)
N#define GPD_13	            _DRVGPIO_DOUT(3, 13)
N#define GPD_14	            _DRVGPIO_DOUT(3, 14)
N#define GPD_15	            _DRVGPIO_DOUT(3, 15)
N#define GPE_0	            _DRVGPIO_DOUT(4, 0)
N#define GPE_1	            _DRVGPIO_DOUT(4, 1)
N#define GPE_2	            _DRVGPIO_DOUT(4, 2)
N#define GPE_3	            _DRVGPIO_DOUT(4, 3)
N#define GPE_4	            _DRVGPIO_DOUT(4, 4)
N#define GPE_5	            _DRVGPIO_DOUT(4, 5)
N#define GPE_6	            _DRVGPIO_DOUT(4, 6)
N#define GPE_7	            _DRVGPIO_DOUT(4, 7)
N#define GPE_8	            _DRVGPIO_DOUT(4, 8)
N#define GPE_9	            _DRVGPIO_DOUT(4, 9)
N#define GPE_10	            _DRVGPIO_DOUT(4, 10)
N#define GPE_11	            _DRVGPIO_DOUT(4, 11)
N#define GPE_12	            _DRVGPIO_DOUT(4, 12)
N#define GPE_13	            _DRVGPIO_DOUT(4, 13)
N#define GPE_14	            _DRVGPIO_DOUT(4, 14)
N#define GPE_15	            _DRVGPIO_DOUT(4, 15)
N
Ntypedef enum 
N{
N	E_GPA = 0,
N	E_GPB = 1, 
N	E_GPC = 2, 
N	E_GPD = 3, 
N	E_GPE = 4
N} E_DRVGPIO_PORT;
N
Ntypedef enum 
N{
N    E_IO_INPUT = 0,
N    E_IO_OUTPUT,
N    E_IO_OPENDRAIN,
N    E_IO_QUASI
N} E_DRVGPIO_IO;
N
Ntypedef enum 
N{
N    E_IO_RISING = 0,
N    E_IO_FALLING,
N    E_IO_BOTH_EDGE
N} E_DRVGPIO_INT_TYPE;
N
Ntypedef enum
N{
N    E_MODE_EDGE = 0,
N    E_MODE_LEVEL
N} E_DRVGPIO_INT_MODE;
N
Ntypedef enum
N{
N    E_DBCLKSRC_HCLK = 0, 
N    E_DBCLKSRC_10K = 1
N} E_DRVGPIO_DBCLKSRC;	   
N
Ntypedef enum
N{
N	E_FUNC_GPIO,    E_FUNC_CLKO,    E_FUNC_I2C0,    E_FUNC_I2C1,    E_FUNC_I2S,     E_FUNC_CAN0,	
N    E_FUNC_ACMP0,   E_FUNC_ACMP1,   
N    E_FUNC_SPI0,    E_FUNC_SPI0_SS1,    E_FUNC_SPI0_2BIT_MODE,
N    E_FUNC_SPI1,    E_FUNC_SPI1_SS1,    E_FUNC_SPI1_2BIT_MODE,
N    E_FUNC_SPI2,    E_FUNC_SPI2_SS1,    E_FUNC_SPI2_2BIT_MODE,
N    E_FUNC_SPI3,    E_FUNC_SPI3_SS1,    E_FUNC_SPI3_2BIT_MODE,      
N    E_FUNC_SPI0_QFN36PIN,   E_FUNC_SPI0_SS1_QFN36PIN,   E_FUNC_SPI0_2BIT_MODE_QFN36PIN,
N    E_FUNC_ADC0,    E_FUNC_ADC1,    E_FUNC_ADC2,    E_FUNC_ADC3,    E_FUNC_ADC4,    E_FUNC_ADC5,
N    E_FUNC_ADC6,    E_FUNC_ADC7,    E_FUNC_EXTINT0, E_FUNC_EXTINT1, E_FUNC_TMR0,    E_FUNC_TMR1,      
N    E_FUNC_TMR2,    E_FUNC_TMR3,    E_FUNC_T0EX,    E_FUNC_T1EX,    E_FUNC_T2EX,    E_FUNC_T3EX,
N    E_FUNC_UART0,   E_FUNC_UART0_RX_TX, E_FUNC_UART0_RTS_CTS,
N    E_FUNC_UART1,   E_FUNC_UART1_RX_TX, E_FUNC_UART1_RTS_CTS,       E_FUNC_UART2,
N    E_FUNC_PWM01,   E_FUNC_PWM23,   E_FUNC_PWM45,   E_FUNC_PWM67,   E_FUNC_PWM0,    E_FUNC_PWM1,
N    E_FUNC_PWM2,    E_FUNC_PWM3,    E_FUNC_PWM4,    E_FUNC_PWM5,    E_FUNC_PWM6,    E_FUNC_PWM7,    
N    E_FUNC_EBI_8B,  E_FUNC_EBI_16B,          
N} E_DRVGPIO_FUNC;
N			  
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define GPIO functions prototype                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
Nint32_t DrvGPIO_Open(E_DRVGPIO_PORT port, int32_t i32Bit, E_DRVGPIO_IO mode);
Nint32_t DrvGPIO_Close(E_DRVGPIO_PORT port, int32_t i32Bit);
Nint32_t DrvGPIO_SetBit(E_DRVGPIO_PORT port, int32_t i32Bit);
Nint32_t DrvGPIO_GetBit(E_DRVGPIO_PORT port, int32_t i32Bit);
Nint32_t DrvGPIO_ClrBit(E_DRVGPIO_PORT port, int32_t i32Bit);
Nint32_t DrvGPIO_SetPortBits(E_DRVGPIO_PORT port, int32_t i32Data);
Nint32_t DrvGPIO_GetPortBits(E_DRVGPIO_PORT port);
Nint32_t DrvGPIO_GetDoutBit(E_DRVGPIO_PORT port, int32_t i32Bit);
Nint32_t DrvGPIO_GetPortDoutBits(E_DRVGPIO_PORT port);
Nint32_t DrvGPIO_SetBitMask(E_DRVGPIO_PORT port, int32_t i32Bit);
Nint32_t DrvGPIO_GetBitMask(E_DRVGPIO_PORT port, int32_t i32Bit);
Nint32_t DrvGPIO_ClrBitMask(E_DRVGPIO_PORT port, int32_t i32Bit);
Nint32_t DrvGPIO_SetPortMask(E_DRVGPIO_PORT port, int32_t i32MaskData);
Nint32_t DrvGPIO_GetPortMask(E_DRVGPIO_PORT port);
Nint32_t DrvGPIO_ClrPortMask(E_DRVGPIO_PORT port, int32_t i32MaskData);
Nint32_t DrvGPIO_EnableDigitalInputBit(E_DRVGPIO_PORT port, int32_t i32Bit);
Nint32_t DrvGPIO_DisableDigitalInputBit(E_DRVGPIO_PORT port, int32_t i32Bit);
Nint32_t DrvGPIO_EnableDebounce(E_DRVGPIO_PORT port, int32_t i32Bit);
Nint32_t DrvGPIO_DisableDebounce(E_DRVGPIO_PORT port, int32_t i32Bit);
Nint32_t DrvGPIO_SetDebounceTime(uint32_t u32CycleSelection, E_DRVGPIO_DBCLKSRC ClockSource);
Nint32_t DrvGPIO_GetDebounceSampleCycle(void);
Nint32_t DrvGPIO_EnableInt(E_DRVGPIO_PORT port, int32_t i32Bit, E_DRVGPIO_INT_TYPE TriggerType, E_DRVGPIO_INT_MODE Mode);
Nint32_t DrvGPIO_DisableInt(E_DRVGPIO_PORT port, int32_t i32Bit);
Nvoid DrvGPIO_SetIntCallback(GPIO_GPAB_CALLBACK pfGPABCallback, GPIO_GPCDE_CALLBACK pfGPCDECallback);
Nvoid DrvGPIO_EnableEINT0(E_DRVGPIO_INT_TYPE TriggerType, E_DRVGPIO_INT_MODE Mode, GPIO_EINT0_CALLBACK pfEINT0Callback);
Nvoid DrvGPIO_DisableEINT0(void);
Nvoid DrvGPIO_EnableEINT1(E_DRVGPIO_INT_TYPE TriggerType, E_DRVGPIO_INT_MODE Mode, GPIO_EINT1_CALLBACK pfEINT1Callback);
Nvoid DrvGPIO_DisableEINT1(void);
Nint32_t DrvGPIO_GetIntStatus(E_DRVGPIO_PORT port);
Nint32_t DrvGPIO_InitFunction(E_DRVGPIO_FUNC function);
Nint32_t DrvGPIO_GetVersion(void);
N
N#endif
N
N
N
N
N
N
N
N
L 12 "Smpl_CAN.c" 2
N#include "Driver\DrvSYS.h"
L 1 "..\..\..\Include\Driver\DrvSYS.h" 1
N/*---------------------------------------------------------------------------------------------------------*/
N/*                                                                                                         */
N/* Copyright(c) 2009 Nuvoton Technology Corp. All rights reserved.                                         */
N/*                                                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#ifndef DRVSYS_H
N#define DRVSYS_H
N
N#include "NUC1xx.h"
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Macro, type and constant definitions                                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N#define DRVSYS_MAJOR_NUM 1
N#define DRVSYS_MINOR_NUM 02
N#define DRVSYS_BUILD_NUM 3
N
N#define DRVSYS_VERSION_NUM      _SYSINFRA_VERSION(DRVSYS_MAJOR_NUM,DRVSYS_MINOR_NUM,DRVSYS_BUILD_NUM)  
N
N//E_DRVSYS_ERR_UNLOCK_FAIL      Unlock protected register failed
N//E_DRVSYS_ERR_LOCK_FAIL        Lock protected register failed
N//E_DRVSYS_ERR_ARGUMENT         Incorrect Argument
N//E_DRVSYS_ERR_IPSRC            Incorrect IP clock selection
N//E_DRVSYS_ERR_IPDIV            Incorrect IP divider selection
N//E_DRVSYS_ERR_OUT_OF_RANGE     Clock setting is out of range
N//E_DRVSYS_ERR_REG_PROTECTED    The Register Write Protection function is enabled
N#define E_DRVSYS_ERR_UNLOCK_FAIL    _SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVSYS, 1)
N#define E_DRVSYS_ERR_LOCK_FAIL      _SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVSYS, 2)
N#define E_DRVSYS_ERR_ARGUMENT       _SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVSYS, 3)
N#define E_DRVSYS_ERR_IPSRC          _SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVSYS, 4)
N#define E_DRVSYS_ERR_IPDIV          _SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVSYS, 5)
N#define E_DRVSYS_ERR_OUT_OF_RANGE   _SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVSYS, 6)
N#define E_DRVSYS_ERR_REG_PROTECTED  _SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVSYS, 7)
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PLL Clock Source Selector                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef enum 
N{
N    E_SYS_EXTERNAL_12M = 0,
N    E_SYS_INTERNAL_22M = 1, 
N}E_SYS_PLL_CLKSRC;
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  IP reset                                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef enum 
N{
N    E_SYS_GPIO_RST  = 1,
N    E_SYS_TMR0_RST  = 2,
N    E_SYS_TMR1_RST  = 3,
N    E_SYS_TMR2_RST  = 4,
N    E_SYS_TMR3_RST  = 5,
N    E_SYS_I2C0_RST  = 8,
N    E_SYS_I2C1_RST  = 9,
N    E_SYS_SPI0_RST  = 12,
N    E_SYS_SPI1_RST  = 13,
N    E_SYS_SPI2_RST  = 14,
N    E_SYS_SPI3_RST  = 15,
N    E_SYS_UART0_RST = 16,
N    E_SYS_UART1_RST = 17,
N    E_SYS_UART2_RST = 18,
N    E_SYS_PWM03_RST = 20,
N    E_SYS_PWM47_RST = 21,
N    E_SYS_ACMP_RST  = 22,
N    E_SYS_PS2_RST   = 23,
N    E_SYS_CAN0_RST  = 24,
N    E_SYS_USBD_RST  = 27,
N    E_SYS_ADC_RST   = 28,
N    E_SYS_I2S_RST   = 29,
N    E_SYS_PDMA_RST  = 32,
N    E_SYS_EBI_RST   = 33
N}E_SYS_IP_RST;
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  SYS IP Clcok Selector                                                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
N
Ntypedef enum 
N{
N    E_SYS_WDT_CLK   = 0,
N    E_SYS_RTC_CLK   = 1,
N    E_SYS_TMR0_CLK  = 2,
N    E_SYS_TMR1_CLK  = 3,
N    E_SYS_TMR2_CLK  = 4,
N    E_SYS_TMR3_CLK  = 5,
N    E_SYS_FDIV_CLK  = 6,
N    E_SYS_I2C0_CLK  = 8,
N    E_SYS_I2C1_CLK  = 9,
N    E_SYS_SPI0_CLK  = 12,
N    E_SYS_SPI1_CLK  = 13,
N    E_SYS_SPI2_CLK  = 14,
N    E_SYS_SPI3_CLK  = 15,
N    E_SYS_UART0_CLK = 16,
N    E_SYS_UART1_CLK = 17,
N    E_SYS_UART2_CLK = 18,
N    E_SYS_PWM01_CLK = 20,
N    E_SYS_PWM23_CLK = 21,
N    E_SYS_PWM45_CLK = 22,
N    E_SYS_PWM67_CLK = 23,
N    E_SYS_CAN0_CLK  = 24,
N    E_SYS_USBD_CLK  = 27,
N    E_SYS_ADC_CLK   = 28,
N    E_SYS_I2S_CLK   = 29,
N    E_SYS_ACMP_CLK  = 30,
N    E_SYS_PS2_CLK   = 31,
N    E_SYS_PDMA_CLK  = 33,
N    E_SYS_ISP_CLK   = 34,
N    E_SYS_EBI_CLK   = 35
N}E_SYS_IP_CLK;
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  SYS IP Clcok Divider                                                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef enum 
N{
N    E_SYS_ADC_DIV,
N    E_SYS_UART_DIV,
N    E_SYS_USB_DIV,
N    E_SYS_HCLK_DIV
N
N}E_SYS_IP_DIV;
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  SYS IP Clcok Selector                                                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef enum 
N{
N    E_SYS_WDT_CLKSRC,
N    E_SYS_ADC_CLKSRC,
N    E_SYS_TMR0_CLKSRC,
N    E_SYS_TMR1_CLKSRC,
N    E_SYS_TMR2_CLKSRC,
N    E_SYS_TMR3_CLKSRC,
N    E_SYS_UART_CLKSRC,
N    E_SYS_PWM01_CLKSRC,
N    E_SYS_PWM23_CLKSRC,
N    E_SYS_I2S_CLKSRC,
N    E_SYS_FRQDIV_CLKSRC,
N    E_SYS_PWM45_CLKSRC,
N    E_SYS_PWM67_CLKSRC
N
N}E_SYS_IP_CLKSRC;
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  SYS Chip Clock Source                                                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef enum 
N{
N    E_SYS_XTL12M,
N    E_SYS_XTL32K,
N    E_SYS_OSC22M,
N    E_SYS_OSC10K,
N    E_SYS_PLL,
N}E_SYS_CHIP_CLKSRC;
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Power Down Type                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef enum 
N{
N    E_SYS_IMMEDIATE, 
N    E_SYS_WAIT_FOR_CPU
N}E_SYS_PD_TYPE;
N
N
Ntypedef void (*BOD_CALLBACK)(void);
Ntypedef void (*PWRWU_CALLBACK)(void);
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define SYS functions prototype                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
Nvoid     DrvSYS_ClearClockSwitchStatus(void);
Nuint32_t DrvSYS_ClearResetSource(uint32_t u32Src);
N
Nvoid     DrvSYS_Delay(uint32_t us);
Nvoid     DrvSYS_DisableBODLowPowerMode(void);
Nvoid     DrvSYS_DisableHighPerformanceMode(void);
Nvoid     DrvSYS_DisableLowVoltReset(void);
Nvoid     DrvSYS_DisablePOR(void);
Nvoid     DrvSYS_DisableTemperatureSensor(void);
N
Nvoid     DrvSYS_EnableBODLowPowerMode(void);
Nvoid     DrvSYS_EnableHighPerformanceMode(void);
Nvoid     DrvSYS_EnableLowVoltReset(void);
Nvoid     DrvSYS_EnablePOR(void);
Nvoid     DrvSYS_EnableTemperatureSensor(void);
Nvoid     DrvSYS_EnterPowerDown(E_SYS_PD_TYPE ePDType);
N
Nuint32_t DrvSYS_GetBODState(void);
Nint32_t  DrvSYS_GetChipClockSourceStatus(E_SYS_CHIP_CLKSRC eClkSrc);
Nuint32_t DrvSYS_GetClockSwitchStatus(void);
Nuint32_t DrvSYS_GetExtClockFreq(void);
Nuint32_t DrvSYS_GetHCLKFreq(void);
Nuint32_t DrvSYS_GetPLLClockFreq(void);
Nuint32_t DrvSYS_GetPLLContent(E_SYS_PLL_CLKSRC ePllSrc, uint32_t u32PllClk);
Nuint32_t DrvSYS_GetResetSource(void);
Nuint32_t DrvSYS_GetVersion(void);
N
Nint32_t  DrvSYS_IsProtectedRegLocked(void);
N
Nint32_t  DrvSYS_LockProtectedReg(void);
N
Nint32_t  DrvSYS_Open(uint32_t u32Hclk);
N
Nuint32_t DrvSYS_ReadProductID(void);
Nvoid     DrvSYS_ResetChip(void);
Nvoid     DrvSYS_ResetCPU(void);
Nvoid     DrvSYS_ResetIP(E_SYS_IP_RST eIpRst);
N
Nvoid     DrvSYS_SelectBODVolt(uint8_t u8Volt);
Nint32_t  DrvSYS_SelectHCLKSource(uint8_t u8ClkSrcSel);
Nint32_t  DrvSYS_SelectIPClockSource(E_SYS_IP_CLKSRC eIpClkSrc, uint8_t u8ClkSrcSel);
Nvoid     DrvSYS_SelectPLLSource(E_SYS_PLL_CLKSRC ePllSrc);
Nint32_t  DrvSYS_SelectSysTickSource(uint8_t u8ClkSrcSel);
Nvoid     DrvSYS_SetBODFunction(int32_t i32Enable, int32_t i32Mode, BOD_CALLBACK bodcallbackFn);
Nint32_t  DrvSYS_SetClockDivider(E_SYS_IP_DIV eIpDiv , int32_t i32value);
Nint32_t  DrvSYS_SetFreqDividerOutput(int32_t i32Flag, uint8_t u8Divider);
Nvoid     DrvSYS_SetIPClock(E_SYS_IP_CLK eIpClk, int32_t i32Enable);
Nint32_t  DrvSYS_SetOscCtrl(E_SYS_CHIP_CLKSRC eClkSrc, int32_t i32Enable);
Nvoid     DrvSYS_SetPLLContent(uint32_t u32PllContent);
Nvoid     DrvSYS_SetPLLMode(int32_t i32Flag);
Nvoid     DrvSYS_SetPowerDownWakeUpInt(int32_t i32Enable, PWRWU_CALLBACK pdwucallbackFn, int32_t i32enWUDelay);
N
Nint32_t  DrvSYS_UnlockProtectedReg(void);
N
N#endif
N
L 13 "Smpl_CAN.c" 2
N#include "Driver\DrvTIMER.h"
L 1 "..\..\..\Include\Driver\DrvTIMER.h" 1
N/*---------------------------------------------------------------------------------------------------------*/
N/*                                                                                                         */
N/* Copyright(c) 2009 Nuvoton Technology Corp. All rights reserved.                                         */
N/*                                                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#ifndef __DRVTIMER_H__
N#define __DRVTIMER_H__
N
N#include "NUC1xx.h"
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Macro, type and constant definitions                                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define Version number								                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define DRVTIMER_MAJOR_NUM      1
N#define DRVTIMER_MINOR_NUM      04
N#define DRVTIMER_BUILD_NUM      005
N#define DRVTIMER_VERSION_NUM    _SYSINFRA_VERSION(DRVTIMER_MAJOR_NUM, DRVTIMER_MINOR_NUM, DRVTIMER_BUILD_NUM)
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define Error Code	                                                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define E_DRVTIMER_CHANNEL          _SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVTIMER, 1)  /* Invalid channel     */
N#define E_DRVTIMER_CLOCK_RATE       _SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVTIMER, 2)  /* Invalid clock rate  */
N#define E_DRVTIMER_EIO              _SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVTIMER, 3)  /* Timer IO error      */
N#define E_DRVTIMER_EVENT_FULL       _SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVTIMER, 4)  /* Event Full error    */
N#define E_DRVWDT_CMD                _SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVTIMER, 5)  /* Invalid CMD         */
N#define E_DRVWDT_OPEN               _SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVTIMER, 6)  /* WDT open fail       */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Global interface variables declarations                                                                 */                                                                            
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef void (*TIMER_CALLBACK)(uint32_t data);	/* function pointer */
Ntypedef void (*WDT_CALLBACK)(uint32_t data);	/* function pointer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define TIME EVENT STRUCT                                                                                */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef struct timeEvent_t
N{
N    int32_t              active;
N    int32_t              initTick;
N    int32_t              curTick;
N    TIMER_CALLBACK       funPtr;
N    uint32_t             transParam;
N} TIMER_EVENT_T;
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define TIMER Channel                                                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef enum {
N    E_TMR0      = 0,
N    E_TMR1      = 1,
N	E_TMR2      = 2,
N	E_TMR3      = 3        
N} E_TIMER_CHANNEL;
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define TIMER OPREATION MODE                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef enum{                   
N    E_ONESHOT_MODE 		= 0,
N    E_PERIODIC_MODE   	= 1,
N    E_TOGGLE_MODE     	= 2, 
N	E_CONTINUOUS_MODE 	= 3     
N} E_TIMER_OPMODE ;
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define Timer Counter TX Phase                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef enum{                   
N    E_PHASE_FALLING     = 0,
N    E_PHASE_RISING      = 1,
N} E_TIMER_TX_PHASE ;
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define Timer Capture Detect Edge                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef enum{                   
N    E_EDGE_FALLING      = 0,
N    E_EDGE_RISING       = 1,
N    E_EDGE_BOTH         = 2,
N} E_TIMER_TEX_EDGE ;
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define Timer Reset or Capture                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef enum{                   
N    E_CAPTURE           = 0,
N    E_RESET             = 1,
N} E_TIMER_RSTCAP_MODE ;
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define WDT Ioctl Command                                                                                */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef enum {
N    E_WDT_IOC_START_TIMER       = 0,
N    E_WDT_IOC_STOP_TIMER        = 1,
N    E_WDT_IOC_ENABLE_INT        = 2,
N    E_WDT_IOC_DISABLE_INT       = 3,
N    E_WDT_IOC_ENABLE_WAKEUP     = 4, 
N    E_WDT_IOC_DISABLE_WAKEUP    = 5, 
N    E_WDT_IOC_RESET_TIMER       = 6,
N    E_WDT_IOC_ENABLE_RESET_FUNC = 7,
N    E_WDT_IOC_DISABLE_RESET_FUNC= 8,
N	E_WDT_IOC_SET_INTERVAL      = 9
N} E_WDT_CMD; 
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define WDT INTERVAL                                                                                     */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef enum{
N    E_WDT_LEVEL0      = 0,         /* 2^4 WDT_CLK	                                                           */
N    E_WDT_LEVEL1      = 1,         /* 2^6 WDT_CLK                                                            */
N    E_WDT_LEVEL2      = 2,         /* 2^8 WDT_CLK                                                            */ 
N    E_WDT_LEVEL3      = 3,         /* 2^10 WDT_CLK                                                           */
N	E_WDT_LEVEL4      = 4,         /* 2^12 WDT_CLK                                                           */
N	E_WDT_LEVEL5      = 5,         /* 2^14 WDT_CLK                                                           */
N	E_WDT_LEVEL6      = 6,         /* 2^16 WDT_CLK                                                           */
N	E_WDT_LEVEL7      = 7          /* 2^18 WDT_CLK                                                           */
N} E_WDT_INTERVAL;
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define Function Prototype                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
Nvoid DrvTIMER_Init(void);
Nint32_t DrvTIMER_Open(E_TIMER_CHANNEL ch, uint32_t uTicksPerSecond, E_TIMER_OPMODE op_mode);
Nint32_t DrvTIMER_Close(E_TIMER_CHANNEL ch);
Nint32_t DrvTIMER_SetTimerEvent(E_TIMER_CHANNEL ch, uint32_t uInterruptTicks, TIMER_CALLBACK pTimerCallback, uint32_t parameter);
Nvoid DrvTIMER_ClearTimerEvent(E_TIMER_CHANNEL ch, uint32_t uTimerEventNo);
Nint32_t DrvTIMER_EnableInt(E_TIMER_CHANNEL ch);
Nint32_t DrvTIMER_DisableInt(E_TIMER_CHANNEL ch);
Nint32_t DrvTIMER_GetIntFlag(E_TIMER_CHANNEL ch);
Nint32_t DrvTIMER_ClearIntFlag(E_TIMER_CHANNEL ch);
Nint32_t DrvTIMER_Start(E_TIMER_CHANNEL ch);
Nuint32_t DrvTIMER_GetIntTicks(E_TIMER_CHANNEL ch);
Nint32_t DrvTIMER_ResetIntTicks(E_TIMER_CHANNEL ch);
Nvoid DrvTIMER_Delay(E_TIMER_CHANNEL ch, uint32_t uTicks);
Nint32_t DrvTIMER_OpenCounter(E_TIMER_CHANNEL ch, uint32_t uCounterBoundary, E_TIMER_OPMODE op_mode);
Nint32_t DrvTIMER_StartCounter(E_TIMER_CHANNEL ch);
Nuint32_t DrvTIMER_GetCounters(E_TIMER_CHANNEL ch);
Nint32_t DrvTIMER_OpenCapture(E_TIMER_CHANNEL ch, E_TIMER_RSTCAP_MODE mode);
Nint32_t DrvTIMER_CloseCapture(E_TIMER_CHANNEL ch);
Nint32_t DrvTIMER_SelectExternalMode(E_TIMER_CHANNEL ch, E_TIMER_RSTCAP_MODE mode);
Nint32_t DrvTIMER_SelectCaptureEdge(E_TIMER_CHANNEL ch, E_TIMER_TEX_EDGE edge);
Nint32_t DrvTIMER_EnableCaptureInt(E_TIMER_CHANNEL ch);
Nint32_t DrvTIMER_DisableCaptureInt(E_TIMER_CHANNEL ch);
Nint32_t DrvTIMER_EnableCapture(E_TIMER_CHANNEL ch);
Nint32_t DrvTIMER_DisableCapture(E_TIMER_CHANNEL ch);
Nuint32_t DrvTIMER_GetCaptureData(E_TIMER_CHANNEL ch);
Nint32_t DrvTIMER_GetCaptureIntFlag(E_TIMER_CHANNEL ch);
Nint32_t DrvTIMER_ClearCaptureIntFlag(E_TIMER_CHANNEL ch);
Nint32_t DrvTIMER_EnableCaptureDebounce(E_TIMER_CHANNEL ch);
Nint32_t DrvTIMER_DisableCaptureDebounce(E_TIMER_CHANNEL ch);
Nint32_t DrvTIMER_EnableCounterDebounce(E_TIMER_CHANNEL ch);
Nint32_t DrvTIMER_DisableCounterDebounce(E_TIMER_CHANNEL ch);
Nint32_t DrvTIMER_SelectCounterDetectPhase(E_TIMER_CHANNEL ch, E_TIMER_TX_PHASE phase);
Nuint32_t DrvTIMER_GetVersion(void);
N
Nint32_t DrvWDT_Open(E_WDT_INTERVAL WDTlevel);
Nvoid DrvWDT_Close(void);
Nvoid DrvWDT_InstallISR(WDT_CALLBACK pvWDTISR);
Nint32_t DrvWDT_Ioctl(E_WDT_CMD uWDTCmd, uint32_t uArgument);
N
N#endif	// __DRVTIMER_H__
N
N
N
L 14 "Smpl_CAN.c" 2
N#include "Driver\DrvUART.h"
L 1 "..\..\..\Include\Driver\DrvUART.h" 1
N/*---------------------------------------------------------------------------------------------------------*/
N/*                                                                                                         */
N/* Copyright(c) 2009 Nuvoton Technology Corp. All rights reserved.                                         */
N/*                                                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#ifndef __DRVUART_H__
N#define __DRVUART_H__
N
N#include "NUC1xx.h"
N
N#ifdef  __cplusplus
Sextern "C"
S{
N#endif
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define Version number								                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define DRVUART_MAJOR_NUM	1
N#define DRVUART_MINOR_NUM	02
N#define DRVUART_BUILD_NUM	003
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Version define with SysInfra				                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define DRVUART_VERSION_NUM     _SYSINFRA_VERSION(DRVUART_MAJOR_NUM, DRVUART_MINOR_NUM, DRVUART_BUILD_NUM)
N							   
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define Error Code									                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N// E_DRVUART_ERR_TIMEOUT  				Time out
N// E_DRVUART_ERR_PORT_INVALID		 	Wrong port
N// E_DRVUART_ERR_PARITY_INVALID			Wrong party setting
N// E_DRVUART_ERR_DATA_BITS_INVALID		Wrong Data bit setting
N// E_DRVUART_ERR_STOP_BITS_INVALID		Wrong Stop bit setting
N// E_DRVUART_ERR_TRIGGERLEVEL_INVALID	Wrong trigger level setting
N// E_DRVUART_ARGUMENT                	Wrong Argument (Wrong UART Port)
N#define E_DRVUART_ERR_TIMEOUT   			_SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVUART, 1)
N#define E_DRVUART_ERR_PORT_INVALID		   	_SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVUART, 2)
N#define E_DRVUART_ERR_PARITY_INVALID   		_SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVUART, 3)
N#define E_DRVUART_ERR_DATA_BITS_INVALID 	_SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVUART, 4)
N#define E_DRVUART_ERR_STOP_BITS_INVALID   	_SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVUART, 5)
N#define E_DRVUART_ERR_TRIGGERLEVEL_INVALID  _SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVUART, 6)
N#define E_DRVUART_ARGUMENT                  _SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVUART, 7)
N#define E_DRVUART_ERR_OPEN                  _SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVUART, 8)
N
N      
Ntypedef void (PFN_DRVUART_CALLBACK)(uint32_t userData);
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define UART Macro		                                                                         	   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define _DRVUART_SENDBYTE(u32Port,byData)					outp32(UART0_BASE + u32Port, (byData))
N#define _DRVUART_RECEIVEBYTE(u32Port)						inp32(UART0_BASE + u32Port)
N#define _DRVUART_SET_DIVIDER(u32Port,u16Divider)			outp32(&UART0->BAUD + u32Port,(0x3<<28)|(u16Divider))    /* Using Mode3 */
N#define _DRVUART_RECEIVEAVAILABLE(u32Port)					(inp32(&UART0->FSR + u32Port) & 0x3F00)>>8
N#define _DRVUART_WAIT_TX_EMPTY(u32Port)			        	(inp32(&UART0->FSR + u32Port) & (1<<28))>>28
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define IRDA / LIN  Operation direction                                                           	   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define MODE_TX  1
N#define MODE_RX  2
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define UART enum      	                                                                         	   */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define UART Channel Sturcture                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N
Ntypedef enum 
N{
N	UART_PORT0 = 0x000, 
N	UART_PORT1 = 0x100000,
N	UART_PORT2 = 0x104000
N} E_UART_PORT;
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* define UART line status control			                                                         	   */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef enum 
N{
N	 DRVUART_LININT   	=    BIT8,	    /* LIN RX Break Field Detected Interrupt */
X	 DRVUART_LININT   	=    0x00000100,	     
N	 DRVUART_WAKEUPINT	=	 BIT6,		/* Wake up interrupt */
X	 DRVUART_WAKEUPINT	=	 0x00000040,		 
N     DRVUART_BUFERRINT  =	 BIT5,		/* Buffer Error Interrupt */
X     DRVUART_BUFERRINT  =	 0x00000020,		 
N     DRVUART_TOUTINT   	=	 BIT4,	    /* RX Time out Interrupt */
X     DRVUART_TOUTINT   	=	 0x00000010,	     
N	 DRVUART_MOSINT   	=	 BIT3,	    /* MODEM Status Interrupt */
X	 DRVUART_MOSINT   	=	 0x00000008,	     
N	 DRVUART_RLSINT   	=	 BIT2,	    /* Receive Line Status Interrupt*/
X	 DRVUART_RLSINT   	=	 0x00000004,	     
N	 DRVUART_THREINT   	=	 BIT1,	    /* Transmit Holding Register Empty Interrupt */
X	 DRVUART_THREINT   	=	 0x00000002,	     
N	 DRVUART_RDAINT   	=	 BIT0		/* Receive Data Available Interrupt */
X	 DRVUART_RDAINT   	=	 0x00000001		 
N} E_INT_SOURCE;
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* DATA BIT                                                                                                */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef enum 
N{
N	 DRVUART_DATABITS_5   =    0x0,
N	 DRVUART_DATABITS_6	  =	   0x1,
N     DRVUART_DATABITS_7   =	   0x2,
N     DRVUART_DATABITS_8   =	   0x3
N
N} E_DATABITS_SETTINS;
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* PARITY Setting                                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N
Ntypedef enum 
N{
N	 DRVUART_PARITY_NONE   =    0x0,
N	 DRVUART_PARITY_ODD	   =	0x1,
N     DRVUART_PARITY_EVEN   =	0x3,
N     DRVUART_PARITY_MARK   =	0x5,
N     DRVUART_PARITY_SPACE  =	0x7
N} E_PARITY_SETTINS;
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* STOP BIT                                                                                                */
N/*---------------------------------------------------------------------------------------------------------*/
N
Ntypedef enum 
N{
N	 DRVUART_STOPBITS_1  	=   0x0,
N	 DRVUART_STOPBITS_1_5	=   0x1,
N     DRVUART_STOPBITS_2   	=   0x1
N} E_STOPBITS_SETTINS;
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* FIFO Select                                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef enum 
N{
N	DRVUART_FIFO_1BYTES 	= 0x0, 
N	DRVUART_FIFO_4BYTES 	= 0x1,
N	DRVUART_FIFO_8BYTES 	= 0x2,
N	DRVUART_FIFO_14BYTES 	= 0x3,
N	DRVUART_FIFO_30BYTES 	= 0x4,
N	DRVUART_FIFO_46BYTES 	= 0x5,
N	DRVUART_FIFO_62BYTES 	= 0x6
N} E_FIFO_SETTINGS;
N
N
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Function Selection                                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N
Ntypedef enum 
N{
N	FUN_UART 	= 0, 
N	FUN_LIN 	= 1,
N	FUN_IRCR 	= 2,
N	FUN_RS485 	= 3
N} E_UART_FUNC;
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define RS485 operation mode                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N
Ntypedef enum 
N{
N	MODE_RS485_NMM = 1, 
N	MODE_RS485_AAD = 2,
N	MODE_RS485_AUD = 4
N} E_MODE_RS485;
N									
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define UART data structure                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N
Ntypedef struct DRVUART_STRUCT
N{
N    uint32_t            u32BaudRate;
N    E_DATABITS_SETTINS  u8cDataBits;
N    E_STOPBITS_SETTINS  u8cStopBits;
N    E_PARITY_SETTINS 	u8cParity;
N    E_FIFO_SETTINGS     u8cRxTriggerLevel;
N    uint8_t             u8TimeOut ;
N}STR_UART_T;
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define IRDA data structure                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N
Ntypedef struct IRCR_STRUCT
N{
N    uint8_t   	    u8cTXSelect;
N    uint8_t			u8cInvTX;
N    uint8_t	        u8cInvRX;
N}STR_IRCR_T;
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define RS485 Setting structure                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N
Ntypedef struct RS485_STRUCT
N{
N    uint8_t   	    u8cModeSelect;
N    uint8_t			u8cAddrEnable;
N    uint8_t	        u8cAddrValue;
N	uint8_t	        u8cDelayTime;
N	uint8_t	        u8cRxDisable;
N}STR_RS485_T;
N
N
N 
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define UART functions prototype                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
Nvoid DrvUART_Close(E_UART_PORT u32Port);
Nvoid DrvUART_EnableInt(E_UART_PORT u32Port,uint32_t u32InterruptFlag,PFN_DRVUART_CALLBACK pfncallback);
Nvoid DrvUART_DisableInt(E_UART_PORT u32Port,uint32_t u32InterruptFlag);
Nvoid DrvUART_GetClcok(uint8_t *pu8ClcokSrc, uint8_t *pu8ClcokDiv);
Nvoid DrvUART_GetCTSInfo(E_UART_PORT u32Port,uint8_t *pu8CTSValue,uint8_t *pu8CTSChangeState);
Nvoid DrvUART_SetClcok(uint8_t u8ClcokSrc, uint8_t u8ClcokDiv);
Nvoid DrvUART_SetRTSTrigLevel(E_UART_PORT u32Port,uint16_t u16TriggerLevel);
Nvoid DrvUART_SetRTS(E_UART_PORT u32Port,uint8_t u8Value,uint16_t u16TriggerLevel);
N
Nint32_t DrvUART_Write(E_UART_PORT u32Port,uint8_t *pu8TxBuf,uint32_t u32WriteBytes);
Nint32_t DrvUART_Read(E_UART_PORT u32Port,uint8_t *pu8RxBuf,uint32_t	u32ReadBytes);
Nint32_t DrvUART_Open(E_UART_PORT u32Port, STR_UART_T *sParam);
Nint32_t DrvUART_GetIntStatus(E_UART_PORT u32Port,uint32_t u32InterruptFlag);
Nint32_t DrvUART_GetVersion(void);
N
Nuint32_t DrvUART_ClearIntFlag(E_UART_PORT u32Port,uint32_t u32InterruptFlag);
Nvoid DrvUART_EnablePDMA(E_UART_PORT u32Port);
Nvoid DrvUART_DisalbePDMA(E_UART_PORT u32Port);
N
Nvoid DrvUART_SetFnIRDA(E_UART_PORT u32Port,STR_IRCR_T *str_IRCR );
Nvoid DrvUART_SetFnLIN(E_UART_PORT u32Port,uint16_t u16Mode,uint16_t u16BreakLength);
Nvoid DrvUART_SetFnRS485(E_UART_PORT u32Port,STR_RS485_T *str_RS485);
N#ifdef  __cplusplus
S}
N#endif
N
N#endif
N
N
N
N
N
N
N
N
N
N
N
L 15 "Smpl_CAN.c" 2
N#include "Driver\DrvADC.h"
L 1 "..\..\..\Include\Driver\DrvADC.h" 1
N/*---------------------------------------------------------------------------------------------------------*/
N/*                                                                                                         */
N/* Copyright(c) 2009 Nuvoton Technology Corp. All rights reserved.                                         */
N/*                                                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#ifndef __DRVADC_H__
N#define __DRVADC_H__
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Include related headers                                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#include "NUC1xx.h"
N#include "System/SysInfra.h"
N
N/* Address definition */
N#define ADC_ADSR             (ADC_BASE       + 0x30)
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Macro, type and constant definitions                                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N/* version definition with SysInfra */
N#define	DRVADC_MAJOR_NUM 1
N#define	DRVADC_MINOR_NUM 03
N#define	DRVADC_BUILD_NUM 002
N#define DRVADC_VERSION_NUM    _SYSINFRA_VERSION(DRVADC_MAJOR_NUM, DRVADC_MINOR_NUM, DRVADC_BUILD_NUM)
N
N/* error code definition */
N#define E_DRVADC_ARGUMENT     _SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVADC, 1)
N
Ntypedef enum {ADC_SINGLE_END, ADC_DIFFERENTIAL} E_ADC_INPUT_MODE;
Ntypedef enum {ADC_SINGLE_OP, ADC_SINGLE_CYCLE_OP, ADC_CONTINUOUS_OP} E_ADC_OPERATION_MODE;
Ntypedef enum {EXTERNAL_12MHZ=0, INTERNAL_PLL=1, INTERNAL_HCLK=2, INTERNAL_RC22MHZ=3} E_ADC_CLK_SRC;
Ntypedef enum {LOW_LEVEL=0, HIGH_LEVEL=1, FALLING_EDGE=2, RISING_EDGE=3} E_ADC_EXT_TRI_COND;
Ntypedef enum {EXTERNAL_INPUT_SIGNAL, INTERNAL_BANDGAP, INTERNAL_TEMPERATURE_SENSOR} E_ADC_CH7_SRC;
Ntypedef enum {LESS_THAN, GREATER_OR_EQUAL} E_ADC_CMP_CONDITION;
Ntypedef enum {UNSIGNED_OUTPUT, TWOS_COMPLEMENT} E_ADC_DIFF_MODE_OUTPUT_FORMAT;
N
Ntypedef void (DRVADC_ADC_CALLBACK)(uint32_t u32UserData);
Ntypedef void (DRVADC_ADCMP0_CALLBACK)(uint32_t u32UserData);
Ntypedef void (DRVADC_ADCMP1_CALLBACK)(uint32_t u32UserData);
N
N#define _DRVADC_CONV() (ADC->ADCR.ADST=1)
N#define _DRVADC_GET_ADC_INT_FLAG() ADC->ADSR.ADF
N#define _DRVADC_GET_CMP0_INT_FLAG() ADC->ADSR.CMPF0
N#define _DRVADC_GET_CMP1_INT_FLAG() ADC->ADSR.CMPF1
N#define _DRVADC_CLEAR_ADC_INT_FLAG() (outpw(ADC_ADSR, (inpw(ADC_ADSR)&(~0x7))|0x1))
N#define _DRVADC_CLEAR_CMP0_INT_FLAG() (outpw(ADC_ADSR, (inpw(ADC_ADSR)&(~0x7))|0x2))
N#define _DRVADC_CLEAR_CMP1_INT_FLAG() (outpw(ADC_ADSR, (inpw(ADC_ADSR)&(~0x7))|0x4))
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define Function Prototypes                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
Nvoid DrvADC_Open(E_ADC_INPUT_MODE InputMode, E_ADC_OPERATION_MODE OpMode, uint8_t u8ChannelSelBitwise, E_ADC_CLK_SRC ClockSrc, uint8_t u8AdcDivisor);
Nvoid DrvADC_Close(void);
Nvoid DrvADC_SetADCChannel(uint8_t u8ChannelSelBitwise);
Nvoid DrvADC_ConfigADCChannel7(E_ADC_CH7_SRC Ch7Src);
Nvoid DrvADC_SetADCInputMode(E_ADC_INPUT_MODE InputMode);
Nvoid DrvADC_SetADCOperationMode(E_ADC_OPERATION_MODE OpMode);
Nvoid DrvADC_SetADCClkSrc(E_ADC_CLK_SRC ClockSrc);
Nvoid DrvADC_SetADCDivisor(uint8_t u8AdcDivisor);
Nvoid DrvADC_EnableADCInt(DRVADC_ADC_CALLBACK callback, uint32_t u32UserData);
Nvoid DrvADC_DisableADCInt(void);
Nvoid DrvADC_EnableADCCmp0Int(DRVADC_ADCMP0_CALLBACK callback, uint32_t u32UserData);
Nvoid DrvADC_DisableADCCmp0Int(void);
Nvoid DrvADC_EnableADCCmp1Int(DRVADC_ADCMP1_CALLBACK callback, uint32_t u32UserData);
Nvoid DrvADC_DisableADCCmp1Int(void);
Nuint32_t DrvADC_GetConversionRate(void);
Nvoid DrvADC_EnableExtTrigger(E_ADC_EXT_TRI_COND TriggerCondition);
Nvoid DrvADC_DisableExtTrigger(void);
Nvoid DrvADC_StartConvert(void);
Nvoid DrvADC_StopConvert(void);
Nuint32_t DrvADC_IsConversionDone(void);
Nint32_t DrvADC_GetConversionData(uint8_t u8ChannelNum);
Nvoid DrvADC_EnablePDMA(void);
Nvoid DrvADC_DisablePDMA(void);
Nuint32_t DrvADC_IsDataValid(uint8_t u8ChannelNum);
Nuint32_t DrvADC_IsDataOverrun(uint8_t u8ChannelNum);
Nint32_t DrvADC_EnableADCCmp0(uint8_t u8CmpChannelNum, E_ADC_CMP_CONDITION CmpCondition, uint16_t u16CmpData, uint8_t CmpMatchCount);
Nint32_t DrvADC_EnableADCCmp1(uint8_t u8CmpChannelNum, E_ADC_CMP_CONDITION CmpCondition, uint16_t u16CmpData, uint8_t CmpMatchCount);
Nvoid DrvADC_DisableADCCmp0(void);
Nvoid DrvADC_DisableADCCmp1(void);
Nvoid DrvADC_EnableSelfCalibration(void);
Nuint32_t DrvADC_IsCalibrationDone(void);
Nvoid DrvADC_DisableSelfCalibration(void);
Nvoid DrvADC_DiffModeOutputFormat(E_ADC_DIFF_MODE_OUTPUT_FORMAT OutputFormat);
Nuint32_t DrvADC_GetVersion (void);
N
N#endif
L 16 "Smpl_CAN.c" 2
N#include "LCD_Driver.h"
L 1 "..\..\..\Include\NUC1xx-LB_002\LCD_Driver.h" 1
N#ifndef __LCD_Driver_H__
N#define __LCD_Driver_H__
N     
Nextern void SysTimerDelay(uint32_t us);
Nextern void Initial_pannel(void);
Nextern void Disable_Buzzer(void);
N
Nextern void Show_Word(unsigned char x, unsigned char y,unsigned char ascii_word);
N
Nextern void print_lcd(unsigned char line, char *str);
N
N
Nextern void clr_all_pannal(void);
N#endif
L 17 "Smpl_CAN.c" 2
N#include "Driver\DrvI2C.h"
L 1 "..\..\..\Include\Driver\DrvI2C.h" 1
N/*---------------------------------------------------------------------------------------------------------*/
N/*                                                                                                         */
N/* Copyright(c) 2009 Nuvoton Technology Corp. All rights reserved.                                         */
N/*                                                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#ifndef _DRVI2C_H
N#define _DRVI2C_H
N
N#include "NUC1xx.h"
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define Version number                                                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
N#define DRVI2C_MAJOR_NUM    1
N#define DRVI2C_MINOR_NUM    02
N#define DRVI2C_BUILD_NUM    2
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Version define with SysInfra                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define DRVI2C_VERSION_NUM     _SYSINFRA_VERSION(DRVI2C_MAJOR_NUM, DRVI2C_MINOR_NUM, DRVI2C_BUILD_NUM)
N                               
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define Error Code                                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N// E_DRVI2C_ERR_ARGUMENT        Incorrect Argument
N#define E_DRVI2C_ERR_ARGUMENT   _SYSINFRA_ERRCODE(TRUE, MODULE_ID_DRVI2C, 1)
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  I2C port                                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef enum 
N{
N    I2C_PORT0 = 0,
N    I2C_PORT1 = 1
N} E_I2C_PORT;
N
Ntypedef void (*I2C_CALLBACK)(uint32_t status);
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define I2C Call back function type                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef enum
N{
N    I2CFUNC   = 0,
N    ARBITLOSS = 1,
N    BUSERROR  = 2,
N    TIMEOUT   = 3
N} E_I2C_CALLBACK_TYPE;
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define I2C Call back function Data Struct                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef struct
N{
N    I2C_CALLBACK    I2CCallBackFn;
N    I2C_CALLBACK    ArbitLossCallBackFn;
N    I2C_CALLBACK    BusErrCallBackFn;
N    I2C_CALLBACK    TimeoutCallBackFn;
N
N} I2C_CALLBACK_T;
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define I2C functions prototype                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
Nvoid     DrvI2C_ClearIntFlag(E_I2C_PORT port);
Nvoid     DrvI2C_ClearTimeoutFlag(E_I2C_PORT port);
Nint32_t  DrvI2C_Close(E_I2C_PORT port);
Nvoid     DrvI2C_Ctrl(E_I2C_PORT port, uint8_t start, uint8_t stop, uint8_t intFlag, uint8_t ack);
N
Nint32_t  DrvI2C_DisableInt(E_I2C_PORT port);
N
Nint32_t  DrvI2C_EnableInt(E_I2C_PORT port);
N
Nuint32_t DrvI2C_GetClockFreq(E_I2C_PORT port);
Nuint8_t  DrvI2C_GetIntFlag(E_I2C_PORT port);
Nuint32_t DrvI2C_GetStatus(E_I2C_PORT port);
Nuint32_t DrvI2C_GetVersion(void);
N
Nint32_t  DrvI2C_InstallCallback(E_I2C_PORT port, E_I2C_CALLBACK_TYPE Type, I2C_CALLBACK callbackfn);
N
Nint32_t  DrvI2C_Open(E_I2C_PORT port, uint32_t u32BusClock);
N
Nuint8_t  DrvI2C_ReadData(E_I2C_PORT port);
N
Nint32_t  DrvI2C_SetAddress(E_I2C_PORT port, uint8_t slaveNo, uint8_t slave_addr, uint8_t GC_Flag);
Nint32_t  DrvI2C_SetAddressMask(E_I2C_PORT port, uint8_t slaveNo, uint8_t slaveAddrMask);
Nint32_t  DrvI2C_SetClockFreq(E_I2C_PORT port, uint32_t u32BusClock);
Nint32_t  DrvI2C_SetTimeoutCounter(E_I2C_PORT port, int32_t i32enable, uint8_t u8div4);
N
Nint32_t  DrvI2C_UninstallCallBack(E_I2C_PORT port, E_I2C_CALLBACK_TYPE Type);
N
Nvoid     DrvI2C_WriteData(E_I2C_PORT port, uint8_t u8data);
N
N#endif
N
L 18 "Smpl_CAN.c" 2
N#define	STE_DATA_READ	DrvGPIO_set(E_IO_INPUT);
N#define	STE_DATA_WRITE	DrvGPIO_set(E_IO_OUTPUT);
N#define Rd(address)		((address<<1) | 0x01)
N#define Wr(address)		((address<<1) & 0xFE)
N#define Da(Data)		(Data & 0xFF)
N/////////////////MPU9250
N#define MPU   0x68
N#define XG_OFFSET_H      0x13  // User-defined trim values for gyroscope
N#define XG_OFFSET_L      0x14
N#define YG_OFFSET_H      0x15
N#define YG_OFFSET_L      0x16
N#define ZG_OFFSET_H      0x17
N#define ZG_OFFSET_L      0x18
N#define SMPLRT_DIV       0x19
N#define CONFIG           0x1A
N#define GYRO_CONFIG      0x1B
N#define ACCEL_CONFIG     0x1C
N#define ACCEL_CONFIG2    0x1D
N#define LP_ACCEL_ODR     0x1E   
N#define WOM_THR          0x1F   
N#define MOT_DUR          0x20  // Duration counter threshold for motion interrupt generation, 1 kHz rate, LSB = 1 ms
N#define ZMOT_THR         0x21  // Zero-motion detection threshold bits [7:0]
N#define ZRMOT_DUR        0x22  // Duration counter threshold for zero motion interrupt generation, 16 Hz rate, LSB = 64 ms
N#define FIFO_EN          0x23
N#define I2C_MST_CTRL     0x24   
N#define I2C_SLV0_ADDR    0x25
N#define I2C_SLV0_REG     0x26
N#define I2C_SLV0_CTRL    0x27
N#define I2C_SLV1_ADDR    0x28
N#define I2C_SLV1_REG     0x29
N#define I2C_SLV1_CTRL    0x2A
N#define I2C_SLV2_ADDR    0x2B
N#define I2C_SLV2_REG     0x2C
N#define I2C_SLV2_CTRL    0x2D
N#define I2C_SLV3_ADDR    0x2E
N#define I2C_SLV3_REG     0x2F
N#define I2C_SLV3_CTRL    0x30
N#define I2C_SLV4_ADDR    0x31
N#define I2C_SLV4_REG     0x32
N#define I2C_SLV4_DO      0x33
N#define I2C_SLV4_CTRL    0x34
N#define I2C_SLV4_DI      0x35
N#define I2C_MST_STATUS   0x36
N#define INT_PIN_CFG      0x37
N#define INT_ENABLE       0x38
N#define DMP_INT_STATUS   0x39  // Check DMP interrupt
N#define INT_STATUS       0x3A
N#define ACCEL_XOUT_H     0x3B
N#define ACCEL_XOUT_L     0x3C
N#define ACCEL_YOUT_H     0x3D
N#define ACCEL_YOUT_L     0x3E
N#define ACCEL_ZOUT_H     0x3F
N#define ACCEL_ZOUT_L     0x40
N#define TEMP_OUT_H       0x41
N#define TEMP_OUT_L       0x42
N#define GYRO_XOUT_H      0x43
N#define GYRO_XOUT_L      0x44
N#define GYRO_YOUT_H      0x45
N#define GYRO_YOUT_L      0x46
N#define GYRO_ZOUT_H      0x47
N#define GYRO_ZOUT_L      0x48
N#define EXT_SENS_DATA_00 0x49
N#define EXT_SENS_DATA_01 0x4A
N#define EXT_SENS_DATA_02 0x4B
N#define EXT_SENS_DATA_03 0x4C
N#define EXT_SENS_DATA_04 0x4D
N#define EXT_SENS_DATA_05 0x4E
N#define EXT_SENS_DATA_06 0x4F
N#define EXT_SENS_DATA_07 0x50
N#define EXT_SENS_DATA_08 0x51
N#define EXT_SENS_DATA_09 0x52
N#define EXT_SENS_DATA_10 0x53
N#define EXT_SENS_DATA_11 0x54
N#define EXT_SENS_DATA_12 0x55
N#define EXT_SENS_DATA_13 0x56
N#define EXT_SENS_DATA_14 0x57
N#define EXT_SENS_DATA_15 0x58
N#define EXT_SENS_DATA_16 0x59
N#define EXT_SENS_DATA_17 0x5A
N#define EXT_SENS_DATA_18 0x5B
N#define EXT_SENS_DATA_19 0x5C
N#define EXT_SENS_DATA_20 0x5D
N#define EXT_SENS_DATA_21 0x5E
N#define EXT_SENS_DATA_22 0x5F
N#define EXT_SENS_DATA_23 0x60
N#define MOT_DETECT_STATUS 0x61
N#define I2C_SLV0_DO      0x63
N#define I2C_SLV1_DO      0x64
N#define I2C_SLV2_DO      0x65
N#define I2C_SLV3_DO      0x66
N#define I2C_MST_DELAY_CTRL 0x67
N#define SIGNAL_PATH_RESET  0x68
N#define MOT_DETECT_CTRL  0x69
N#define USER_CTRL        0x6A  // Bit 7 enable DMP, bit 3 reset DMP
N#define PWR_MGMT_1       0x6B // Device defaults to the SLEEP mode
N#define PWR_MGMT_2       0x6C
N#define DMP_BANK         0x6D  // Activates a specific bank in the DMP
N#define DMP_RW_PNT       0x6E  // Set read/write pointer to a specific start address in specified DMP bank
N#define DMP_REG          0x6F  // Register in DMP from which to read or to which to write
N#define DMP_REG_1        0x70
N#define DMP_REG_2        0x71 
N#define FIFO_COUNTH      0x72
N#define FIFO_COUNTL      0x73
N#define FIFO_R_W         0x74
N#define WHO_AM_I_MPU9250 0x75 // Should return 0x71
N#define XA_OFFSET_H      0x77
N#define XA_OFFSET_L      0x78
N#define YA_OFFSET_H      0x7A
N#define YA_OFFSET_L      0x7B
N#define ZA_OFFSET_H      0x7D
N#define ZA_OFFSET_L      0x7E
Nint16_t accelCount[3];  // Stores the 16-bit signed accelerometer sensor output
Nfloat gyroBias[3] = {0, 0, 0};// Bias corrections for gyro and accelerometer
Nfloat accelBias[3] = {0, 0, 0}; 
N
Nvoid ADC_initialize (void)
N{
N	DrvADC_Open(ADC_SINGLE_END,ADC_SINGLE_CYCLE_OP,0x17,EXTERNAL_12MHZ,0x9);   //  0x17 adc0,1,2,4   00010111
N	DrvSYS_Delay(100); 
N}
N
Nstatic int32_t ADC_average (int32_t *ADC_value)  
N{
N	int32_t value[9] = {0};
N	uint8_t i,j,k;
N	int32_t value_max;
N	for (i=0; i<9; i++)
N	{
N		value[i] = *ADC_value++;
N	}
N	for (j=0; j<9; j++)
N	{
N		for (k=0; k<9-j; k++) 
N		{
N			if(k != 8)
N			{
N				if (value[k] > value[k+1]) 
N				{
N					value_max = value[k];
N					value[k] = value[k+1]; 
N					value[k+1] = value_max;
N				}
N			}
N		}
N	}
N	return (value[4]);
N}
N
Nstatic int32_t get_ADC_value(uint8_t ADC_channel_number)
N{
N	uint8_t i;
N	int32_t ADC_calibration[9]={0}; 
N	for (i=0; i<9; i++)
N	{
N		DrvADC_StartConvert(); 
N		while(!DrvADC_IsConversionDone()) 
N		{
N		}
N		ADC_calibration[i] = DrvADC_GetConversionData(ADC_channel_number); 
N		DrvADC_StopConvert(); 
N	}
N	return (ADC_average(ADC_calibration)); 
N}
N
Nvoid InitHCLK12M(void)
N{
N	UNLOCKREG();
X	*((volatile uint32_t *)(((( uint32_t)0x50000000) + 0x00000) + 0x100)) = 0x59;*((volatile uint32_t *)(((( uint32_t)0x50000000) + 0x00000) + 0x100)) = 0x16;*((volatile uint32_t *)(((( uint32_t)0x50000000) + 0x00000) + 0x100)) = 0x88;
N	//External 4~24 MHz High Speed Crystal Enable (writeprotectionbit)
N	SYSCLK->PWRCON.XTL12M_EN = 1;
X	((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->PWRCON.XTL12M_EN = 1;
N	//HCLK clock source select (write-protection bits)
N	//000 = Clock source from external 12 MHz
N	SYSCLK->CLKSEL0.HCLK_S = 0;
X	((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSEL0.HCLK_S = 0;
N	LOCKREG();
X	*((volatile uint32_t *)(((( uint32_t)0x50000000) + 0x00000) + 0x100)) = 0x00;;
N}
N
N////////////////////////////////////I2C/////////////////////////
N
Nvoid  writeByte(uint8_t addr ,uint8_t reg , uint8_t data)
N{
N	uint32_t i;
N	int count = 0;
N	//Open I2C1 and set clock = 50Kbps
N	SystemCoreClock = DrvSYS_GetHCLKFreq(); 
N	DrvI2C_Open(I2C_PORT1, 50000);
N	//send i2c start
N	DrvI2C_Ctrl(I2C_PORT1, 1, 0, 1, 1);	 	//set start
N	while (I2C1->I2CON.SI == 0);				//poll si flag
X	while (((I2C_T *) ((( uint32_t)0x40100000) + 0x20000))->I2CON.SI == 0);				
N	//send  addr command
N	I2C1->I2CDAT = addr<<1;		    	//write  addr   to
X	((I2C_T *) ((( uint32_t)0x40100000) + 0x20000))->I2CDAT = addr<<1;		    	
N	DrvI2C_Ctrl(I2C_PORT1, 0, 0, 1, 1);	   //clr si
N	while( I2C1->I2CON.SI == 0 );			   //poll si flag
X	while( ((I2C_T *) ((( uint32_t)0x40100000) + 0x20000))->I2CON.SI == 0 );			   
N	//send reg
N	I2C1->I2CDAT = reg;					//write  reg   to
X	((I2C_T *) ((( uint32_t)0x40100000) + 0x20000))->I2CDAT = reg;					
N	DrvI2C_Ctrl(I2C_PORT1, 0, 0, 1, 1); //clr si and set ack	
N	while( I2C1->I2CON.SI == 0 );			//poll si flag
X	while( ((I2C_T *) ((( uint32_t)0x40100000) + 0x20000))->I2CON.SI == 0 );			
N	//send data
N	I2C1->I2CDAT = data;					//write data to 
X	((I2C_T *) ((( uint32_t)0x40100000) + 0x20000))->I2CDAT = data;					
N	DrvI2C_Ctrl(I2C_PORT1, 0, 0, 1, 1); //clr si and set ack	
N	while( I2C1->I2CON.SI == 0 );			//poll si flag
X	while( ((I2C_T *) ((( uint32_t)0x40100000) + 0x20000))->I2CON.SI == 0 );			
N	//send i2c stop
N	DrvI2C_Ctrl(I2C_PORT1, 0, 1, 1, 0);    //clr si and set stop
N	while( I2C1->I2CON.STO){
X	while( ((I2C_T *) ((( uint32_t)0x40100000) + 0x20000))->I2CON.STO){
N		count++;
N		if(count>1000){
N			break;
N		}
N	}
N	for(i=0;i<60;i++);
N	DrvI2C_Close(I2C_PORT1);
N}
N
Nuint8_t readByte(uint8_t addr , uint8_t data)
N{
N	uint8_t value;
N	uint32_t i;
N	int count = 0;
N	//Open I2C1 and set clock = 50Kbps
N	SystemCoreClock = DrvSYS_GetHCLKFreq(); 
N	DrvI2C_Open(I2C_PORT1, 50000);
N	//send i2c start
N	DrvI2C_Ctrl(I2C_PORT1, 1, 0, 1, 1);	 	//set start
N	while (I2C1->I2CON.SI == 0);				//poll si flag
X	while (((I2C_T *) ((( uint32_t)0x40100000) + 0x20000))->I2CON.SI == 0);				
N	//send writer command
N	I2C1->I2CDAT = addr<<1;
X	((I2C_T *) ((( uint32_t)0x40100000) + 0x20000))->I2CDAT = addr<<1;
N	DrvI2C_Ctrl(I2C_PORT1, 0, 0, 1, 1);	   //clr si
N	while( I2C1->I2CON.SI == 0 );			   //poll si flag
X	while( ((I2C_T *) ((( uint32_t)0x40100000) + 0x20000))->I2CON.SI == 0 );			   
N	//send data
N	I2C1->I2CDAT = data;					//write data to 
X	((I2C_T *) ((( uint32_t)0x40100000) + 0x20000))->I2CDAT = data;					
N	DrvI2C_Ctrl(I2C_PORT1, 0, 0, 1, 1); //clr si and set ack	
N	while( I2C1->I2CON.SI == 0 );			//poll si flag
X	while( ((I2C_T *) ((( uint32_t)0x40100000) + 0x20000))->I2CON.SI == 0 );			
N	//send i2c start
N	DrvI2C_Ctrl(I2C_PORT1, 1, 0, 1, 1);	 	//set start
N	while (I2C1->I2CON.SI == 0);				//poll si flag
X	while (((I2C_T *) ((( uint32_t)0x40100000) + 0x20000))->I2CON.SI == 0);				
N	//send writer command
N	I2C1->I2CDAT = (addr<<1)+1;
X	((I2C_T *) ((( uint32_t)0x40100000) + 0x20000))->I2CDAT = (addr<<1)+1;
N	DrvI2C_Ctrl(I2C_PORT1, 0, 0, 1, 1);	   //clr si
N	while( I2C1->I2CON.SI == 0 );			   //poll si flag
X	while( ((I2C_T *) ((( uint32_t)0x40100000) + 0x20000))->I2CON.SI == 0 );			   
N	//resive data
N	I2C1->I2CDAT = 0XFF;
X	((I2C_T *) ((( uint32_t)0x40100000) + 0x20000))->I2CDAT = 0XFF;
N	DrvI2C_Ctrl(I2C_PORT1, 0, 0, 1, 1);    //clr si	
N	while( I2C1->I2CON.SI == 0 );			   //poll si flag
X	while( ((I2C_T *) ((( uint32_t)0x40100000) + 0x20000))->I2CON.SI == 0 );			   
N	value= I2C1->I2CDAT;
X	value= ((I2C_T *) ((( uint32_t)0x40100000) + 0x20000))->I2CDAT;
N	//send i2c stop
N	DrvI2C_Ctrl(I2C_PORT1, 0, 1, 1, 0);    //clr si and set stop
N	while( I2C1->I2CON.STO){
X	while( ((I2C_T *) ((( uint32_t)0x40100000) + 0x20000))->I2CON.STO){
N		count++;
N		if(count>1000)  break;
N	}
N	for(i=0;i<60;i++);
N	DrvI2C_Close(I2C_PORT1);
N	return value;
N}
N
Nvoid initMPU9250()
N{  
N	uint8_t c;
N	writeByte(MPU, PWR_MGMT_1, 0x00); 
X	writeByte(0x68, 0x6B, 0x00); 
N	DrvSYS_Delay(100000);
N
N	writeByte(MPU, PWR_MGMT_1, 0x01);  
X	writeByte(0x68, 0x6B, 0x01);  
N	writeByte(MPU, CONFIG, 0x03);  
X	writeByte(0x68, 0x1A, 0x03);  
N
N	writeByte(MPU, SMPLRT_DIV, 0x04);  
X	writeByte(0x68, 0x19, 0x04);  
N	c = readByte(MPU, GYRO_CONFIG); 
X	c = readByte(0x68, 0x1B); 
N	c = c & ~0x02; 
N	c = c & ~0x18; 
N	writeByte(MPU, GYRO_CONFIG, c ); 
X	writeByte(0x68, 0x1B, c ); 
N	c = readByte(MPU, ACCEL_CONFIG); 
X	c = readByte(0x68, 0x1C); 
N	c = c & ~0x18; 
N	writeByte(MPU, ACCEL_CONFIG, c); 
X	writeByte(0x68, 0x1C, c); 
N	c = readByte(MPU, ACCEL_CONFIG2); 
X	c = readByte(0x68, 0x1D); 
N	c = c & ~0x0F; 
N	c = c | 0x03;  
N	writeByte(MPU, ACCEL_CONFIG2, c); 
X	writeByte(0x68, 0x1D, c); 
N	writeByte(MPU, INT_PIN_CFG, 0x22);    
X	writeByte(0x68, 0x37, 0x22);    
N	writeByte(MPU, INT_ENABLE, 0x01);  
X	writeByte(0x68, 0x38, 0x01);  
N}
N
Nvoid resetMPU9250() {
N	// reset device
N	writeByte(MPU, PWR_MGMT_1, 0x80); 
X	writeByte(0x68, 0x6B, 0x80); 
N}
Nvoid calibrateMPU9250(float * dest1, float * dest2)
N{  
N	uint8_t data[12]; 
N	uint16_t ii, packet_count, fifo_count;
N	int32_t gyro_bias[3] = {0, 0, 0}, accel_bias[3] = {0, 0, 0};
N	uint32_t mask = 1uL; // Define mask for temperature compensation bit 0 of lower byte of accelerometer bias registers
N	uint8_t mask_bit[3] = {0, 0, 0}; // Define array to hold mask bit for each accelerometer bias axis
N	uint16_t  gyrosensitivity  = 131;   // = 131 LSB/degrees/sec
N	uint16_t  accelsensitivity = 16384;  // = 16384 LSB/g
N	int32_t accel_bias_reg[3] = {0, 0, 0}; // A place to hold the factory accelerometer trim biases
N	writeByte(MPU, PWR_MGMT_1, 0x80); 
X	writeByte(0x68, 0x6B, 0x80); 
N	DrvSYS_Delay(100000);
N
N	writeByte(MPU, PWR_MGMT_1, 0x01);  
X	writeByte(0x68, 0x6B, 0x01);  
N	writeByte(MPU, PWR_MGMT_2, 0x00); 
X	writeByte(0x68, 0x6C, 0x00); 
N	DrvSYS_Delay(200000);
N
N	writeByte(MPU, INT_ENABLE, 0x00);   // Disable all interrupts
X	writeByte(0x68, 0x38, 0x00);   
N	writeByte(MPU, FIFO_EN, 0x00);      // Disable FIFO
X	writeByte(0x68, 0x23, 0x00);      
N	writeByte(MPU, PWR_MGMT_1, 0x00);   // Turn on internal clock source
X	writeByte(0x68, 0x6B, 0x00);   
N	writeByte(MPU, I2C_MST_CTRL, 0x00); // Disable I2C master
X	writeByte(0x68, 0x24, 0x00); 
N	writeByte(MPU, USER_CTRL, 0x00);    // Disable FIFO and I2C master modes
X	writeByte(0x68, 0x6A, 0x00);    
N	writeByte(MPU, USER_CTRL, 0x0C);    // Reset FIFO and DMP
X	writeByte(0x68, 0x6A, 0x0C);    
N	DrvSYS_Delay(10000);
N
N	// Configure MPU9250 gyro and accelerometer for bias calculation
N	writeByte(MPU, CONFIG, 0x01);      // Set low-pass filter to 188 Hz
X	writeByte(0x68, 0x1A, 0x01);      
N	writeByte(MPU, SMPLRT_DIV, 0x00);  // Set sample rate to 1 kHz
X	writeByte(0x68, 0x19, 0x00);  
N	writeByte(MPU, GYRO_CONFIG, 0x00);  // Set gyro full-scale to 250 degrees per second, maximum sensitivity
X	writeByte(0x68, 0x1B, 0x00);  
N	writeByte(MPU, ACCEL_CONFIG, 0x00); // Set accelerometer full-scale to 2 g, maximum sensitivity
X	writeByte(0x68, 0x1C, 0x00); 
N
N
N
N	// Configure FIFO to capture accelerometer and gyro data for bias calculation
N	writeByte(MPU, USER_CTRL, 0x40);   // Enable FIFO  
X	writeByte(0x68, 0x6A, 0x40);   
N	writeByte(MPU, FIFO_EN, 0x78);     // Enable gyro and accelerometer sensors for FIFO (max size 512 bytes in MPU-9250)
X	writeByte(0x68, 0x23, 0x78);     
N	DrvSYS_Delay(40000);
N
N	// At end of sample accumulation, turn off FIFO sensor read
N	writeByte(MPU, FIFO_EN, 0x00);        // Disable gyro and accelerometer sensors for FIFO
X	writeByte(0x68, 0x23, 0x00);        
N	data[0]=readByte(MPU, FIFO_COUNTH); // read FIFO sample count
X	data[0]=readByte(0x68, 0x72); 
N	data[1]=readByte(MPU, FIFO_COUNTL); // read FIFO sample count
X	data[1]=readByte(0x68, 0x73); 
N	fifo_count = ((uint16_t)data[0] << 8) | data[1];
N	packet_count = fifo_count/12;// How many sets of full gyro and accelerometer data for averaging
N
N	for (ii = 0; ii < packet_count; ii++) {
N		int16_t accel_temp[3] = {0, 0, 0}, gyro_temp[3] = {0, 0, 0};
N		data[0]=readByte(MPU,ACCEL_XOUT_H); 
X		data[0]=readByte(0x68,0x3B); 
N		data[1]=readByte(MPU,ACCEL_XOUT_L);
X		data[1]=readByte(0x68,0x3C);
N		data[2]=readByte(MPU,ACCEL_YOUT_H);
X		data[2]=readByte(0x68,0x3D);
N		data[3]=readByte(MPU,ACCEL_YOUT_L);
X		data[3]=readByte(0x68,0x3E);
N		data[4]=readByte(MPU,ACCEL_ZOUT_H);
X		data[4]=readByte(0x68,0x3F);
N		data[5]=readByte(MPU,ACCEL_ZOUT_L);
X		data[5]=readByte(0x68,0x40);
N		data[6]=readByte(MPU,GYRO_XOUT_H);
X		data[6]=readByte(0x68,0x43);
N		data[7]=readByte(MPU,GYRO_XOUT_L);
X		data[7]=readByte(0x68,0x44);
N		data[8]=readByte(MPU,GYRO_YOUT_H);
X		data[8]=readByte(0x68,0x45);
N		data[9]=readByte(MPU,GYRO_YOUT_L);
X		data[9]=readByte(0x68,0x46);
N		data[10]=readByte(MPU,GYRO_ZOUT_H);
X		data[10]=readByte(0x68,0x47);
N		data[11]=readByte(MPU,GYRO_ZOUT_L);
X		data[11]=readByte(0x68,0x48);
N		accel_temp[0] = (int16_t) (((int16_t)data[0] << 8) | data[1]  ) ;  // Form signed 16-bit integer for each sample in FIFO
N		accel_temp[1] = (int16_t) (((int16_t)data[2] << 8) | data[3]  ) ;
N		accel_temp[2] = (int16_t) (((int16_t)data[4] << 8) | data[5]  ) ;    
N		gyro_temp[0]  = (int16_t) (((int16_t)data[6] << 8) | data[7]  ) ;
N		gyro_temp[1]  = (int16_t) (((int16_t)data[8] << 8) | data[9]  ) ;
N		gyro_temp[2]  = (int16_t) (((int16_t)data[10] << 8) | data[11]) ;
N
N		accel_bias[0] += (int32_t) accel_temp[0]; // Sum individual signed 16-bit biases to get accumulated signed 32-bit biases
N		accel_bias[1] += (int32_t) accel_temp[1];
N		accel_bias[2] += (int32_t) accel_temp[2];
N		gyro_bias[0]  += (int32_t) gyro_temp[0];
N		gyro_bias[1]  += (int32_t) gyro_temp[1];
N		gyro_bias[2]  += (int32_t) gyro_temp[2];
N
N	}
N	accel_bias[0] /= (int32_t) packet_count; // Normalize sums to get average count biases
N	accel_bias[1] /= (int32_t) packet_count;
N	accel_bias[2] /= (int32_t) packet_count;
N	gyro_bias[0]  /= (int32_t) packet_count;
N	gyro_bias[1]  /= (int32_t) packet_count;
N	gyro_bias[2]  /= (int32_t) packet_count;
N
N	if(accel_bias[2] > 0L) {accel_bias[2] -= (int32_t) accelsensitivity;}  // Remove gravity from the z-axis accelerometer bias calculation
N	else {accel_bias[2] += (int32_t) accelsensitivity;}
N
N	// Construct the gyro biases for push to the hardware gyro bias registers, which are reset to zero upon device startup
N	data[0] = (-gyro_bias[0]/4  >> 8) & 0xFF; // Divide by 4 to get 32.9 LSB per deg/s to conform to expected bias input format
N	data[1] = (-gyro_bias[0]/4)       & 0xFF; // Biases are additive, so change sign on calculated average gyro biases
N	data[2] = (-gyro_bias[1]/4  >> 8) & 0xFF;
N	data[3] = (-gyro_bias[1]/4)       & 0xFF;
N	data[4] = (-gyro_bias[2]/4  >> 8) & 0xFF;
N	data[5] = (-gyro_bias[2]/4)       & 0xFF;
N
N	dest1[0] = (float) gyro_bias[0]/(float) gyrosensitivity; // construct gyro bias in deg/s for later manual subtraction
N	dest1[1] = (float) gyro_bias[1]/(float) gyrosensitivity;
N	dest1[2] = (float) gyro_bias[2]/(float) gyrosensitivity;
N
N
N	data[0]=readByte(MPU, XA_OFFSET_H);
X	data[0]=readByte(0x68, 0x77);
N	data[1]=readByte(MPU, XA_OFFSET_L);
X	data[1]=readByte(0x68, 0x78);
N	accel_bias_reg[0] = (int16_t) ((int16_t)data[0] << 8) | data[1];
N	data[0]=readByte(MPU, YA_OFFSET_H);
X	data[0]=readByte(0x68, 0x7A);
N	data[1]=readByte(MPU, YA_OFFSET_L);
X	data[1]=readByte(0x68, 0x7B);
N	accel_bias_reg[1] = (int16_t) ((int16_t)data[0] << 8) | data[1];
N	data[0]=readByte(MPU, ZA_OFFSET_H);
X	data[0]=readByte(0x68, 0x7D);
N	data[1]=readByte(MPU, ZA_OFFSET_L);
X	data[1]=readByte(0x68, 0x7E);
N	accel_bias_reg[2] = (int16_t) ((int16_t)data[0] << 8) | data[1];
N
N
N
N	for(ii = 0; ii < 3; ii++) {
N		if(accel_bias_reg[ii] & mask) mask_bit[ii] = 0x01; // If temperature compensation bit is set, record that fact in mask_bit
N	}
N
N	// Construct total accelerometer bias, including calculated average accelerometer bias from above
N	accel_bias_reg[0] -= (accel_bias[0]/8); // Subtract calculated averaged accelerometer bias scaled to 2048 LSB/g (16 g full scale)
N	accel_bias_reg[1] -= (accel_bias[1]/8);
N	accel_bias_reg[2] -= (accel_bias[2]/8);
N
N	data[0] = (accel_bias_reg[0] >> 8) & 0xFF;
N	data[1] = (accel_bias_reg[0])      & 0xFF;
N	data[1] = data[1] | mask_bit[0]; // preserve temperature compensation bit when writing back to accelerometer bias registers
N	data[2] = (accel_bias_reg[1] >> 8) & 0xFF;
N	data[3] = (accel_bias_reg[1])      & 0xFF;
N	data[3] = data[3] | mask_bit[1]; // preserve temperature compensation bit when writing back to accelerometer bias registers
N	data[4] = (accel_bias_reg[2] >> 8) & 0xFF;
N	data[5] = (accel_bias_reg[2])      & 0xFF;
N	data[5] = data[5] | mask_bit[2]; // preserve temperature compensation bit when writing back to accelerometer bias registers
N
N	dest2[0] = (float)accel_bias[0]/(float)accelsensitivity; 
N	dest2[1] = (float)accel_bias[1]/(float)accelsensitivity;
N	dest2[2] = (float)accel_bias[2]/(float)accelsensitivity;
N}
Nvoid readAccelData(int16_t * destination)
N{
N	uint8_t rawData[6];  // x/y/z accel register data stored here
N	rawData[0]=readByte(MPU, ACCEL_XOUT_H);  // Read the six raw data registers into data array
X	rawData[0]=readByte(0x68, 0x3B);  
N	rawData[1]=readByte(MPU, ACCEL_XOUT_L);
X	rawData[1]=readByte(0x68, 0x3C);
N	rawData[2]=readByte(MPU, ACCEL_YOUT_H);
X	rawData[2]=readByte(0x68, 0x3D);
N	rawData[3]=readByte(MPU, ACCEL_YOUT_L);
X	rawData[3]=readByte(0x68, 0x3E);
N	rawData[4]=readByte(MPU, ACCEL_ZOUT_H);
X	rawData[4]=readByte(0x68, 0x3F);
N	rawData[5]=readByte(MPU, ACCEL_ZOUT_L);
X	rawData[5]=readByte(0x68, 0x40);
N	destination[0] = rawData[0] *256 + rawData[1] ;  // Turn the MSB and LSB into a signed 16-bit value
N	destination[1] = rawData[2] *256 + rawData[3] ;
N	destination[2] = rawData[4] *256 + rawData[5] ;
N}
N
Nvoid delay_time(int time)		     // 1 secend
N{
N	int i=0;
N	for(i=0;i<time*3;i++)
N	{
N		DrvSYS_Delay(330000);
N	}
N}
N
Nvoid Init_LED()
N{
N	DrvGPIO_Open(E_GPC, 8, E_IO_INPUT);  //button
N	DrvGPIO_Open(E_GPC, 0, E_IO_OUTPUT); //wifi_init
N	DrvGPIO_Open(E_GPC, 1, E_IO_OUTPUT);
N	DrvGPIO_Open(E_GPC, 2, E_IO_OUTPUT);
N	
N	DrvGPIO_ClrBit(E_GPC, 0);     //wifi_init
N	DrvGPIO_ClrBit(E_GPC, 1);
N	DrvGPIO_ClrBit(E_GPC, 2);
N}
N
Nint main (void)
N{
N	STR_UART_T sParam;     
N	int command2;
N	int32_t adc1=0,adc2=0,adc3=0,adc4=0;
N	float ax,ay,az;
N	char textout[30],c1,c2,c3=0x00;
N	
N	//Initial 12M and set HCLK=12MHz
N	InitHCLK12M();
N	//Initial ADC
N	ADC_initialize();
N	Init_LED();
N	UNLOCKREG();
X	*((volatile uint32_t *)(((( uint32_t)0x50000000) + 0x00000) + 0x100)) = 0x59;*((volatile uint32_t *)(((( uint32_t)0x50000000) + 0x00000) + 0x100)) = 0x16;*((volatile uint32_t *)(((( uint32_t)0x50000000) + 0x00000) + 0x100)) = 0x88;
N	DrvSYS_Open(48000000);
N	DrvSYS_SetOscCtrl(E_SYS_XTL12M,1);
N	DrvSYS_Delay(20000);/* Delay for Xtal stable */
N	while(!SYSCLK->CLKSTATUS.XTL12M_STB);
X	while(!((SYSCLK_T *) ((( uint32_t)0x50000000) + 0x00200))->CLKSTATUS.XTL12M_STB);
N	DrvSYS_SelectHCLKSource(0);
N	LOCKREG();
X	*((volatile uint32_t *)(((( uint32_t)0x50000000) + 0x00000) + 0x100)) = 0x00;;
N	DrvGPIO_InitFunction(E_FUNC_I2C1);
N	DrvGPIO_InitFunction(E_FUNC_UART0);		
N
N	/* UART Setting */
N	sParam.u32BaudRate 		= 9600;
N	sParam.u8cDataBits 		= DRVUART_DATABITS_8;
N	sParam.u8cStopBits 		= DRVUART_STOPBITS_1;
N	sParam.u8cParity 		= DRVUART_PARITY_NONE;
N	sParam.u8cRxTriggerLevel= DRVUART_FIFO_1BYTES;
N
N	/* Set UART Configuration */
N	if(DrvUART_Open(UART_PORT0,&sParam) != E_SUCCESS);  
X	if(DrvUART_Open(UART_PORT0,&sParam) != 0);  
N	//wifi
N  delay_time(10);	
N	DrvUART_Write(UART_PORT0,"AT+CIPSTART=\"TCP\",\"192.168.4.1\",8087\r\n",39);
N	delay_time(1);
N	
N	resetMPU9250();
N	calibrateMPU9250(gyroBias, accelBias);
N	initMPU9250();
N	DrvSYS_Delay(300000);
N	DrvGPIO_SetBit(E_GPC, 0);     //finish init LED 
N	while(1)
N	{
N		writeByte(0x68, 0x37,0x02);
N		writeByte(0x68, 0x6A,0x01);
N		DrvSYS_Delay(20000);	
N		readAccelData(accelCount);
N		ax = accelCount[0]*2.0/32768.0- accelBias[0];	  //accel  value
N		ay = accelCount[1]*2.0/32768.0- accelBias[1]; 
N		az = accelCount[2]*2.0/32768.0- accelBias[2];
N		adc1=get_ADC_value(0);     
N		adc2=get_ADC_value(1);   
N		adc3=get_ADC_value(2);   
N		adc4=get_ADC_value(4);
N
N		//hand action
N		if(ax>=0.4f)      //right
N		{
N			command2=((int)(ax*10))-3;
N			if(command2>7)
N				command2=7;
N			
N			switch(command2)
N			{
N				case 1:
N					c1=0x11;c2=0x01;break;
N				case 2:
N					c1=0x12;c2=0x02;break;
N				case 3:
N					c1=0x13;c2=0x03;break;
N				case 4:
N					c1=0x14;c2=0x04;break;
N				case 5:
N					c1=0x15;c2=0x05;break;
N				case 6:
N					c1=0x16;c2=0x06;break;
N				case 7:
N					c1=0x17;c2=0x07;break;
N			}
N		}
N		else if(ax<=-0.4f)    //left
N		{
N			command2=((int)((-ax)*10))-3;
N			if(command2>7)
N				command2=7;
N			
N			switch(command2)
N			{
N				case 1:
N					c1=0x01;c2=0x11;break;
N				case 2:
N					c1=0x02;c2=0x12;break;
N				case 3:
N					c1=0x03;c2=0x13;break;
N				case 4:
N					c1=0x04;c2=0x14;break;
N				case 5:
N					c1=0x05;c2=0x15;break;
N				case 6:
N					c1=0x06;c2=0x16;break;
N				case 7:
N					c1=0x07;c2=0x17;break;
N			}
N		}
N		else if(ay>=0.4f)       //up
N		{
N			command2=((int)(ay*10))-3;
N			if(command2>7)
N				command2=7;
N			
N			switch(command2)
N			{
N				case 1:
N					c1=0x01;c2=0x01;break;
N				case 2:
N					c1=0x02;c2=0x02;break;
N				case 3:
N					c1=0x03;c2=0x03;break;
N				case 4:
N					c1=0x04;c2=0x04;break;
N				case 5:
N					c1=0x05;c2=0x05;break;
N				case 6:
N					c1=0x06;c2=0x06;break;
N				case 7:
N					c1=0x07;c2=0x07;break;
N			}
N		}	
N		else if(ay<=-0.4f)		//down
N		{
N			command2=((int)((-ay)*10))-3;
N			if(command2>7)
N				command2=7;
N			
N			switch(command2)
N			{
N				case 1:
N					c1=0x11;c2=0x11;break;
N				case 2:
N					c1=0x12;c2=0x12;break;
N				case 3:
N					c1=0x13;c2=0x13;break;
N				case 4:
N					c1=0x14;c2=0x14;break;
N				case 5:
N					c1=0x15;c2=0x15;break;
N				case 6:
N					c1=0x16;c2=0x16;break;
N				case 7:
N					c1=0x17;c2=0x17;break;
N			}
N		}
N		else 
N		{
N			c1=0x00;c2=0x00;
N		}
N		
N		if(adc1>1500 || adc2>1500 || adc3>1500 || adc4>1500)
N		{
N			DrvGPIO_ClrBit(E_GPC, 2);
N			//finger action
N			if(adc1<=2810 && adc2<=2800 && adc3<=2900 && adc4<=2900)
N			{
N				c3=0x00;           //all finger
N			}
N			else if(adc3<=2900)    //finger1
N			{
N				c3=0x10;
N			}
N			else if(adc4<=2900)    //finger2
N			{
N				c3=0x70;
N			}
N		}
N		else
N		{
N			DrvGPIO_SetBit(E_GPC, 2);
N		}
N		//WiFi send data
N		if(DrvGPIO_GetBit(E_GPC, 8)==0)
N		{
N			/*sprintf(textout,"a%d\r\n",get_ADC_value(0));	
N			DrvUART_Write(UART_PORT0,textout,strlen(textout)); 
N			sprintf(textout,"b%d\r\n",get_ADC_value(1));	
N			DrvUART_Write(UART_PORT0,textout,strlen(textout)); 
N			sprintf(textout,"c%d\r\n",get_ADC_value(2));	
N			DrvUART_Write(UART_PORT0,textout,strlen(textout)); 
N			sprintf(textout,"d%d\r\n\r\n",get_ADC_value(4));	
N			DrvUART_Write(UART_PORT0,textout,strlen(textout)); 
N			DrvSYS_Delay(200000);*/
N						
N			DrvGPIO_SetBit(E_GPC, 1);
N			DrvUART_Write(UART_PORT0,"AT+CIPSEND=3\r\n",14);
N			DrvSYS_Delay(100000);
N			sprintf(textout,"%c%c%c",c1,c2,c3);	
N			DrvUART_Write(UART_PORT0,textout,3); 
N			DrvSYS_Delay(100000);
N		}
N		else
N		{
N			DrvGPIO_ClrBit(E_GPC, 1);
N		}
N	}
W "Smpl_CAN.c" 671 2 last line of file ends without a newline
N}
