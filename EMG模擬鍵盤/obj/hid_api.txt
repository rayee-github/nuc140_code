; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\obj\hid_api.o --depend=.\obj\hid_api.d --cpu=Cortex-M0 --apcs=interwork -O0 -I.\ -I..\..\..\..\CMSIS\CM0\CoreSupport -I..\..\..\..\CMSIS\CM0\DeviceSupport\Nuvoton\NUC1xx -I..\..\..\Include -I..\..\..\Include\Driver -I..\..\..\Include\NUC1xx-LB_002 -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\ST\STM32F10x -DUSE_STDPERIPH_DRIVER --omf_browse=.\obj\hid_api.crf HID_API.c]
                          THUMB

                          AREA ||i.ADC_average||, CODE, READONLY, ALIGN=1

                  ADC_average PROC
;;;906    
;;;907    static int32_t ADC_average (int32_t *ADC_value)  //[static恁?セゅン?场ノ
000000  b5f0              PUSH     {r4-r7,lr}
;;;908    {
000002  b08b              SUB      sp,sp,#0x2c
000004  4607              MOV      r7,r0
;;;909     int32_t value[9] = {0};
000006  2124              MOVS     r1,#0x24
000008  a802              ADD      r0,sp,#8
00000a  f7fffffe          BL       __aeabi_memclr4
;;;910     uint8_t i,j,k;
;;;911     int32_t value_max;
;;;912     for (i=0; i<9; i++)
00000e  2600              MOVS     r6,#0
000010  e005              B        |L1.30|
                  |L1.18|
;;;913     {
;;;914      value[i] = *ADC_value++;                    //??n??涵
000012  cf01              LDM      r7!,{r0}
000014  00b1              LSLS     r1,r6,#2
000016  aa02              ADD      r2,sp,#8
000018  5050              STR      r0,[r2,r1]
00001a  1c70              ADDS     r0,r6,#1              ;912
00001c  b2c6              UXTB     r6,r0                 ;912
                  |L1.30|
00001e  2e09              CMP      r6,#9                 ;912
000020  dbf7              BLT      |L1.18|
;;;915     }
;;;916     
;;;917     //_wk?p欷j逼C
;;;918     for (j=0; j<9; j++)                    //@@nゑ?9Ω
000022  2500              MOVS     r5,#0
000024  e021              B        |L1.106|
                  |L1.38|
;;;919     {
;;;920      for (k=0; k<9-j; k++)      //材@Ω?Z程j涵醛瘭bF程蔼害旄m
000026  2400              MOVS     r4,#0
000028  e019              B        |L1.94|
                  |L1.42|
;;;921      {           //NぃノAゑ?程j酣?じ坤F
;;;922       if(k != 8)        //兢k?8?Avalue[8]Ovalue[9]氦?A]?Z踏w?WXF??涵S?
00002a  2c08              CMP      r4,#8
00002c  d015              BEQ      |L1.90|
;;;923       {
;;;924        if (value[k] > value[k+1])      //┮HCΩゑ?ЧU@Ωぶゑ?@Ω
00002e  00a0              LSLS     r0,r4,#2
000030  a902              ADD      r1,sp,#8
000032  5809              LDR      r1,[r1,r0]
000034  1c60              ADDS     r0,r4,#1
000036  0080              LSLS     r0,r0,#2
000038  aa02              ADD      r2,sp,#8
00003a  5810              LDR      r0,[r2,r0]
00003c  4281              CMP      r1,r0
00003e  dd0c              BLE      |L1.90|
;;;925        {
;;;926         value_max = value[k];   //??j涵全Os_?
000040  00a0              LSLS     r0,r4,#2
000042  a902              ADD      r1,sp,#8
000044  5808              LDR      r0,[r1,r0]
000046  9001              STR      r0,[sp,#4]
;;;927         value[k] = value[k+1];   //?p涵??C欷腐
000048  1c60              ADDS     r0,r4,#1
00004a  0080              LSLS     r0,r0,#2
00004c  5808              LDR      r0,[r1,r0]
00004e  00a1              LSLS     r1,r4,#2
000050  5050              STR      r0,[r2,r1]
;;;928         value[k+1] = value_max;   //?j涵??蔼欷腐
000052  1c61              ADDS     r1,r4,#1
000054  0089              LSLS     r1,r1,#2
000056  9801              LDR      r0,[sp,#4]
000058  5050              STR      r0,[r2,r1]
                  |L1.90|
00005a  1c60              ADDS     r0,r4,#1              ;920
00005c  b2c4              UXTB     r4,r0                 ;920
                  |L1.94|
00005e  2009              MOVS     r0,#9                 ;920
000060  1b40              SUBS     r0,r0,r5              ;920
000062  42a0              CMP      r0,r4                 ;920
000064  dce1              BGT      |L1.42|
000066  1c68              ADDS     r0,r5,#1              ;918
000068  b2c5              UXTB     r5,r0                 ;918
                  |L1.106|
00006a  2d09              CMP      r5,#9                 ;918
00006c  dbdb              BLT      |L1.38|
;;;929        }
;;;930       }
;;;931      }
;;;932     }
;;;933     return (value[4]);
00006e  9806              LDR      r0,[sp,#0x18]
;;;934    }
000070  b00b              ADD      sp,sp,#0x2c
000072  bdf0              POP      {r4-r7,pc}
;;;935    
                          ENDP


                          AREA ||i.DrvUSB_BusResumeCallback||, CODE, READONLY, ALIGN=1

                  DrvUSB_BusResumeCallback PROC
;;;884    
;;;885    void DrvUSB_BusResumeCallback(void * pVoid)
000000  b570              PUSH     {r4-r6,lr}
;;;886    {
000002  4605              MOV      r5,r0
;;;887        DrvUSB_SetUsbState((E_DRVUSB_STATE)((uint32_t)DrvUSB_GetUsbState() & (uint32_t)(~eDRVUSB_SUSPENDED)));
000004  f7fffffe          BL       DrvUSB_GetUsbState
000008  2120              MOVS     r1,#0x20
00000a  4388              BICS     r0,r0,r1
00000c  4604              MOV      r4,r0
00000e  f7fffffe          BL       DrvUSB_SetUsbState
;;;888    }
000012  bd70              POP      {r4-r6,pc}
;;;889    
                          ENDP


                          AREA ||i.DrvUSB_BusSuspendCallback||, CODE, READONLY, ALIGN=1

                  DrvUSB_BusSuspendCallback PROC
;;;878    }  	   */
;;;879    void DrvUSB_BusSuspendCallback(void * pVoid)
000000  b570              PUSH     {r4-r6,lr}
;;;880    {
000002  4605              MOV      r5,r0
;;;881        /* Note!! We should not power down or idle in Handler mode */
;;;882        DrvUSB_SetUsbState((E_DRVUSB_STATE)((uint32_t)DrvUSB_GetUsbState() | (uint32_t)eDRVUSB_SUSPENDED));
000004  f7fffffe          BL       DrvUSB_GetUsbState
000008  2120              MOVS     r1,#0x20
00000a  4308              ORRS     r0,r0,r1
00000c  4604              MOV      r4,r0
00000e  f7fffffe          BL       DrvUSB_SetUsbState
;;;883    }
000012  bd70              POP      {r4-r6,pc}
;;;884    
                          ENDP


                          AREA ||i.HID_GetOutReportAck||, CODE, READONLY, ALIGN=1

                  HID_GetOutReportAck PROC
;;;747       Therefore, we could prepare next out report here. */
;;;748    void HID_GetOutReportAck(uint8_t *buf, uint32_t size)
000000  4770              BX       lr
;;;749    {
;;;750        
;;;751    }
;;;752    
                          ENDP


                          AREA ||i.HID_Init||, CODE, READONLY, ALIGN=2

                  HID_Init PROC
;;;455    
;;;456    void HID_Init(void)
000000  b510              PUSH     {r4,lr}
;;;457    {
;;;458        /* Open HID to initial the descriptors and control handlers */
;;;459        HID_Open();
000002  f7fffffe          BL       HID_Open
;;;460        
;;;461    #if(HID_FUNCTION == HID_MOUSE)
;;;462    
;;;463        /* Set the HID report descriptor */
;;;464        HID_SetReportDescriptor(g_HID_au8MouseReportDescriptor, g_HID_u32MouseReportDescriptorSize);
;;;465    
;;;466        /* Set the HID report buffer */
;;;467        HID_SetReportBuf(g_au8MouseReport, g_u32MouseReportSize);
;;;468    
;;;469    #elif(HID_FUNCTION == HID_DIGITIZER)
;;;470        /* Set the HID report descriptor */
;;;471        HID_SetReportDescriptor(g_HID_au8DigitizerReportDescriptor, g_HID_u32DigitizerReportDescriptorSize);
;;;472    
;;;473        /* Set the HID report buffer */
;;;474        HID_SetReportBuf(g_au8DigitizerReport, g_u32DigitizerReportSize);
;;;475    #else
;;;476        /* Set the HID report descriptor */
;;;477        HID_SetReportDescriptor(g_HID_au8KeyboardReportDescriptor, g_HID_u32KeyboardReportDescriptorSize);
000006  216e              MOVS     r1,#0x6e
000008  4803              LDR      r0,|L5.24|
00000a  f7fffffe          BL       HID_SetReportDescriptor
;;;478    
;;;479        /* Set the HID report buffer */
;;;480        HID_SetReportBuf(g_au8KeyboardReport, g_u32KeyboardReportSize);
00000e  2109              MOVS     r1,#9
000010  4802              LDR      r0,|L5.28|
000012  f7fffffe          BL       HID_SetReportBuf
;;;481    #endif
;;;482    
;;;483    }
000016  bd10              POP      {r4,pc}
;;;484    
                          ENDP

                  |L5.24|
                          DCD      g_HID_au8KeyboardReportDescriptor
                  |L5.28|
                          DCD      g_au8KeyboardReport

                          AREA ||i.HID_MainProcess||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  HID_MainProcess PROC
;;;790    
;;;791    int32_t HID_MainProcess(void)
000000  b57f              PUSH     {r0-r6,lr}
;;;792    {
;;;793    	char adc_value[15]="ADC Value:";
000002  4b2d              LDR      r3,|L6.184|
000004  cb0f              LDM      r3,{r0-r3}
000006  466c              MOV      r4,sp
000008  c40f              STM      r4!,{r0-r3}
;;;794        
;;;795    	int32_t i32Ret = 0;
00000a  2500              MOVS     r5,#0
;;;796        E_DRVUSB_STATE eUsbState;
;;;797    
;;;798      
;;;799    
;;;800    
;;;801        //GPIOD->IEN = (1 << 1);
;;;802        NVIC_EnableIRQ(GPCDE_IRQn);
00000c  bf00              NOP      
00000e  2005              MOVS     r0,#5
000010  2101              MOVS     r1,#1
000012  4081              LSLS     r1,r1,r0
000014  4829              LDR      r0,|L6.188|
000016  6001              STR      r1,[r0,#0]
000018  bf00              NOP      
;;;803        
;;;804        i32Ret = DrvUSB_Open((void *)DrvUSB_DispatchEvent);
00001a  4829              LDR      r0,|L6.192|
00001c  f7fffffe          BL       DrvUSB_Open
000020  4605              MOV      r5,r0
;;;805        if(i32Ret != 0)
000022  2d00              CMP      r5,#0
000024  d002              BEQ      |L6.44|
;;;806            return i32Ret;
000026  4628              MOV      r0,r5
;;;807    
;;;808    
;;;809    
;;;810    
;;;811    
;;;812        while(1)
;;;813        {
;;;814            /* Disable USB-related interrupts. */
;;;815            _DRVUSB_ENABLE_MISC_INT(0);
;;;816    		show_string(0,10,"ggg");
;;;817            /* Enable float-detection interrupt. */
;;;818            _DRVUSB_ENABLE_FLDET_INT();
;;;819        	  
;;;820            /* Start HID and install the callback functions to handle in/out report */
;;;821            HID_Init();
;;;822    		
;;;823            /* Enable USB-related interrupts. */
;;;824            _DRVUSB_ENABLE_MISC_INT(INTEN_WAKEUP | INTEN_WAKEUPEN | INTEN_FLDET | INTEN_USB | INTEN_BUS);
;;;825    		  	  show_string(0,10,"db");
;;;826            /* Enter power down to wait USB attached */
;;;827           // PowerDown();
;;;828    		   show_string(0,10,"dg");
;;;829            /* Poll and handle USB events. */
;;;830            while(1)
;;;831            {	
;;;832    			    ADC_result = get_ADC_value(1); 					   //1
;;;833    				//uint16_ascii(adc_value,ADC_result);
;;;834    				sprintf(adc_value,"%d",ADC_result)	;
;;;835    				show_string(2,10,adc_value);		  
;;;836    				DrvSYS_Delay(5000); 
;;;837    		// show_string(0,10,"dx");
;;;838                eUsbState = DrvUSB_GetUsbState();
;;;839    			  
;;;840                if (eUsbState == eDRVUSB_DETACHED)
;;;841                {	 
;;;842                    DBG_PRINTF("USB Detached!\n");
;;;843                    break;
;;;844                }
;;;845                
;;;846                if (eUsbState & eDRVUSB_SUSPENDED)
;;;847                {	
;;;848                    /* Enter suspend here */
;;;849                   // PowerDown();
;;;850                }
;;;851                
;;;852                if (eUsbState == eDRVUSB_CONFIGURED)
;;;853                {	 
;;;854                    /* Set HID IN report for interrupt IN transfer */
;;;855    			
;;;856                    HID_SetInReport();
;;;857                }
;;;858            }
;;;859    
;;;860            /* Disable USB-related interrupts. */
;;;861            _DRVUSB_ENABLE_MISC_INT(0);
;;;862        }
;;;863    }
000028  b004              ADD      sp,sp,#0x10
00002a  bd70              POP      {r4-r6,pc}
                  |L6.44|
00002c  e042              B        |L6.180|
                  |L6.46|
00002e  2000              MOVS     r0,#0                 ;815
000030  4924              LDR      r1,|L6.196|
000032  6008              STR      r0,[r1,#0]            ;815
000034  a224              ADR      r2,|L6.200|
000036  210a              MOVS     r1,#0xa               ;816
000038  f7fffffe          BL       show_string
00003c  4821              LDR      r0,|L6.196|
00003e  6800              LDR      r0,[r0,#0]            ;818
000040  2104              MOVS     r1,#4                 ;818
000042  4388              BICS     r0,r0,r1              ;818
000044  1d00              ADDS     r0,r0,#4              ;818
000046  491f              LDR      r1,|L6.196|
000048  6008              STR      r0,[r1,#0]            ;818
00004a  f7fffffe          BL       HID_Init
00004e  200f              MOVS     r0,#0xf               ;824
000050  491c              LDR      r1,|L6.196|
000052  6008              STR      r0,[r1,#0]            ;824
000054  a21d              ADR      r2,|L6.204|
000056  210a              MOVS     r1,#0xa               ;825
000058  2000              MOVS     r0,#0                 ;825
00005a  f7fffffe          BL       show_string
00005e  a21c              ADR      r2,|L6.208|
000060  210a              MOVS     r1,#0xa               ;828
000062  2000              MOVS     r0,#0                 ;828
000064  f7fffffe          BL       show_string
000068  e01f              B        |L6.170|
                  |L6.106|
00006a  2001              MOVS     r0,#1                 ;832
00006c  f7fffffe          BL       get_ADC_value
000070  4918              LDR      r1,|L6.212|
000072  8008              STRH     r0,[r1,#0]            ;832
000074  4608              MOV      r0,r1                 ;834
000076  8802              LDRH     r2,[r0,#0]            ;834  ; ADC_result
000078  a117              ADR      r1,|L6.216|
00007a  4668              MOV      r0,sp                 ;834
00007c  f7fffffe          BL       __2sprintf
000080  466a              MOV      r2,sp                 ;835
000082  210a              MOVS     r1,#0xa               ;835
000084  2002              MOVS     r0,#2                 ;835
000086  f7fffffe          BL       show_string
00008a  4814              LDR      r0,|L6.220|
00008c  f7fffffe          BL       DrvSYS_Delay
000090  f7fffffe          BL       DrvUSB_GetUsbState
000094  4604              MOV      r4,r0                 ;838
000096  2c00              CMP      r4,#0                 ;840
000098  d103              BNE      |L6.162|
00009a  a011              ADR      r0,|L6.224|
00009c  f7fffffe          BL       __2printf
0000a0  e004              B        |L6.172|
                  |L6.162|
0000a2  2c1f              CMP      r4,#0x1f              ;852
0000a4  d101              BNE      |L6.170|
0000a6  f7fffffe          BL       HID_SetInReport
                  |L6.170|
0000aa  e7de              B        |L6.106|
                  |L6.172|
0000ac  bf00              NOP                            ;843
0000ae  2000              MOVS     r0,#0                 ;861
0000b0  4904              LDR      r1,|L6.196|
0000b2  6008              STR      r0,[r1,#0]            ;861
                  |L6.180|
0000b4  e7bb              B        |L6.46|
;;;864    /*
                          ENDP

0000b6  0000              DCW      0x0000
                  |L6.184|
                          DCD      ||.constdata||+0x3f4
                  |L6.188|
                          DCD      0xe000e100
                  |L6.192|
                          DCD      DrvUSB_DispatchEvent
                  |L6.196|
                          DCD      0x40060000
                  |L6.200|
0000c8  67676700          DCB      "ggg",0
                  |L6.204|
0000cc  646200            DCB      "db",0
0000cf  00                DCB      0
                  |L6.208|
0000d0  646700            DCB      "dg",0
0000d3  00                DCB      0
                  |L6.212|
                          DCD      ADC_result
                  |L6.216|
0000d8  256400            DCB      "%d",0
0000db  00                DCB      0
                  |L6.220|
                          DCD      0x00001388
                  |L6.224|
0000e0  55534220          DCB      "USB Detached!\n",0
0000e4  44657461
0000e8  63686564
0000ec  210a00  
0000ef  00                DCB      0

                          AREA ||i.HID_SetFirstInReport||, CODE, READONLY, ALIGN=2

                  HID_SetFirstInReport PROC
;;;739    /* This function is used to prepare the first in report */
;;;740    void HID_SetFirstInReport(void)
000000  b510              PUSH     {r4,lr}
;;;741    {
;;;742        DrvUSB_DataIn(INT_IN_EP_NUM, g_HID_sDevice.pu8Report, g_HID_sDevice.u32ReportSize);
000002  4803              LDR      r0,|L7.16|
000004  6a82              LDR      r2,[r0,#0x28]  ; g_HID_sDevice
000006  6a41              LDR      r1,[r0,#0x24]  ; g_HID_sDevice
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       DrvUSB_DataIn
;;;743    }
00000e  bd10              POP      {r4,pc}
;;;744    
                          ENDP

                  |L7.16|
                          DCD      g_HID_sDevice

                          AREA ||i.HID_SetFirstOutReport||, CODE, READONLY, ALIGN=1

                  HID_SetFirstOutReport PROC
;;;733    /* This function is used to prepare the first out report. */
;;;734    void HID_SetFirstOutReport(void)
000000  4770              BX       lr
;;;735    {
;;;736    
;;;737    }
;;;738    
                          ENDP


                          AREA ||i.HID_SetInReport||, CODE, READONLY, ALIGN=2

                  HID_SetInReport PROC
;;;605    
;;;606    void HID_SetInReport()
000000  b5f8              PUSH     {r3-r7,lr}
;;;607    {
;;;608      /*  uint8_t *buf;
;;;609        int32_t i;
;;;610        uint32_t key = 0xF;
;;;611        static uint32_t preKey;
;;;612    	
;;;613    
;;;614        if(g_HID_sDevice.isReportReady)
;;;615        //    return;
;;;616        
;;;617     
;;;618       //  If GPD1 = 0, just report it is key 'a' 
;;;619        key = (GPIOD->PIN & (1 << 1))? 0 : 1;
;;;620                                  
;;;621        buf = g_HID_sDevice.pu8Report;
;;;622                
;;;623        if (key == 0)
;;;624        {
;;;625            for (i=0;i<8;i++)
;;;626            {
;;;627                buf[i] = 0;
;;;628            }
;;;629    	
;;;630            if(key != preKey)
;;;631            {
;;;632                // Trigger to note key release 
;;;633                g_HID_sDevice.isReportReady = 1;
;;;634                DrvUSB_DataIn(INT_IN_EP_NUM, g_HID_sDevice.pu8Report, g_HID_sDevice.u32ReportSize);
;;;635            }
;;;636        }
;;;637        else
;;;638        {
;;;639    	
;;;640            preKey = key;
;;;641            buf[2] = 0x04;// Key A 
;;;642            g_HID_sDevice.isReportReady = 1;
;;;643            DrvUSB_DataIn(INT_IN_EP_NUM, g_HID_sDevice.pu8Report, g_HID_sDevice.u32ReportSize);
;;;644        }  															  */
;;;645     uint8_t *buf;
;;;646        int32_t i;
;;;647        uint32_t key = 0xF;
000002  250f              MOVS     r5,#0xf
;;;648    	uint32_t key1 = 0xF;
000004  270f              MOVS     r7,#0xf
;;;649    	uint32_t key2 = 0xF;
000006  200f              MOVS     r0,#0xf
000008  9000              STR      r0,[sp,#0]
;;;650    	
;;;651        static uint32_t preKey;
;;;652    
;;;653        /* To check if previous report data is processed or not */
;;;654        if(g_HID_sDevice.isReportReady)
00000a  484f              LDR      r0,|L9.328|
00000c  7b00              LDRB     r0,[r0,#0xc]
00000e  2800              CMP      r0,#0
000010  d000              BEQ      |L9.20|
                  |L9.18|
;;;655            return;
;;;656        /* Update new report data */
;;;657    
;;;658        /* If GPD2 = 0, just report it is key 'a' */
;;;659        key = (GPIOD->PIN & (1 << 2))? 0 : 1;
;;;660    		
;;;661    		/* If GPD3 = 0, just report it is key "Volume +" */
;;;662        key1 = (GPIOD->PIN & (1 << 3))? 0 : 1;
;;;663    		
;;;664    		/* If GPD4 = 0, just report it is key "Volume -" */
;;;665        key2 = (GPIOD->PIN & (1 << 4))? 0 : 1;
;;;666                                  												
;;;667        buf = g_HID_sDevice.pu8Report;
;;;668                
;;;669        if ((key | key1 | key2) == 0)
;;;670        {
;;;671    			  if(key == 0)
;;;672    					buf[0] = 0x01;	/* Report ID */ 
;;;673    				else
;;;674    					buf[0] = 0x02;	/* Report ID */ 
;;;675    				
;;;676            for (i=1;i<9;i++)
;;;677            {
;;;678                buf[i] = 0;										 
;;;679            }
;;;680    			
;;;681            if((key != preKey) && (key1 != preKey) && (key2 != preKey))
;;;682            {																																					                                                                                                             
;;;683                /* Trigger to note key release */
;;;684                g_HID_sDevice.isReportReady = 1;
;;;685                DrvUSB_DataIn(INT_IN_EP_NUM, g_HID_sDevice.pu8Report, g_HID_sDevice.u32ReportSize);
;;;686            }
;;;687    		}
;;;688    		else if (key == 1)
;;;689        {	
;;;690    		if(ADC_result>=1000) 
;;;691    		{
;;;692    	        preKey = key;
;;;693    			buf[0] = 0x01;	/* Report ID */
;;;694    	        buf[3] = 0x2C; 	/* Key A */		
;;;695    	        g_HID_sDevice.isReportReady = 1;   
;;;696    			show_string(0,10,"111");
;;;697    	        DrvUSB_DataIn(INT_IN_EP_NUM, g_HID_sDevice.pu8Report, g_HID_sDevice.u32ReportSize);
;;;698    		}
;;;699    		else
;;;700    		{
;;;701    	        preKey = key;
;;;702    			buf[0] = 0x01;	/* Report ID */
;;;703    	        buf[3] = 0x05; 	/* Key B */		
;;;704    	        g_HID_sDevice.isReportReady = 1;   
;;;705    			show_string(0,10,"ddd");
;;;706    	        DrvUSB_DataIn(INT_IN_EP_NUM, g_HID_sDevice.pu8Report, g_HID_sDevice.u32ReportSize);
;;;707    		}
;;;708        }
;;;709    		else if (key1 == 1)
;;;710    		{
;;;711    			  preKey = key1;											 
;;;712    				buf[0] = 0x02;	// Report ID 
;;;713            buf[1] = 0x02; 	// Volume + 
;;;714            g_HID_sDevice.isReportReady = 1;
;;;715            DrvUSB_DataIn(INT_IN_EP_NUM, g_HID_sDevice.pu8Report, g_HID_sDevice.u32ReportSize);
;;;716    		}
;;;717    		else if (key2 == 1)
;;;718    		{
;;;719    			  preKey = key2;										   
;;;720    		 buf[0] = 0x02;	// Report ID 
;;;721            buf[1] = 0x04; 	// Volume - 
;;;722            g_HID_sDevice.isReportReady = 1;
;;;723            DrvUSB_DataIn(INT_IN_EP_NUM, g_HID_sDevice.pu8Report, g_HID_sDevice.u32ReportSize);
;;;724    		}	  
;;;725    }
000012  bdf8              POP      {r3-r7,pc}
                  |L9.20|
000014  484d              LDR      r0,|L9.332|
000016  6900              LDR      r0,[r0,#0x10]         ;659
000018  0881              LSRS     r1,r0,#2              ;659
00001a  2001              MOVS     r0,#1                 ;659
00001c  4388              BICS     r0,r0,r1              ;659
00001e  4605              MOV      r5,r0                 ;659
000020  484a              LDR      r0,|L9.332|
000022  6900              LDR      r0,[r0,#0x10]         ;662
000024  08c1              LSRS     r1,r0,#3              ;662
000026  2001              MOVS     r0,#1                 ;662
000028  4388              BICS     r0,r0,r1              ;662
00002a  4607              MOV      r7,r0                 ;662
00002c  4847              LDR      r0,|L9.332|
00002e  6900              LDR      r0,[r0,#0x10]         ;665
000030  0901              LSRS     r1,r0,#4              ;665
000032  2001              MOVS     r0,#1                 ;665
000034  4388              BICS     r0,r0,r1              ;665
000036  9000              STR      r0,[sp,#0]            ;665
000038  4843              LDR      r0,|L9.328|
00003a  3820              SUBS     r0,r0,#0x20           ;667
00003c  6a44              LDR      r4,[r0,#0x24]         ;667  ; g_HID_sDevice
00003e  4628              MOV      r0,r5                 ;669
000040  4338              ORRS     r0,r0,r7              ;669
000042  9900              LDR      r1,[sp,#0]            ;669
000044  4308              ORRS     r0,r0,r1              ;669
000046  d124              BNE      |L9.146|
000048  2d00              CMP      r5,#0                 ;671
00004a  d102              BNE      |L9.82|
00004c  2001              MOVS     r0,#1                 ;672
00004e  7020              STRB     r0,[r4,#0]            ;672
000050  e001              B        |L9.86|
                  |L9.82|
000052  2002              MOVS     r0,#2                 ;674
000054  7020              STRB     r0,[r4,#0]            ;674
                  |L9.86|
000056  2601              MOVS     r6,#1                 ;676
000058  e002              B        |L9.96|
                  |L9.90|
00005a  2000              MOVS     r0,#0                 ;678
00005c  55a0              STRB     r0,[r4,r6]            ;678
00005e  1c76              ADDS     r6,r6,#1              ;676
                  |L9.96|
000060  2e09              CMP      r6,#9                 ;676
000062  dbfa              BLT      |L9.90|
000064  483a              LDR      r0,|L9.336|
000066  6800              LDR      r0,[r0,#0]            ;681  ; preKey
000068  4285              CMP      r5,r0                 ;681
00006a  d06a              BEQ      |L9.322|
00006c  4838              LDR      r0,|L9.336|
00006e  6800              LDR      r0,[r0,#0]            ;681  ; preKey
000070  4287              CMP      r7,r0                 ;681
000072  d066              BEQ      |L9.322|
000074  4936              LDR      r1,|L9.336|
000076  9800              LDR      r0,[sp,#0]            ;681
000078  6809              LDR      r1,[r1,#0]            ;681  ; preKey
00007a  4288              CMP      r0,r1                 ;681
00007c  d061              BEQ      |L9.322|
00007e  2101              MOVS     r1,#1                 ;684
000080  4831              LDR      r0,|L9.328|
000082  7301              STRB     r1,[r0,#0xc]          ;684
000084  3820              SUBS     r0,r0,#0x20           ;685
000086  6a82              LDR      r2,[r0,#0x28]         ;685  ; g_HID_sDevice
000088  6a41              LDR      r1,[r0,#0x24]         ;685  ; g_HID_sDevice
00008a  2001              MOVS     r0,#1                 ;685
00008c  f7fffffe          BL       DrvUSB_DataIn
000090  e057              B        |L9.322|
                  |L9.146|
000092  2d01              CMP      r5,#1                 ;688
000094  d131              BNE      |L9.250|
000096  482f              LDR      r0,|L9.340|
000098  8800              LDRH     r0,[r0,#0]            ;690  ; ADC_result
00009a  217d              MOVS     r1,#0x7d              ;690
00009c  00c9              LSLS     r1,r1,#3              ;690
00009e  4288              CMP      r0,r1                 ;690
0000a0  db15              BLT      |L9.206|
0000a2  482b              LDR      r0,|L9.336|
0000a4  6005              STR      r5,[r0,#0]            ;692  ; preKey
0000a6  2001              MOVS     r0,#1                 ;693
0000a8  7020              STRB     r0,[r4,#0]            ;693
0000aa  202c              MOVS     r0,#0x2c              ;694
0000ac  70e0              STRB     r0,[r4,#3]            ;694
0000ae  2101              MOVS     r1,#1                 ;695
0000b0  4825              LDR      r0,|L9.328|
0000b2  7301              STRB     r1,[r0,#0xc]          ;695
0000b4  a228              ADR      r2,|L9.344|
0000b6  210a              MOVS     r1,#0xa               ;696
0000b8  2000              MOVS     r0,#0                 ;696
0000ba  f7fffffe          BL       show_string
0000be  4822              LDR      r0,|L9.328|
0000c0  3820              SUBS     r0,r0,#0x20           ;697
0000c2  6a82              LDR      r2,[r0,#0x28]         ;697  ; g_HID_sDevice
0000c4  6a41              LDR      r1,[r0,#0x24]         ;697  ; g_HID_sDevice
0000c6  2001              MOVS     r0,#1                 ;697
0000c8  f7fffffe          BL       DrvUSB_DataIn
0000cc  e039              B        |L9.322|
                  |L9.206|
0000ce  4820              LDR      r0,|L9.336|
0000d0  6005              STR      r5,[r0,#0]            ;701  ; preKey
0000d2  2001              MOVS     r0,#1                 ;702
0000d4  7020              STRB     r0,[r4,#0]            ;702
0000d6  2005              MOVS     r0,#5                 ;703
0000d8  70e0              STRB     r0,[r4,#3]            ;703
0000da  2101              MOVS     r1,#1                 ;704
0000dc  481a              LDR      r0,|L9.328|
0000de  7301              STRB     r1,[r0,#0xc]          ;704
0000e0  a21e              ADR      r2,|L9.348|
0000e2  210a              MOVS     r1,#0xa               ;705
0000e4  2000              MOVS     r0,#0                 ;705
0000e6  f7fffffe          BL       show_string
0000ea  4817              LDR      r0,|L9.328|
0000ec  3820              SUBS     r0,r0,#0x20           ;706
0000ee  6a82              LDR      r2,[r0,#0x28]         ;706  ; g_HID_sDevice
0000f0  6a41              LDR      r1,[r0,#0x24]         ;706  ; g_HID_sDevice
0000f2  2001              MOVS     r0,#1                 ;706
0000f4  f7fffffe          BL       DrvUSB_DataIn
0000f8  e023              B        |L9.322|
                  |L9.250|
0000fa  2f01              CMP      r7,#1                 ;709
0000fc  d10e              BNE      |L9.284|
0000fe  4814              LDR      r0,|L9.336|
000100  6007              STR      r7,[r0,#0]            ;711  ; preKey
000102  2002              MOVS     r0,#2                 ;712
000104  7020              STRB     r0,[r4,#0]            ;712
000106  7060              STRB     r0,[r4,#1]            ;713
000108  2101              MOVS     r1,#1                 ;714
00010a  480f              LDR      r0,|L9.328|
00010c  7301              STRB     r1,[r0,#0xc]          ;714
00010e  3820              SUBS     r0,r0,#0x20           ;715
000110  6a82              LDR      r2,[r0,#0x28]         ;715  ; g_HID_sDevice
000112  6a41              LDR      r1,[r0,#0x24]         ;715  ; g_HID_sDevice
000114  2001              MOVS     r0,#1                 ;715
000116  f7fffffe          BL       DrvUSB_DataIn
00011a  e012              B        |L9.322|
                  |L9.284|
00011c  9800              LDR      r0,[sp,#0]            ;717
00011e  2801              CMP      r0,#1                 ;717
000120  d10f              BNE      |L9.322|
000122  490b              LDR      r1,|L9.336|
000124  9800              LDR      r0,[sp,#0]            ;719
000126  6008              STR      r0,[r1,#0]            ;719  ; preKey
000128  2002              MOVS     r0,#2                 ;720
00012a  7020              STRB     r0,[r4,#0]            ;720
00012c  2004              MOVS     r0,#4                 ;721
00012e  7060              STRB     r0,[r4,#1]            ;721
000130  2101              MOVS     r1,#1                 ;722
000132  4805              LDR      r0,|L9.328|
000134  7301              STRB     r1,[r0,#0xc]          ;722
000136  3820              SUBS     r0,r0,#0x20           ;723
000138  6a82              LDR      r2,[r0,#0x28]         ;723  ; g_HID_sDevice
00013a  6a41              LDR      r1,[r0,#0x24]         ;723  ; g_HID_sDevice
00013c  2001              MOVS     r0,#1                 ;723
00013e  f7fffffe          BL       DrvUSB_DataIn
                  |L9.322|
000142  bf00              NOP      
000144  e765              B        |L9.18|
;;;726    
                          ENDP

000146  0000              DCW      0x0000
                  |L9.328|
                          DCD      g_HID_sDevice+0x20
                  |L9.332|
                          DCD      0x500040c0
                  |L9.336|
                          DCD      preKey
                  |L9.340|
                          DCD      ADC_result
                  |L9.344|
000158  31313100          DCB      "111",0
                  |L9.348|
00015c  64646400          DCB      "ddd",0

                          AREA ||i.PowerDown||, CODE, READONLY, ALIGN=2

                  PowerDown PROC
;;;752    
;;;753    void PowerDown()
000000  b510              PUSH     {r4,lr}
;;;754    {
;;;755        DBG_PRINTF("Enter power down ...\n");
000002  a02a              ADR      r0,|L10.172|
000004  f7fffffe          BL       __2printf
;;;756    
;;;757        UNLOCKREG();
000008  2059              MOVS     r0,#0x59
00000a  492e              LDR      r1,|L10.196|
00000c  6008              STR      r0,[r1,#0]
00000e  2016              MOVS     r0,#0x16
000010  6008              STR      r0,[r1,#0]
000012  2088              MOVS     r0,#0x88
000014  6008              STR      r0,[r1,#0]
;;;758    
;;;759        while ( IsDebugFifoEmpty() == FALSE );
000016  bf00              NOP      
                  |L10.24|
000018  f7fffffe          BL       IsDebugFifoEmpty
00001c  2800              CMP      r0,#0
00001e  d0fb              BEQ      |L10.24|
;;;760        
;;;761        /* Wakeup Enable */
;;;762        USBD->INTEN.WAKEUP_EN = 1;
000020  4829              LDR      r0,|L10.200|
000022  6800              LDR      r0,[r0,#0]
000024  21ff              MOVS     r1,#0xff
000026  3101              ADDS     r1,#1
000028  4388              BICS     r0,r0,r1
00002a  1840              ADDS     r0,r0,r1
00002c  4926              LDR      r1,|L10.200|
00002e  6008              STR      r0,[r1,#0]
;;;763    
;;;764        /* Deep sleep */
;;;765        outp32(0xE000ED10, 4);
000030  2004              MOVS     r0,#4
000032  4926              LDR      r1,|L10.204|
000034  6108              STR      r0,[r1,#0x10]
;;;766        SYSCLK->PWRCON.PD_WAIT_CPU = 1;
000036  4826              LDR      r0,|L10.208|
000038  6800              LDR      r0,[r0,#0]
00003a  21ff              MOVS     r1,#0xff
00003c  3101              ADDS     r1,#1
00003e  4388              BICS     r0,r0,r1
000040  1840              ADDS     r0,r0,r1
000042  4923              LDR      r1,|L10.208|
000044  6008              STR      r0,[r1,#0]
;;;767        SYSCLK->PWRCON.PWR_DOWN_EN = 1;
000046  4608              MOV      r0,r1
000048  6800              LDR      r0,[r0,#0]
00004a  2180              MOVS     r1,#0x80
00004c  4388              BICS     r0,r0,r1
00004e  3080              ADDS     r0,r0,#0x80
000050  491f              LDR      r1,|L10.208|
000052  6008              STR      r0,[r1,#0]
;;;768        __WFI();
000054  bf30              WFI      
;;;769        SYSCLK->PWRCON.PWR_DOWN_EN = 0;
000056  4608              MOV      r0,r1
000058  6800              LDR      r0,[r0,#0]
00005a  2180              MOVS     r1,#0x80
00005c  4388              BICS     r0,r0,r1
00005e  491c              LDR      r1,|L10.208|
000060  6008              STR      r0,[r1,#0]
;;;770    
;;;771        if(DrvUSB_GetUsbState() & eDRVUSB_SUSPENDED)
000062  f7fffffe          BL       DrvUSB_GetUsbState
000066  2120              MOVS     r1,#0x20
000068  4208              TST      r0,r1
00006a  d01b              BEQ      |L10.164|
;;;772        {
;;;773            /* Note HOST to resume USB tree if it is suspended and remote wakeup enabled */
;;;774            if(DrvUSB_IsRemoteWakeupEnabled())
00006c  f7fffffe          BL       DrvUSB_IsRemoteWakeupEnabled
000070  2800              CMP      r0,#0
000072  d017              BEQ      |L10.164|
;;;775            {
;;;776                /* Enable PHY before sending Resume('K') state */
;;;777                USBD->ATTR.PHY_EN = 1;
000074  4814              LDR      r0,|L10.200|
000076  6900              LDR      r0,[r0,#0x10]
000078  2110              MOVS     r1,#0x10
00007a  4388              BICS     r0,r0,r1
00007c  3010              ADDS     r0,r0,#0x10
00007e  4912              LDR      r1,|L10.200|
000080  6108              STR      r0,[r1,#0x10]
;;;778    
;;;779                /* Keep remote wakeup for 1 ms */
;;;780                USBD->ATTR.RWAKEUP = 1;
000082  4608              MOV      r0,r1
000084  6900              LDR      r0,[r0,#0x10]
000086  2120              MOVS     r1,#0x20
000088  4388              BICS     r0,r0,r1
00008a  3020              ADDS     r0,r0,#0x20
00008c  490e              LDR      r1,|L10.200|
00008e  6108              STR      r0,[r1,#0x10]
;;;781                DrvSYS_Delay(1000); /* Delay 1ms */
000090  207d              MOVS     r0,#0x7d
000092  00c0              LSLS     r0,r0,#3
000094  f7fffffe          BL       DrvSYS_Delay
;;;782                USBD->ATTR.RWAKEUP = 0;
000098  480b              LDR      r0,|L10.200|
00009a  6900              LDR      r0,[r0,#0x10]
00009c  2120              MOVS     r1,#0x20
00009e  4388              BICS     r0,r0,r1
0000a0  4909              LDR      r1,|L10.200|
0000a2  6108              STR      r0,[r1,#0x10]
                  |L10.164|
;;;783            }
;;;784        }
;;;785    
;;;786        DBG_PRINTF("device wakeup!\n");
0000a4  a00b              ADR      r0,|L10.212|
0000a6  f7fffffe          BL       __2printf
;;;787        
;;;788    }
0000aa  bd10              POP      {r4,pc}
;;;789    
                          ENDP

                  |L10.172|
0000ac  456e7465          DCB      "Enter power down ...\n",0
0000b0  7220706f
0000b4  77657220
0000b8  646f776e
0000bc  202e2e2e
0000c0  0a00    
0000c2  00                DCB      0
0000c3  00                DCB      0
                  |L10.196|
                          DCD      0x50000100
                  |L10.200|
                          DCD      0x40060000
                  |L10.204|
                          DCD      0xe000ed00
                  |L10.208|
                          DCD      0x50000200
                  |L10.212|
0000d4  64657669          DCB      "device wakeup!\n",0
0000d8  63652077
0000dc  616b6575
0000e0  70210a00

                          AREA ||i.get_ADC_value||, CODE, READONLY, ALIGN=1

                  get_ADC_value PROC
;;;890    	   
;;;891    static int32_t get_ADC_value(uint8_t ADC_channel_number)
000000  b530              PUSH     {r4,r5,lr}
;;;892    {
000002  b089              SUB      sp,sp,#0x24
000004  4605              MOV      r5,r0
;;;893     uint8_t i;
;;;894        int32_t ADC_calibration[9]={0};                                   //ADCDい??u?s??
000006  2124              MOVS     r1,#0x24
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       __aeabi_memclr4
;;;895     for (i=0; i<9; i++)                      //?9Ω涵
00000e  2400              MOVS     r4,#0
000010  e010              B        |L11.52|
                  |L11.18|
;;;896     {
;;;897      DrvADC_StartConvert();                    //??ADC??
000012  f7fffffe          BL       DrvADC_StartConvert
;;;898      while(!DrvADC_IsConversionDone())                 //单ADC??ЧΘ
000016  bf00              NOP      
                  |L11.24|
000018  f7fffffe          BL       DrvADC_IsConversionDone
00001c  2800              CMP      r0,#0
00001e  d0fb              BEQ      |L11.24|
;;;899      {
;;;900      }
;;;901      ADC_calibration[i] = DrvADC_GetConversionData(ADC_channel_number); //???ADCqD涵
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       DrvADC_GetConversionData
000026  00a1              LSLS     r1,r4,#2
000028  466a              MOV      r2,sp
00002a  5050              STR      r0,[r2,r1]
;;;902      DrvADC_StopConvert();                                           //氨ゎ??
00002c  f7fffffe          BL       DrvADC_StopConvert
000030  1c60              ADDS     r0,r4,#1              ;895
000032  b2c4              UXTB     r4,r0                 ;895
                  |L11.52|
000034  2c09              CMP      r4,#9                 ;895
000036  dbec              BLT      |L11.18|
;;;903     }
;;;904     return (ADC_average(ADC_calibration));                 //?飒涵权Dい?圈Z穰^
000038  4668              MOV      r0,sp
00003a  f7fffffe          BL       ADC_average
;;;905    }
00003e  b009              ADD      sp,sp,#0x24
000040  bd30              POP      {r4,r5,pc}
;;;906    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_au8KeyboardReport
                          %        9

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  g_sVendorStringDesc
000000  1003              DCB      0x10,0x03
000002  004e              DCW      0x004e
000004  00550056          DCW      0x0055,0x0056
000008  004f0054          DCW      0x004f,0x0054
00000c  004f004e          DCW      0x004f,0x004e
                          %        184
0000c8  0000              DCB      0x00,0x00
                  g_sProductStringDesc
0000ca  1603              DCB      0x16,0x03
0000cc  00410052          DCW      0x0041,0x0052
0000d0  004d0020          DCW      0x004d,0x0020
0000d4  00730065          DCW      0x0073,0x0065
0000d8  00720069          DCW      0x0072,0x0069
0000dc  00650073          DCW      0x0065,0x0073
                          %        180
                  g_HID_au8KeyboardReportDescriptor
000194  05010906          DCB      0x05,0x01,0x09,0x06
000198  a1018501          DCB      0xa1,0x01,0x85,0x01
00019c  050719e0          DCB      0x05,0x07,0x19,0xe0
0001a0  29e71500          DCB      0x29,0xe7,0x15,0x00
0001a4  25017501          DCB      0x25,0x01,0x75,0x01
0001a8  95088102          DCB      0x95,0x08,0x81,0x02
0001ac  95017508          DCB      0x95,0x01,0x75,0x08
0001b0  81019505          DCB      0x81,0x01,0x95,0x05
0001b4  75010508          DCB      0x75,0x01,0x05,0x08
0001b8  19012905          DCB      0x19,0x01,0x29,0x05
0001bc  91029501          DCB      0x91,0x02,0x95,0x01
0001c0  75039101          DCB      0x75,0x03,0x91,0x01
0001c4  95067508          DCB      0x95,0x06,0x75,0x08
0001c8  15002565          DCB      0x15,0x00,0x25,0x65
0001cc  05071900          DCB      0x05,0x07,0x19,0x00
0001d0  29658100          DCB      0x29,0x65,0x81,0x00
0001d4  c0050c09          DCB      0xc0,0x05,0x0c,0x09
0001d8  01a10185          DCB      0x01,0xa1,0x01,0x85
0001dc  02150025          DCB      0x02,0x15,0x00,0x25
0001e0  0109e209          DCB      0x01,0x09,0xe2,0x09
0001e4  e909ea09          DCB      0xe9,0x09,0xea,0x09
0001e8  6f097075          DCB      0x6f,0x09,0x70,0x75
0001ec  01950581          DCB      0x01,0x95,0x05,0x81
0001f0  02050109          DCB      0x02,0x05,0x01,0x09
0001f4  82750195          DCB      0x82,0x75,0x01,0x95
0001f8  01810275          DCB      0x01,0x81,0x02,0x75
0001fc  01950281          DCB      0x01,0x95,0x02,0x81
000200  03c00000          DCB      0x03,0xc0,0x00,0x00
                  g_HID_u32KeyboardReportDescriptorSize
                          DCD      0x0000006e
                  g_u32KeyboardReportSize
                          DCD      0x00000009
                  g_HID_au8DeviceDescriptor
00020c  12010002          DCB      0x12,0x01,0x00,0x02
000210  00000008          DCB      0x00,0x00,0x00,0x08
000214  160441c1          DCB      0x16,0x04,0x41,0xc1
000218  00000102          DCB      0x00,0x00,0x01,0x02
00021c  0001              DCB      0x00,0x01
                  g_HID_au8ConfigDescriptor
00021e  0902              DCB      0x09,0x02
000220  22000101          DCB      0x22,0x00,0x01,0x01
000224  00a03209          DCB      0x00,0xa0,0x32,0x09
000228  04000001          DCB      0x04,0x00,0x00,0x01
00022c  03010100          DCB      0x03,0x01,0x01,0x00
000230  09211001          DCB      0x09,0x21,0x10,0x01
000234  0001226e          DCB      0x00,0x01,0x22,0x6e
000238  00070581          DCB      0x00,0x07,0x05,0x81
00023c  03400014          DCB      0x03,0x40,0x00,0x14
                  g_HID_au8StringLang
000240  04030904          DCB      0x04,0x03,0x09,0x04
                  g_HID_sVendorStringDesc
000244  1003              DCB      0x10,0x03
000246  004e              DCW      0x004e
000248  00550056          DCW      0x0055,0x0056
00024c  004f0054          DCW      0x004f,0x0054
000250  004f004e          DCW      0x004f,0x004e
                          %        184
00030c  0000              DCB      0x00,0x00
                  g_HID_sProductStringDesc
00030e  1003              DCB      0x10,0x03
000310  00570050          DCW      0x0057,0x0050
000314  004d0020          DCW      0x004d,0x0020
000318  00550053          DCW      0x0055,0x0053
00031c  0042              DCW      0x0042
00031e  0000              DCB      0x00,0x00
                          %        184
                  g_HID_au8StringSerial
0003d8  1a034200          DCB      0x1a,0x03,0x42,0x00
0003dc  30003200          DCB      0x30,0x00,0x32,0x00
0003e0  30003000          DCB      0x30,0x00,0x30,0x00
0003e4  36003000          DCB      0x36,0x00,0x30,0x00
0003e8  39003200          DCB      0x39,0x00,0x32,0x00
0003ec  31003100          DCB      0x31,0x00,0x31,0x00
0003f0  34000000          DCB      0x34,0x00,0x00,0x00
0003f4  41444320          DCB      0x41,0x44,0x43,0x20
0003f8  56616c75          DCB      0x56,0x61,0x6c,0x75
0003fc  653a0000          DCB      0x65,0x3a,0x00,0x00
000400  000000            DCB      0x00,0x00,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  preKey
                          DCD      0x00000000
                  ADC_result
000004  0000              DCB      0x00,0x00
